var N = null;var searchIndex = {};
searchIndex["numext_fixed_uint"]={"doc":"","items":[[3,"U128","numext_fixed_uint","",N,N],[3,"U160","","",N,N],[3,"U224","","",N,N],[3,"U256","","",N,N],[3,"U384","","",N,N],[3,"U512","","",N,N],[3,"U1024","","",N,N],[3,"U2048","","",N,N],[3,"U4096","","",N,N],[4,"FromBytesError","","Error for parse from bytes.",N,N],[13,"InvalidLength","","",0,N],[4,"IntoBytesError","","Error for parse from bytes.",N,N],[13,"InvalidLength","","",1,N],[4,"FromStrError","","Error for parse from string.",N,N],[13,"InvalidCharacter","","",2,N],[12,"chr","numext_fixed_uint::FromStrError","",2,N],[12,"idx","","",2,N],[13,"InvalidLength","numext_fixed_uint","",2,N],[13,"Overflow","","",2,N],[4,"FixedUintError","","",N,N],[13,"FromBytes","","",3,N],[13,"IntoBytes","","",3,N],[13,"FromStr","","",3,N],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"from","","",3,[[["frombyteserror"]],["fixeduinterror"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"from","","",3,[[["intobyteserror"]],["fixeduinterror"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"from","","",3,[[["fromstrerror"]],["fixeduinterror"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"zero","","Create a new fixed uint and value is zero.",4,[[],["self"]]],[11,"one","","Create a new fixed uint and value is zero.",4,[[],["self"]]],[11,"is_zero","","Test if a fixed uint is zero.",4,[[["self"]],["bool"]]],[11,"is_max","","Test if a fixed uint is the max value.",4,[[["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",4,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",4,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",4,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",4,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",4,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",4,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",4,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",4,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",4,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",4,[[["self"]],["option",["usize"]]]],[11,"complete_mul","","Calculates the multiplication of `self` and `other`.",4,N],[11,"complete_div","","Calculates both the quotient and the remainder when `self` is divided by `other`.",4,N],[11,"from_little_endian","","Convert from little-endian bytes.",4,N],[11,"from_big_endian","","Convert from big-endian bytes.",4,N],[11,"into_little_endian","","Convert into little-endian bytes.",4,N],[11,"into_big_endian","","Convert into big-endian bytes.",4,N],[11,"from_bin_str","","Convert from a binary string.",4,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_oct_str","","Convert from a octal string.",4,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_hex_str","","Convert from a hexadecimal string.",4,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_dec_str","","Convert from a decimal string.",4,[[["str"]],["result",["fixeduinterror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",4,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",4,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",4,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",4,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",4,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",4,[[["self"]],["u32"]]],[11,"checked_add","","Checked integer addition. Computes `self + rhs`, returning `None` if overflow occurred.",4,[[["self"],["self"]],["option"]]],[11,"checked_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",4,[[["self"],["self"]],["option"]]],[11,"checked_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",4,[[["self"],["self"]],["option"]]],[11,"checked_div","","Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`.",4,[[["self"],["self"]],["option"]]],[11,"checked_rem","","Checked integer remainder. Computes `self % rhs`, returning `None` if `rhs == 0`.",4,[[["self"],["self"]],["option"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",4,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",4,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",4,[[["self"]],["option"]]],[11,"saturating_add","","Saturating integer addition. Computes `self + rhs`, saturating at the numeric bounds instead of overflowing.",4,[[["self"],["self"]],["self"]]],[11,"saturating_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",4,[[["self"],["self"]],["self"]]],[11,"saturating_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",4,[[["self"],["self"]],["self"]]],[11,"overflowing_add","","Calculates `self + rhs`.",4,N],[11,"overflowing_sub","","Calculates `self - rhs`.",4,N],[11,"overflowing_mul","","Calculates the multiplication of `self` and `rhs`.",4,N],[11,"overflowing_div","","Calculates the divisor when `self` is divided by `rhs`.",4,N],[11,"overflowing_rem","","Calculates the remainder when `self` is divided by `rhs`.",4,N],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",4,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",4,N],[11,"overflowing_neg","","Negates `self` in an overflowing fashion.",4,N],[11,"random","","Create a random fixed uint with a input random core.",4,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",4,[[],["self"]]],[11,"clone","","",4,[[["self"]],["self"]]],[11,"default","","",4,[[],["self"]]],[11,"eq","","",4,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",4,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",4,[[["self"],["self"]],["ordering"]]],[11,"add","","",4,N],[11,"add_assign","","",4,[[["self"],["rhs"]]]],[11,"add","","",4,N],[11,"add_assign","","",4,[[["self"],["u128"]]]],[11,"sub","","",4,N],[11,"sub_assign","","",4,[[["self"],["rhs"]]]],[11,"sub","","",4,N],[11,"sub_assign","","",4,[[["self"],["u128"]]]],[11,"mul","","",4,N],[11,"mul_assign","","",4,[[["self"],["rhs"]]]],[11,"mul","","",4,N],[11,"mul_assign","","",4,[[["self"],["u128"]]]],[11,"div","","",4,N],[11,"div_assign","","",4,[[["self"],["rhs"]]]],[11,"div","","",4,N],[11,"div_assign","","",4,[[["self"],["u128"]]]],[11,"rem","","",4,N],[11,"rem_assign","","",4,[[["self"],["rhs"]]]],[11,"rem","","",4,N],[11,"rem_assign","","",4,[[["self"],["u128"]]]],[11,"bitand","","",4,N],[11,"bitand_assign","","",4,[[["self"],["rhs"]]]],[11,"bitand","","",4,N],[11,"bitand_assign","","",4,[[["self"],["u128"]]]],[11,"bitor","","",4,N],[11,"bitor_assign","","",4,[[["self"],["rhs"]]]],[11,"bitor","","",4,N],[11,"bitor_assign","","",4,[[["self"],["u128"]]]],[11,"bitxor","","",4,N],[11,"bitxor_assign","","",4,[[["self"],["rhs"]]]],[11,"bitxor","","",4,N],[11,"bitxor_assign","","",4,[[["self"],["u128"]]]],[11,"not","","",4,N],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["u8"]]]],[11,"shl_assign","","",4,[[["self"],["u8"]]]],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["u16"]]]],[11,"shl_assign","","",4,[[["self"],["u16"]]]],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["u32"]]]],[11,"shl_assign","","",4,[[["self"],["u32"]]]],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["u64"]]]],[11,"shl_assign","","",4,[[["self"],["u64"]]]],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["u128"]]]],[11,"shl_assign","","",4,[[["self"],["u128"]]]],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["usize"]]]],[11,"shl_assign","","",4,[[["self"],["usize"]]]],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["i8"]]]],[11,"shl_assign","","",4,[[["self"],["i8"]]]],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["i16"]]]],[11,"shl_assign","","",4,[[["self"],["i16"]]]],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["i32"]]]],[11,"shl_assign","","",4,[[["self"],["i32"]]]],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["i64"]]]],[11,"shl_assign","","",4,[[["self"],["i64"]]]],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["i128"]]]],[11,"shl_assign","","",4,[[["self"],["i128"]]]],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["isize"]]]],[11,"shl_assign","","",4,[[["self"],["isize"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["u8"]]]],[11,"shr_assign","","",4,[[["self"],["u8"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["u16"]]]],[11,"shr_assign","","",4,[[["self"],["u16"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["u32"]]]],[11,"shr_assign","","",4,[[["self"],["u32"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["u64"]]]],[11,"shr_assign","","",4,[[["self"],["u64"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["u128"]]]],[11,"shr_assign","","",4,[[["self"],["u128"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["usize"]]]],[11,"shr_assign","","",4,[[["self"],["usize"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["i8"]]]],[11,"shr_assign","","",4,[[["self"],["i8"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["i16"]]]],[11,"shr_assign","","",4,[[["self"],["i16"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["i32"]]]],[11,"shr_assign","","",4,[[["self"],["i32"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["i64"]]]],[11,"shr_assign","","",4,[[["self"],["i64"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["i128"]]]],[11,"shr_assign","","",4,[[["self"],["i128"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["isize"]]]],[11,"shr_assign","","",4,[[["self"],["isize"]]]],[11,"from","","",4,[[["bool"]],["self"]]],[11,"from","","",4,[[["u8"]],["self"]]],[11,"from","","",4,[[["u8"]],["self"]]],[11,"from","","",4,[[["u16"]],["self"]]],[11,"from","","",4,[[["u16"]],["self"]]],[11,"from","","",4,[[["u32"]],["self"]]],[11,"from","","",4,[[["u32"]],["self"]]],[11,"from","","",4,[[["u64"]],["self"]]],[11,"from","","",4,[[["u64"]],["self"]]],[11,"from","","",4,[[["u128"]],["self"]]],[11,"from","","",4,[[["u128"]],["self"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"hash","","",4,[[["self"],["h"]]]],[11,"sum","","",4,[[["i"]],["self"]]],[11,"sum","","",4,[[["i"]],["self"]]],[11,"product","","",4,[[["i"]],["self"]]],[11,"product","","",4,[[["i"]],["self"]]],[11,"zero","","Create a new fixed uint and value is zero.",5,[[],["self"]]],[11,"one","","Create a new fixed uint and value is zero.",5,[[],["self"]]],[11,"is_zero","","Test if a fixed uint is zero.",5,[[["self"]],["bool"]]],[11,"is_max","","Test if a fixed uint is the max value.",5,[[["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",5,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",5,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",5,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",5,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",5,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",5,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",5,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",5,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",5,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",5,[[["self"]],["option",["usize"]]]],[11,"complete_mul","","Calculates the multiplication of `self` and `other`.",5,N],[11,"complete_div","","Calculates both the quotient and the remainder when `self` is divided by `other`.",5,N],[11,"from_little_endian","","Convert from little-endian bytes.",5,N],[11,"from_big_endian","","Convert from big-endian bytes.",5,N],[11,"into_little_endian","","Convert into little-endian bytes.",5,N],[11,"into_big_endian","","Convert into big-endian bytes.",5,N],[11,"from_bin_str","","Convert from a binary string.",5,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_oct_str","","Convert from a octal string.",5,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_hex_str","","Convert from a hexadecimal string.",5,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_dec_str","","Convert from a decimal string.",5,[[["str"]],["result",["fixeduinterror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",5,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",5,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",5,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",5,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",5,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",5,[[["self"]],["u32"]]],[11,"checked_add","","Checked integer addition. Computes `self + rhs`, returning `None` if overflow occurred.",5,[[["self"],["self"]],["option"]]],[11,"checked_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",5,[[["self"],["self"]],["option"]]],[11,"checked_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",5,[[["self"],["self"]],["option"]]],[11,"checked_div","","Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`.",5,[[["self"],["self"]],["option"]]],[11,"checked_rem","","Checked integer remainder. Computes `self % rhs`, returning `None` if `rhs == 0`.",5,[[["self"],["self"]],["option"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",5,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",5,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",5,[[["self"]],["option"]]],[11,"saturating_add","","Saturating integer addition. Computes `self + rhs`, saturating at the numeric bounds instead of overflowing.",5,[[["self"],["self"]],["self"]]],[11,"saturating_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",5,[[["self"],["self"]],["self"]]],[11,"saturating_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",5,[[["self"],["self"]],["self"]]],[11,"overflowing_add","","Calculates `self + rhs`.",5,N],[11,"overflowing_sub","","Calculates `self - rhs`.",5,N],[11,"overflowing_mul","","Calculates the multiplication of `self` and `rhs`.",5,N],[11,"overflowing_div","","Calculates the divisor when `self` is divided by `rhs`.",5,N],[11,"overflowing_rem","","Calculates the remainder when `self` is divided by `rhs`.",5,N],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",5,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",5,N],[11,"overflowing_neg","","Negates `self` in an overflowing fashion.",5,N],[11,"random","","Create a random fixed uint with a input random core.",5,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",5,[[],["self"]]],[11,"clone","","",5,[[["self"]],["self"]]],[11,"default","","",5,[[],["self"]]],[11,"eq","","",5,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",5,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",5,[[["self"],["self"]],["ordering"]]],[11,"add","","",5,N],[11,"add_assign","","",5,[[["self"],["rhs"]]]],[11,"add","","",5,N],[11,"add_assign","","",5,[[["self"],["u160"]]]],[11,"sub","","",5,N],[11,"sub_assign","","",5,[[["self"],["rhs"]]]],[11,"sub","","",5,N],[11,"sub_assign","","",5,[[["self"],["u160"]]]],[11,"mul","","",5,N],[11,"mul_assign","","",5,[[["self"],["rhs"]]]],[11,"mul","","",5,N],[11,"mul_assign","","",5,[[["self"],["u160"]]]],[11,"div","","",5,N],[11,"div_assign","","",5,[[["self"],["rhs"]]]],[11,"div","","",5,N],[11,"div_assign","","",5,[[["self"],["u160"]]]],[11,"rem","","",5,N],[11,"rem_assign","","",5,[[["self"],["rhs"]]]],[11,"rem","","",5,N],[11,"rem_assign","","",5,[[["self"],["u160"]]]],[11,"bitand","","",5,N],[11,"bitand_assign","","",5,[[["self"],["rhs"]]]],[11,"bitand","","",5,N],[11,"bitand_assign","","",5,[[["self"],["u160"]]]],[11,"bitor","","",5,N],[11,"bitor_assign","","",5,[[["self"],["rhs"]]]],[11,"bitor","","",5,N],[11,"bitor_assign","","",5,[[["self"],["u160"]]]],[11,"bitxor","","",5,N],[11,"bitxor_assign","","",5,[[["self"],["rhs"]]]],[11,"bitxor","","",5,N],[11,"bitxor_assign","","",5,[[["self"],["u160"]]]],[11,"not","","",5,N],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["u8"]]]],[11,"shl_assign","","",5,[[["self"],["u8"]]]],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["u16"]]]],[11,"shl_assign","","",5,[[["self"],["u16"]]]],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["u32"]]]],[11,"shl_assign","","",5,[[["self"],["u32"]]]],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["u64"]]]],[11,"shl_assign","","",5,[[["self"],["u64"]]]],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["u128"]]]],[11,"shl_assign","","",5,[[["self"],["u128"]]]],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["usize"]]]],[11,"shl_assign","","",5,[[["self"],["usize"]]]],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["i8"]]]],[11,"shl_assign","","",5,[[["self"],["i8"]]]],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["i16"]]]],[11,"shl_assign","","",5,[[["self"],["i16"]]]],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["i32"]]]],[11,"shl_assign","","",5,[[["self"],["i32"]]]],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["i64"]]]],[11,"shl_assign","","",5,[[["self"],["i64"]]]],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["i128"]]]],[11,"shl_assign","","",5,[[["self"],["i128"]]]],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["isize"]]]],[11,"shl_assign","","",5,[[["self"],["isize"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["u8"]]]],[11,"shr_assign","","",5,[[["self"],["u8"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["u16"]]]],[11,"shr_assign","","",5,[[["self"],["u16"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["u32"]]]],[11,"shr_assign","","",5,[[["self"],["u32"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["u64"]]]],[11,"shr_assign","","",5,[[["self"],["u64"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["u128"]]]],[11,"shr_assign","","",5,[[["self"],["u128"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["usize"]]]],[11,"shr_assign","","",5,[[["self"],["usize"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["i8"]]]],[11,"shr_assign","","",5,[[["self"],["i8"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["i16"]]]],[11,"shr_assign","","",5,[[["self"],["i16"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["i32"]]]],[11,"shr_assign","","",5,[[["self"],["i32"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["i64"]]]],[11,"shr_assign","","",5,[[["self"],["i64"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["i128"]]]],[11,"shr_assign","","",5,[[["self"],["i128"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["isize"]]]],[11,"shr_assign","","",5,[[["self"],["isize"]]]],[11,"from","","",5,[[["bool"]],["self"]]],[11,"from","","",5,[[["u8"]],["self"]]],[11,"from","","",5,[[["u8"]],["self"]]],[11,"from","","",5,[[["u16"]],["self"]]],[11,"from","","",5,[[["u16"]],["self"]]],[11,"from","","",5,[[["u32"]],["self"]]],[11,"from","","",5,[[["u32"]],["self"]]],[11,"from","","",5,[[["u64"]],["self"]]],[11,"from","","",5,[[["u64"]],["self"]]],[11,"from","","",5,[[["u128"]],["self"]]],[11,"from","","",5,[[["u128"]],["self"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"hash","","",5,[[["self"],["h"]]]],[11,"sum","","",5,[[["i"]],["self"]]],[11,"sum","","",5,[[["i"]],["self"]]],[11,"product","","",5,[[["i"]],["self"]]],[11,"product","","",5,[[["i"]],["self"]]],[11,"zero","","Create a new fixed uint and value is zero.",6,[[],["self"]]],[11,"one","","Create a new fixed uint and value is zero.",6,[[],["self"]]],[11,"is_zero","","Test if a fixed uint is zero.",6,[[["self"]],["bool"]]],[11,"is_max","","Test if a fixed uint is the max value.",6,[[["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",6,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",6,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",6,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",6,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",6,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",6,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",6,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",6,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",6,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",6,[[["self"]],["option",["usize"]]]],[11,"complete_mul","","Calculates the multiplication of `self` and `other`.",6,N],[11,"complete_div","","Calculates both the quotient and the remainder when `self` is divided by `other`.",6,N],[11,"from_little_endian","","Convert from little-endian bytes.",6,N],[11,"from_big_endian","","Convert from big-endian bytes.",6,N],[11,"into_little_endian","","Convert into little-endian bytes.",6,N],[11,"into_big_endian","","Convert into big-endian bytes.",6,N],[11,"from_bin_str","","Convert from a binary string.",6,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_oct_str","","Convert from a octal string.",6,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_hex_str","","Convert from a hexadecimal string.",6,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_dec_str","","Convert from a decimal string.",6,[[["str"]],["result",["fixeduinterror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",6,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",6,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",6,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",6,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",6,[[["self"]],["u32"]]],[11,"checked_add","","Checked integer addition. Computes `self + rhs`, returning `None` if overflow occurred.",6,[[["self"],["self"]],["option"]]],[11,"checked_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",6,[[["self"],["self"]],["option"]]],[11,"checked_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",6,[[["self"],["self"]],["option"]]],[11,"checked_div","","Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`.",6,[[["self"],["self"]],["option"]]],[11,"checked_rem","","Checked integer remainder. Computes `self % rhs`, returning `None` if `rhs == 0`.",6,[[["self"],["self"]],["option"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",6,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",6,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",6,[[["self"]],["option"]]],[11,"saturating_add","","Saturating integer addition. Computes `self + rhs`, saturating at the numeric bounds instead of overflowing.",6,[[["self"],["self"]],["self"]]],[11,"saturating_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",6,[[["self"],["self"]],["self"]]],[11,"saturating_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",6,[[["self"],["self"]],["self"]]],[11,"overflowing_add","","Calculates `self + rhs`.",6,N],[11,"overflowing_sub","","Calculates `self - rhs`.",6,N],[11,"overflowing_mul","","Calculates the multiplication of `self` and `rhs`.",6,N],[11,"overflowing_div","","Calculates the divisor when `self` is divided by `rhs`.",6,N],[11,"overflowing_rem","","Calculates the remainder when `self` is divided by `rhs`.",6,N],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",6,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",6,N],[11,"overflowing_neg","","Negates `self` in an overflowing fashion.",6,N],[11,"random","","Create a random fixed uint with a input random core.",6,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",6,[[],["self"]]],[11,"clone","","",6,[[["self"]],["self"]]],[11,"default","","",6,[[],["self"]]],[11,"eq","","",6,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",6,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",6,[[["self"],["self"]],["ordering"]]],[11,"add","","",6,N],[11,"add_assign","","",6,[[["self"],["rhs"]]]],[11,"add","","",6,N],[11,"add_assign","","",6,[[["self"],["u224"]]]],[11,"sub","","",6,N],[11,"sub_assign","","",6,[[["self"],["rhs"]]]],[11,"sub","","",6,N],[11,"sub_assign","","",6,[[["self"],["u224"]]]],[11,"mul","","",6,N],[11,"mul_assign","","",6,[[["self"],["rhs"]]]],[11,"mul","","",6,N],[11,"mul_assign","","",6,[[["self"],["u224"]]]],[11,"div","","",6,N],[11,"div_assign","","",6,[[["self"],["rhs"]]]],[11,"div","","",6,N],[11,"div_assign","","",6,[[["self"],["u224"]]]],[11,"rem","","",6,N],[11,"rem_assign","","",6,[[["self"],["rhs"]]]],[11,"rem","","",6,N],[11,"rem_assign","","",6,[[["self"],["u224"]]]],[11,"bitand","","",6,N],[11,"bitand_assign","","",6,[[["self"],["rhs"]]]],[11,"bitand","","",6,N],[11,"bitand_assign","","",6,[[["self"],["u224"]]]],[11,"bitor","","",6,N],[11,"bitor_assign","","",6,[[["self"],["rhs"]]]],[11,"bitor","","",6,N],[11,"bitor_assign","","",6,[[["self"],["u224"]]]],[11,"bitxor","","",6,N],[11,"bitxor_assign","","",6,[[["self"],["rhs"]]]],[11,"bitxor","","",6,N],[11,"bitxor_assign","","",6,[[["self"],["u224"]]]],[11,"not","","",6,N],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["u8"]]]],[11,"shl_assign","","",6,[[["self"],["u8"]]]],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["u16"]]]],[11,"shl_assign","","",6,[[["self"],["u16"]]]],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["u32"]]]],[11,"shl_assign","","",6,[[["self"],["u32"]]]],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["u64"]]]],[11,"shl_assign","","",6,[[["self"],["u64"]]]],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["u128"]]]],[11,"shl_assign","","",6,[[["self"],["u128"]]]],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["usize"]]]],[11,"shl_assign","","",6,[[["self"],["usize"]]]],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["i8"]]]],[11,"shl_assign","","",6,[[["self"],["i8"]]]],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["i16"]]]],[11,"shl_assign","","",6,[[["self"],["i16"]]]],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["i32"]]]],[11,"shl_assign","","",6,[[["self"],["i32"]]]],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["i64"]]]],[11,"shl_assign","","",6,[[["self"],["i64"]]]],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["i128"]]]],[11,"shl_assign","","",6,[[["self"],["i128"]]]],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["isize"]]]],[11,"shl_assign","","",6,[[["self"],["isize"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["u8"]]]],[11,"shr_assign","","",6,[[["self"],["u8"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["u16"]]]],[11,"shr_assign","","",6,[[["self"],["u16"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["u32"]]]],[11,"shr_assign","","",6,[[["self"],["u32"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["u64"]]]],[11,"shr_assign","","",6,[[["self"],["u64"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["u128"]]]],[11,"shr_assign","","",6,[[["self"],["u128"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["usize"]]]],[11,"shr_assign","","",6,[[["self"],["usize"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["i8"]]]],[11,"shr_assign","","",6,[[["self"],["i8"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["i16"]]]],[11,"shr_assign","","",6,[[["self"],["i16"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["i32"]]]],[11,"shr_assign","","",6,[[["self"],["i32"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["i64"]]]],[11,"shr_assign","","",6,[[["self"],["i64"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["i128"]]]],[11,"shr_assign","","",6,[[["self"],["i128"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["isize"]]]],[11,"shr_assign","","",6,[[["self"],["isize"]]]],[11,"from","","",6,[[["bool"]],["self"]]],[11,"from","","",6,[[["u8"]],["self"]]],[11,"from","","",6,[[["u8"]],["self"]]],[11,"from","","",6,[[["u16"]],["self"]]],[11,"from","","",6,[[["u16"]],["self"]]],[11,"from","","",6,[[["u32"]],["self"]]],[11,"from","","",6,[[["u32"]],["self"]]],[11,"from","","",6,[[["u64"]],["self"]]],[11,"from","","",6,[[["u64"]],["self"]]],[11,"from","","",6,[[["u128"]],["self"]]],[11,"from","","",6,[[["u128"]],["self"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"hash","","",6,[[["self"],["h"]]]],[11,"sum","","",6,[[["i"]],["self"]]],[11,"sum","","",6,[[["i"]],["self"]]],[11,"product","","",6,[[["i"]],["self"]]],[11,"product","","",6,[[["i"]],["self"]]],[11,"zero","","Create a new fixed uint and value is zero.",7,[[],["self"]]],[11,"one","","Create a new fixed uint and value is zero.",7,[[],["self"]]],[11,"is_zero","","Test if a fixed uint is zero.",7,[[["self"]],["bool"]]],[11,"is_max","","Test if a fixed uint is the max value.",7,[[["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",7,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",7,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",7,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",7,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",7,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",7,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",7,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",7,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",7,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",7,[[["self"]],["option",["usize"]]]],[11,"complete_mul","","Calculates the multiplication of `self` and `other`.",7,N],[11,"complete_div","","Calculates both the quotient and the remainder when `self` is divided by `other`.",7,N],[11,"from_little_endian","","Convert from little-endian bytes.",7,N],[11,"from_big_endian","","Convert from big-endian bytes.",7,N],[11,"into_little_endian","","Convert into little-endian bytes.",7,N],[11,"into_big_endian","","Convert into big-endian bytes.",7,N],[11,"from_bin_str","","Convert from a binary string.",7,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_oct_str","","Convert from a octal string.",7,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_hex_str","","Convert from a hexadecimal string.",7,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_dec_str","","Convert from a decimal string.",7,[[["str"]],["result",["fixeduinterror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",7,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",7,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",7,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",7,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",7,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",7,[[["self"]],["u32"]]],[11,"checked_add","","Checked integer addition. Computes `self + rhs`, returning `None` if overflow occurred.",7,[[["self"],["self"]],["option"]]],[11,"checked_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",7,[[["self"],["self"]],["option"]]],[11,"checked_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",7,[[["self"],["self"]],["option"]]],[11,"checked_div","","Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`.",7,[[["self"],["self"]],["option"]]],[11,"checked_rem","","Checked integer remainder. Computes `self % rhs`, returning `None` if `rhs == 0`.",7,[[["self"],["self"]],["option"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",7,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",7,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",7,[[["self"]],["option"]]],[11,"saturating_add","","Saturating integer addition. Computes `self + rhs`, saturating at the numeric bounds instead of overflowing.",7,[[["self"],["self"]],["self"]]],[11,"saturating_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",7,[[["self"],["self"]],["self"]]],[11,"saturating_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",7,[[["self"],["self"]],["self"]]],[11,"overflowing_add","","Calculates `self + rhs`.",7,N],[11,"overflowing_sub","","Calculates `self - rhs`.",7,N],[11,"overflowing_mul","","Calculates the multiplication of `self` and `rhs`.",7,N],[11,"overflowing_div","","Calculates the divisor when `self` is divided by `rhs`.",7,N],[11,"overflowing_rem","","Calculates the remainder when `self` is divided by `rhs`.",7,N],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",7,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",7,N],[11,"overflowing_neg","","Negates `self` in an overflowing fashion.",7,N],[11,"random","","Create a random fixed uint with a input random core.",7,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",7,[[],["self"]]],[11,"clone","","",7,[[["self"]],["self"]]],[11,"default","","",7,[[],["self"]]],[11,"eq","","",7,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",7,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",7,[[["self"],["self"]],["ordering"]]],[11,"add","","",7,N],[11,"add_assign","","",7,[[["self"],["rhs"]]]],[11,"add","","",7,N],[11,"add_assign","","",7,[[["self"],["u256"]]]],[11,"sub","","",7,N],[11,"sub_assign","","",7,[[["self"],["rhs"]]]],[11,"sub","","",7,N],[11,"sub_assign","","",7,[[["self"],["u256"]]]],[11,"mul","","",7,N],[11,"mul_assign","","",7,[[["self"],["rhs"]]]],[11,"mul","","",7,N],[11,"mul_assign","","",7,[[["self"],["u256"]]]],[11,"div","","",7,N],[11,"div_assign","","",7,[[["self"],["rhs"]]]],[11,"div","","",7,N],[11,"div_assign","","",7,[[["self"],["u256"]]]],[11,"rem","","",7,N],[11,"rem_assign","","",7,[[["self"],["rhs"]]]],[11,"rem","","",7,N],[11,"rem_assign","","",7,[[["self"],["u256"]]]],[11,"bitand","","",7,N],[11,"bitand_assign","","",7,[[["self"],["rhs"]]]],[11,"bitand","","",7,N],[11,"bitand_assign","","",7,[[["self"],["u256"]]]],[11,"bitor","","",7,N],[11,"bitor_assign","","",7,[[["self"],["rhs"]]]],[11,"bitor","","",7,N],[11,"bitor_assign","","",7,[[["self"],["u256"]]]],[11,"bitxor","","",7,N],[11,"bitxor_assign","","",7,[[["self"],["rhs"]]]],[11,"bitxor","","",7,N],[11,"bitxor_assign","","",7,[[["self"],["u256"]]]],[11,"not","","",7,N],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["u8"]]]],[11,"shl_assign","","",7,[[["self"],["u8"]]]],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["u16"]]]],[11,"shl_assign","","",7,[[["self"],["u16"]]]],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["u32"]]]],[11,"shl_assign","","",7,[[["self"],["u32"]]]],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["u64"]]]],[11,"shl_assign","","",7,[[["self"],["u64"]]]],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["u128"]]]],[11,"shl_assign","","",7,[[["self"],["u128"]]]],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["usize"]]]],[11,"shl_assign","","",7,[[["self"],["usize"]]]],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["i8"]]]],[11,"shl_assign","","",7,[[["self"],["i8"]]]],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["i16"]]]],[11,"shl_assign","","",7,[[["self"],["i16"]]]],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["i32"]]]],[11,"shl_assign","","",7,[[["self"],["i32"]]]],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["i64"]]]],[11,"shl_assign","","",7,[[["self"],["i64"]]]],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["i128"]]]],[11,"shl_assign","","",7,[[["self"],["i128"]]]],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["isize"]]]],[11,"shl_assign","","",7,[[["self"],["isize"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["u8"]]]],[11,"shr_assign","","",7,[[["self"],["u8"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["u16"]]]],[11,"shr_assign","","",7,[[["self"],["u16"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["u32"]]]],[11,"shr_assign","","",7,[[["self"],["u32"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["u64"]]]],[11,"shr_assign","","",7,[[["self"],["u64"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["u128"]]]],[11,"shr_assign","","",7,[[["self"],["u128"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["usize"]]]],[11,"shr_assign","","",7,[[["self"],["usize"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["i8"]]]],[11,"shr_assign","","",7,[[["self"],["i8"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["i16"]]]],[11,"shr_assign","","",7,[[["self"],["i16"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["i32"]]]],[11,"shr_assign","","",7,[[["self"],["i32"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["i64"]]]],[11,"shr_assign","","",7,[[["self"],["i64"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["i128"]]]],[11,"shr_assign","","",7,[[["self"],["i128"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["isize"]]]],[11,"shr_assign","","",7,[[["self"],["isize"]]]],[11,"from","","",7,[[["bool"]],["self"]]],[11,"from","","",7,[[["u8"]],["self"]]],[11,"from","","",7,[[["u8"]],["self"]]],[11,"from","","",7,[[["u16"]],["self"]]],[11,"from","","",7,[[["u16"]],["self"]]],[11,"from","","",7,[[["u32"]],["self"]]],[11,"from","","",7,[[["u32"]],["self"]]],[11,"from","","",7,[[["u64"]],["self"]]],[11,"from","","",7,[[["u64"]],["self"]]],[11,"from","","",7,[[["u128"]],["self"]]],[11,"from","","",7,[[["u128"]],["self"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"hash","","",7,[[["self"],["h"]]]],[11,"sum","","",7,[[["i"]],["self"]]],[11,"sum","","",7,[[["i"]],["self"]]],[11,"product","","",7,[[["i"]],["self"]]],[11,"product","","",7,[[["i"]],["self"]]],[11,"zero","","Create a new fixed uint and value is zero.",8,[[],["self"]]],[11,"one","","Create a new fixed uint and value is zero.",8,[[],["self"]]],[11,"is_zero","","Test if a fixed uint is zero.",8,[[["self"]],["bool"]]],[11,"is_max","","Test if a fixed uint is the max value.",8,[[["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",8,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",8,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",8,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",8,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",8,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",8,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",8,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",8,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",8,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",8,[[["self"]],["option",["usize"]]]],[11,"complete_mul","","Calculates the multiplication of `self` and `other`.",8,N],[11,"complete_div","","Calculates both the quotient and the remainder when `self` is divided by `other`.",8,N],[11,"from_little_endian","","Convert from little-endian bytes.",8,N],[11,"from_big_endian","","Convert from big-endian bytes.",8,N],[11,"into_little_endian","","Convert into little-endian bytes.",8,N],[11,"into_big_endian","","Convert into big-endian bytes.",8,N],[11,"from_bin_str","","Convert from a binary string.",8,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_oct_str","","Convert from a octal string.",8,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_hex_str","","Convert from a hexadecimal string.",8,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_dec_str","","Convert from a decimal string.",8,[[["str"]],["result",["fixeduinterror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",8,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",8,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",8,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",8,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",8,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",8,[[["self"]],["u32"]]],[11,"checked_add","","Checked integer addition. Computes `self + rhs`, returning `None` if overflow occurred.",8,[[["self"],["self"]],["option"]]],[11,"checked_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",8,[[["self"],["self"]],["option"]]],[11,"checked_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",8,[[["self"],["self"]],["option"]]],[11,"checked_div","","Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`.",8,[[["self"],["self"]],["option"]]],[11,"checked_rem","","Checked integer remainder. Computes `self % rhs`, returning `None` if `rhs == 0`.",8,[[["self"],["self"]],["option"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",8,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",8,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",8,[[["self"]],["option"]]],[11,"saturating_add","","Saturating integer addition. Computes `self + rhs`, saturating at the numeric bounds instead of overflowing.",8,[[["self"],["self"]],["self"]]],[11,"saturating_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",8,[[["self"],["self"]],["self"]]],[11,"saturating_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",8,[[["self"],["self"]],["self"]]],[11,"overflowing_add","","Calculates `self + rhs`.",8,N],[11,"overflowing_sub","","Calculates `self - rhs`.",8,N],[11,"overflowing_mul","","Calculates the multiplication of `self` and `rhs`.",8,N],[11,"overflowing_div","","Calculates the divisor when `self` is divided by `rhs`.",8,N],[11,"overflowing_rem","","Calculates the remainder when `self` is divided by `rhs`.",8,N],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",8,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",8,N],[11,"overflowing_neg","","Negates `self` in an overflowing fashion.",8,N],[11,"random","","Create a random fixed uint with a input random core.",8,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",8,[[],["self"]]],[11,"clone","","",8,[[["self"]],["self"]]],[11,"default","","",8,[[],["self"]]],[11,"eq","","",8,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",8,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",8,[[["self"],["self"]],["ordering"]]],[11,"add","","",8,N],[11,"add_assign","","",8,[[["self"],["rhs"]]]],[11,"add","","",8,N],[11,"add_assign","","",8,[[["self"],["u384"]]]],[11,"sub","","",8,N],[11,"sub_assign","","",8,[[["self"],["rhs"]]]],[11,"sub","","",8,N],[11,"sub_assign","","",8,[[["self"],["u384"]]]],[11,"mul","","",8,N],[11,"mul_assign","","",8,[[["self"],["rhs"]]]],[11,"mul","","",8,N],[11,"mul_assign","","",8,[[["self"],["u384"]]]],[11,"div","","",8,N],[11,"div_assign","","",8,[[["self"],["rhs"]]]],[11,"div","","",8,N],[11,"div_assign","","",8,[[["self"],["u384"]]]],[11,"rem","","",8,N],[11,"rem_assign","","",8,[[["self"],["rhs"]]]],[11,"rem","","",8,N],[11,"rem_assign","","",8,[[["self"],["u384"]]]],[11,"bitand","","",8,N],[11,"bitand_assign","","",8,[[["self"],["rhs"]]]],[11,"bitand","","",8,N],[11,"bitand_assign","","",8,[[["self"],["u384"]]]],[11,"bitor","","",8,N],[11,"bitor_assign","","",8,[[["self"],["rhs"]]]],[11,"bitor","","",8,N],[11,"bitor_assign","","",8,[[["self"],["u384"]]]],[11,"bitxor","","",8,N],[11,"bitxor_assign","","",8,[[["self"],["rhs"]]]],[11,"bitxor","","",8,N],[11,"bitxor_assign","","",8,[[["self"],["u384"]]]],[11,"not","","",8,N],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["u8"]]]],[11,"shl_assign","","",8,[[["self"],["u8"]]]],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["u16"]]]],[11,"shl_assign","","",8,[[["self"],["u16"]]]],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["u32"]]]],[11,"shl_assign","","",8,[[["self"],["u32"]]]],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["u64"]]]],[11,"shl_assign","","",8,[[["self"],["u64"]]]],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["u128"]]]],[11,"shl_assign","","",8,[[["self"],["u128"]]]],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["usize"]]]],[11,"shl_assign","","",8,[[["self"],["usize"]]]],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["i8"]]]],[11,"shl_assign","","",8,[[["self"],["i8"]]]],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["i16"]]]],[11,"shl_assign","","",8,[[["self"],["i16"]]]],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["i32"]]]],[11,"shl_assign","","",8,[[["self"],["i32"]]]],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["i64"]]]],[11,"shl_assign","","",8,[[["self"],["i64"]]]],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["i128"]]]],[11,"shl_assign","","",8,[[["self"],["i128"]]]],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["isize"]]]],[11,"shl_assign","","",8,[[["self"],["isize"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["u8"]]]],[11,"shr_assign","","",8,[[["self"],["u8"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["u16"]]]],[11,"shr_assign","","",8,[[["self"],["u16"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["u32"]]]],[11,"shr_assign","","",8,[[["self"],["u32"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["u64"]]]],[11,"shr_assign","","",8,[[["self"],["u64"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["u128"]]]],[11,"shr_assign","","",8,[[["self"],["u128"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["usize"]]]],[11,"shr_assign","","",8,[[["self"],["usize"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["i8"]]]],[11,"shr_assign","","",8,[[["self"],["i8"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["i16"]]]],[11,"shr_assign","","",8,[[["self"],["i16"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["i32"]]]],[11,"shr_assign","","",8,[[["self"],["i32"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["i64"]]]],[11,"shr_assign","","",8,[[["self"],["i64"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["i128"]]]],[11,"shr_assign","","",8,[[["self"],["i128"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["isize"]]]],[11,"shr_assign","","",8,[[["self"],["isize"]]]],[11,"from","","",8,[[["bool"]],["self"]]],[11,"from","","",8,[[["u8"]],["self"]]],[11,"from","","",8,[[["u8"]],["self"]]],[11,"from","","",8,[[["u16"]],["self"]]],[11,"from","","",8,[[["u16"]],["self"]]],[11,"from","","",8,[[["u32"]],["self"]]],[11,"from","","",8,[[["u32"]],["self"]]],[11,"from","","",8,[[["u64"]],["self"]]],[11,"from","","",8,[[["u64"]],["self"]]],[11,"from","","",8,[[["u128"]],["self"]]],[11,"from","","",8,[[["u128"]],["self"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"hash","","",8,[[["self"],["h"]]]],[11,"sum","","",8,[[["i"]],["self"]]],[11,"sum","","",8,[[["i"]],["self"]]],[11,"product","","",8,[[["i"]],["self"]]],[11,"product","","",8,[[["i"]],["self"]]],[11,"zero","","Create a new fixed uint and value is zero.",9,[[],["self"]]],[11,"one","","Create a new fixed uint and value is zero.",9,[[],["self"]]],[11,"is_zero","","Test if a fixed uint is zero.",9,[[["self"]],["bool"]]],[11,"is_max","","Test if a fixed uint is the max value.",9,[[["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",9,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",9,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",9,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",9,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",9,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",9,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",9,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",9,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",9,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",9,[[["self"]],["option",["usize"]]]],[11,"complete_mul","","Calculates the multiplication of `self` and `other`.",9,N],[11,"complete_div","","Calculates both the quotient and the remainder when `self` is divided by `other`.",9,N],[11,"from_little_endian","","Convert from little-endian bytes.",9,N],[11,"from_big_endian","","Convert from big-endian bytes.",9,N],[11,"into_little_endian","","Convert into little-endian bytes.",9,N],[11,"into_big_endian","","Convert into big-endian bytes.",9,N],[11,"from_bin_str","","Convert from a binary string.",9,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_oct_str","","Convert from a octal string.",9,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_hex_str","","Convert from a hexadecimal string.",9,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_dec_str","","Convert from a decimal string.",9,[[["str"]],["result",["fixeduinterror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",9,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",9,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",9,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",9,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",9,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",9,[[["self"]],["u32"]]],[11,"checked_add","","Checked integer addition. Computes `self + rhs`, returning `None` if overflow occurred.",9,[[["self"],["self"]],["option"]]],[11,"checked_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",9,[[["self"],["self"]],["option"]]],[11,"checked_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",9,[[["self"],["self"]],["option"]]],[11,"checked_div","","Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`.",9,[[["self"],["self"]],["option"]]],[11,"checked_rem","","Checked integer remainder. Computes `self % rhs`, returning `None` if `rhs == 0`.",9,[[["self"],["self"]],["option"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",9,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",9,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",9,[[["self"]],["option"]]],[11,"saturating_add","","Saturating integer addition. Computes `self + rhs`, saturating at the numeric bounds instead of overflowing.",9,[[["self"],["self"]],["self"]]],[11,"saturating_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",9,[[["self"],["self"]],["self"]]],[11,"saturating_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",9,[[["self"],["self"]],["self"]]],[11,"overflowing_add","","Calculates `self + rhs`.",9,N],[11,"overflowing_sub","","Calculates `self - rhs`.",9,N],[11,"overflowing_mul","","Calculates the multiplication of `self` and `rhs`.",9,N],[11,"overflowing_div","","Calculates the divisor when `self` is divided by `rhs`.",9,N],[11,"overflowing_rem","","Calculates the remainder when `self` is divided by `rhs`.",9,N],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",9,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",9,N],[11,"overflowing_neg","","Negates `self` in an overflowing fashion.",9,N],[11,"random","","Create a random fixed uint with a input random core.",9,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",9,[[],["self"]]],[11,"clone","","",9,[[["self"]],["self"]]],[11,"default","","",9,[[],["self"]]],[11,"eq","","",9,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",9,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",9,[[["self"],["self"]],["ordering"]]],[11,"add","","",9,N],[11,"add_assign","","",9,[[["self"],["rhs"]]]],[11,"add","","",9,N],[11,"add_assign","","",9,[[["self"],["u512"]]]],[11,"sub","","",9,N],[11,"sub_assign","","",9,[[["self"],["rhs"]]]],[11,"sub","","",9,N],[11,"sub_assign","","",9,[[["self"],["u512"]]]],[11,"mul","","",9,N],[11,"mul_assign","","",9,[[["self"],["rhs"]]]],[11,"mul","","",9,N],[11,"mul_assign","","",9,[[["self"],["u512"]]]],[11,"div","","",9,N],[11,"div_assign","","",9,[[["self"],["rhs"]]]],[11,"div","","",9,N],[11,"div_assign","","",9,[[["self"],["u512"]]]],[11,"rem","","",9,N],[11,"rem_assign","","",9,[[["self"],["rhs"]]]],[11,"rem","","",9,N],[11,"rem_assign","","",9,[[["self"],["u512"]]]],[11,"bitand","","",9,N],[11,"bitand_assign","","",9,[[["self"],["rhs"]]]],[11,"bitand","","",9,N],[11,"bitand_assign","","",9,[[["self"],["u512"]]]],[11,"bitor","","",9,N],[11,"bitor_assign","","",9,[[["self"],["rhs"]]]],[11,"bitor","","",9,N],[11,"bitor_assign","","",9,[[["self"],["u512"]]]],[11,"bitxor","","",9,N],[11,"bitxor_assign","","",9,[[["self"],["rhs"]]]],[11,"bitxor","","",9,N],[11,"bitxor_assign","","",9,[[["self"],["u512"]]]],[11,"not","","",9,N],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["u8"]]]],[11,"shl_assign","","",9,[[["self"],["u8"]]]],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["u16"]]]],[11,"shl_assign","","",9,[[["self"],["u16"]]]],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["u32"]]]],[11,"shl_assign","","",9,[[["self"],["u32"]]]],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["u64"]]]],[11,"shl_assign","","",9,[[["self"],["u64"]]]],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["u128"]]]],[11,"shl_assign","","",9,[[["self"],["u128"]]]],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["usize"]]]],[11,"shl_assign","","",9,[[["self"],["usize"]]]],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["i8"]]]],[11,"shl_assign","","",9,[[["self"],["i8"]]]],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["i16"]]]],[11,"shl_assign","","",9,[[["self"],["i16"]]]],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["i32"]]]],[11,"shl_assign","","",9,[[["self"],["i32"]]]],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["i64"]]]],[11,"shl_assign","","",9,[[["self"],["i64"]]]],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["i128"]]]],[11,"shl_assign","","",9,[[["self"],["i128"]]]],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["isize"]]]],[11,"shl_assign","","",9,[[["self"],["isize"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["u8"]]]],[11,"shr_assign","","",9,[[["self"],["u8"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["u16"]]]],[11,"shr_assign","","",9,[[["self"],["u16"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["u32"]]]],[11,"shr_assign","","",9,[[["self"],["u32"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["u64"]]]],[11,"shr_assign","","",9,[[["self"],["u64"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["u128"]]]],[11,"shr_assign","","",9,[[["self"],["u128"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["usize"]]]],[11,"shr_assign","","",9,[[["self"],["usize"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["i8"]]]],[11,"shr_assign","","",9,[[["self"],["i8"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["i16"]]]],[11,"shr_assign","","",9,[[["self"],["i16"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["i32"]]]],[11,"shr_assign","","",9,[[["self"],["i32"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["i64"]]]],[11,"shr_assign","","",9,[[["self"],["i64"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["i128"]]]],[11,"shr_assign","","",9,[[["self"],["i128"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["isize"]]]],[11,"shr_assign","","",9,[[["self"],["isize"]]]],[11,"from","","",9,[[["bool"]],["self"]]],[11,"from","","",9,[[["u8"]],["self"]]],[11,"from","","",9,[[["u8"]],["self"]]],[11,"from","","",9,[[["u16"]],["self"]]],[11,"from","","",9,[[["u16"]],["self"]]],[11,"from","","",9,[[["u32"]],["self"]]],[11,"from","","",9,[[["u32"]],["self"]]],[11,"from","","",9,[[["u64"]],["self"]]],[11,"from","","",9,[[["u64"]],["self"]]],[11,"from","","",9,[[["u128"]],["self"]]],[11,"from","","",9,[[["u128"]],["self"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"hash","","",9,[[["self"],["h"]]]],[11,"sum","","",9,[[["i"]],["self"]]],[11,"sum","","",9,[[["i"]],["self"]]],[11,"product","","",9,[[["i"]],["self"]]],[11,"product","","",9,[[["i"]],["self"]]],[11,"zero","","Create a new fixed uint and value is zero.",10,[[],["self"]]],[11,"one","","Create a new fixed uint and value is zero.",10,[[],["self"]]],[11,"is_zero","","Test if a fixed uint is zero.",10,[[["self"]],["bool"]]],[11,"is_max","","Test if a fixed uint is the max value.",10,[[["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",10,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",10,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",10,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",10,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",10,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",10,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",10,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",10,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",10,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",10,[[["self"]],["option",["usize"]]]],[11,"complete_mul","","Calculates the multiplication of `self` and `other`.",10,N],[11,"complete_div","","Calculates both the quotient and the remainder when `self` is divided by `other`.",10,N],[11,"from_little_endian","","Convert from little-endian bytes.",10,N],[11,"from_big_endian","","Convert from big-endian bytes.",10,N],[11,"into_little_endian","","Convert into little-endian bytes.",10,N],[11,"into_big_endian","","Convert into big-endian bytes.",10,N],[11,"from_bin_str","","Convert from a binary string.",10,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_oct_str","","Convert from a octal string.",10,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_hex_str","","Convert from a hexadecimal string.",10,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_dec_str","","Convert from a decimal string.",10,[[["str"]],["result",["fixeduinterror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",10,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",10,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",10,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",10,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",10,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",10,[[["self"]],["u32"]]],[11,"checked_add","","Checked integer addition. Computes `self + rhs`, returning `None` if overflow occurred.",10,[[["self"],["self"]],["option"]]],[11,"checked_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",10,[[["self"],["self"]],["option"]]],[11,"checked_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",10,[[["self"],["self"]],["option"]]],[11,"checked_div","","Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`.",10,[[["self"],["self"]],["option"]]],[11,"checked_rem","","Checked integer remainder. Computes `self % rhs`, returning `None` if `rhs == 0`.",10,[[["self"],["self"]],["option"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",10,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",10,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",10,[[["self"]],["option"]]],[11,"saturating_add","","Saturating integer addition. Computes `self + rhs`, saturating at the numeric bounds instead of overflowing.",10,[[["self"],["self"]],["self"]]],[11,"saturating_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",10,[[["self"],["self"]],["self"]]],[11,"saturating_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",10,[[["self"],["self"]],["self"]]],[11,"overflowing_add","","Calculates `self + rhs`.",10,N],[11,"overflowing_sub","","Calculates `self - rhs`.",10,N],[11,"overflowing_mul","","Calculates the multiplication of `self` and `rhs`.",10,N],[11,"overflowing_div","","Calculates the divisor when `self` is divided by `rhs`.",10,N],[11,"overflowing_rem","","Calculates the remainder when `self` is divided by `rhs`.",10,N],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",10,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",10,N],[11,"overflowing_neg","","Negates `self` in an overflowing fashion.",10,N],[11,"random","","Create a random fixed uint with a input random core.",10,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",10,[[],["self"]]],[11,"clone","","",10,[[["self"]],["self"]]],[11,"default","","",10,[[],["self"]]],[11,"eq","","",10,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",10,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",10,[[["self"],["self"]],["ordering"]]],[11,"add","","",10,N],[11,"add_assign","","",10,[[["self"],["rhs"]]]],[11,"add","","",10,N],[11,"add_assign","","",10,[[["self"],["u1024"]]]],[11,"sub","","",10,N],[11,"sub_assign","","",10,[[["self"],["rhs"]]]],[11,"sub","","",10,N],[11,"sub_assign","","",10,[[["self"],["u1024"]]]],[11,"mul","","",10,N],[11,"mul_assign","","",10,[[["self"],["rhs"]]]],[11,"mul","","",10,N],[11,"mul_assign","","",10,[[["self"],["u1024"]]]],[11,"div","","",10,N],[11,"div_assign","","",10,[[["self"],["rhs"]]]],[11,"div","","",10,N],[11,"div_assign","","",10,[[["self"],["u1024"]]]],[11,"rem","","",10,N],[11,"rem_assign","","",10,[[["self"],["rhs"]]]],[11,"rem","","",10,N],[11,"rem_assign","","",10,[[["self"],["u1024"]]]],[11,"bitand","","",10,N],[11,"bitand_assign","","",10,[[["self"],["rhs"]]]],[11,"bitand","","",10,N],[11,"bitand_assign","","",10,[[["self"],["u1024"]]]],[11,"bitor","","",10,N],[11,"bitor_assign","","",10,[[["self"],["rhs"]]]],[11,"bitor","","",10,N],[11,"bitor_assign","","",10,[[["self"],["u1024"]]]],[11,"bitxor","","",10,N],[11,"bitxor_assign","","",10,[[["self"],["rhs"]]]],[11,"bitxor","","",10,N],[11,"bitxor_assign","","",10,[[["self"],["u1024"]]]],[11,"not","","",10,N],[11,"shl","","",10,N],[11,"shl","","",10,N],[11,"shl_assign","","",10,[[["self"],["u8"]]]],[11,"shl_assign","","",10,[[["self"],["u8"]]]],[11,"shl","","",10,N],[11,"shl","","",10,N],[11,"shl_assign","","",10,[[["self"],["u16"]]]],[11,"shl_assign","","",10,[[["self"],["u16"]]]],[11,"shl","","",10,N],[11,"shl","","",10,N],[11,"shl_assign","","",10,[[["self"],["u32"]]]],[11,"shl_assign","","",10,[[["self"],["u32"]]]],[11,"shl","","",10,N],[11,"shl","","",10,N],[11,"shl_assign","","",10,[[["self"],["u64"]]]],[11,"shl_assign","","",10,[[["self"],["u64"]]]],[11,"shl","","",10,N],[11,"shl","","",10,N],[11,"shl_assign","","",10,[[["self"],["u128"]]]],[11,"shl_assign","","",10,[[["self"],["u128"]]]],[11,"shl","","",10,N],[11,"shl","","",10,N],[11,"shl_assign","","",10,[[["self"],["usize"]]]],[11,"shl_assign","","",10,[[["self"],["usize"]]]],[11,"shl","","",10,N],[11,"shl","","",10,N],[11,"shl_assign","","",10,[[["self"],["i8"]]]],[11,"shl_assign","","",10,[[["self"],["i8"]]]],[11,"shl","","",10,N],[11,"shl","","",10,N],[11,"shl_assign","","",10,[[["self"],["i16"]]]],[11,"shl_assign","","",10,[[["self"],["i16"]]]],[11,"shl","","",10,N],[11,"shl","","",10,N],[11,"shl_assign","","",10,[[["self"],["i32"]]]],[11,"shl_assign","","",10,[[["self"],["i32"]]]],[11,"shl","","",10,N],[11,"shl","","",10,N],[11,"shl_assign","","",10,[[["self"],["i64"]]]],[11,"shl_assign","","",10,[[["self"],["i64"]]]],[11,"shl","","",10,N],[11,"shl","","",10,N],[11,"shl_assign","","",10,[[["self"],["i128"]]]],[11,"shl_assign","","",10,[[["self"],["i128"]]]],[11,"shl","","",10,N],[11,"shl","","",10,N],[11,"shl_assign","","",10,[[["self"],["isize"]]]],[11,"shl_assign","","",10,[[["self"],["isize"]]]],[11,"shr","","",10,N],[11,"shr","","",10,N],[11,"shr_assign","","",10,[[["self"],["u8"]]]],[11,"shr_assign","","",10,[[["self"],["u8"]]]],[11,"shr","","",10,N],[11,"shr","","",10,N],[11,"shr_assign","","",10,[[["self"],["u16"]]]],[11,"shr_assign","","",10,[[["self"],["u16"]]]],[11,"shr","","",10,N],[11,"shr","","",10,N],[11,"shr_assign","","",10,[[["self"],["u32"]]]],[11,"shr_assign","","",10,[[["self"],["u32"]]]],[11,"shr","","",10,N],[11,"shr","","",10,N],[11,"shr_assign","","",10,[[["self"],["u64"]]]],[11,"shr_assign","","",10,[[["self"],["u64"]]]],[11,"shr","","",10,N],[11,"shr","","",10,N],[11,"shr_assign","","",10,[[["self"],["u128"]]]],[11,"shr_assign","","",10,[[["self"],["u128"]]]],[11,"shr","","",10,N],[11,"shr","","",10,N],[11,"shr_assign","","",10,[[["self"],["usize"]]]],[11,"shr_assign","","",10,[[["self"],["usize"]]]],[11,"shr","","",10,N],[11,"shr","","",10,N],[11,"shr_assign","","",10,[[["self"],["i8"]]]],[11,"shr_assign","","",10,[[["self"],["i8"]]]],[11,"shr","","",10,N],[11,"shr","","",10,N],[11,"shr_assign","","",10,[[["self"],["i16"]]]],[11,"shr_assign","","",10,[[["self"],["i16"]]]],[11,"shr","","",10,N],[11,"shr","","",10,N],[11,"shr_assign","","",10,[[["self"],["i32"]]]],[11,"shr_assign","","",10,[[["self"],["i32"]]]],[11,"shr","","",10,N],[11,"shr","","",10,N],[11,"shr_assign","","",10,[[["self"],["i64"]]]],[11,"shr_assign","","",10,[[["self"],["i64"]]]],[11,"shr","","",10,N],[11,"shr","","",10,N],[11,"shr_assign","","",10,[[["self"],["i128"]]]],[11,"shr_assign","","",10,[[["self"],["i128"]]]],[11,"shr","","",10,N],[11,"shr","","",10,N],[11,"shr_assign","","",10,[[["self"],["isize"]]]],[11,"shr_assign","","",10,[[["self"],["isize"]]]],[11,"from","","",10,[[["bool"]],["self"]]],[11,"from","","",10,[[["u8"]],["self"]]],[11,"from","","",10,[[["u8"]],["self"]]],[11,"from","","",10,[[["u16"]],["self"]]],[11,"from","","",10,[[["u16"]],["self"]]],[11,"from","","",10,[[["u32"]],["self"]]],[11,"from","","",10,[[["u32"]],["self"]]],[11,"from","","",10,[[["u64"]],["self"]]],[11,"from","","",10,[[["u64"]],["self"]]],[11,"from","","",10,[[["u128"]],["self"]]],[11,"from","","",10,[[["u128"]],["self"]]],[11,"fmt","","",10,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",10,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",10,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",10,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",10,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",10,[[["self"],["formatter"]],["result"]]],[11,"hash","","",10,[[["self"],["h"]]]],[11,"sum","","",10,[[["i"]],["self"]]],[11,"sum","","",10,[[["i"]],["self"]]],[11,"product","","",10,[[["i"]],["self"]]],[11,"product","","",10,[[["i"]],["self"]]],[11,"zero","","Create a new fixed uint and value is zero.",11,[[],["self"]]],[11,"one","","Create a new fixed uint and value is zero.",11,[[],["self"]]],[11,"is_zero","","Test if a fixed uint is zero.",11,[[["self"]],["bool"]]],[11,"is_max","","Test if a fixed uint is the max value.",11,[[["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",11,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",11,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",11,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",11,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",11,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",11,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",11,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",11,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",11,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",11,[[["self"]],["option",["usize"]]]],[11,"complete_mul","","Calculates the multiplication of `self` and `other`.",11,N],[11,"complete_div","","Calculates both the quotient and the remainder when `self` is divided by `other`.",11,N],[11,"from_little_endian","","Convert from little-endian bytes.",11,N],[11,"from_big_endian","","Convert from big-endian bytes.",11,N],[11,"into_little_endian","","Convert into little-endian bytes.",11,N],[11,"into_big_endian","","Convert into big-endian bytes.",11,N],[11,"from_bin_str","","Convert from a binary string.",11,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_oct_str","","Convert from a octal string.",11,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_hex_str","","Convert from a hexadecimal string.",11,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_dec_str","","Convert from a decimal string.",11,[[["str"]],["result",["fixeduinterror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",11,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",11,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",11,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",11,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",11,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",11,[[["self"]],["u32"]]],[11,"checked_add","","Checked integer addition. Computes `self + rhs`, returning `None` if overflow occurred.",11,[[["self"],["self"]],["option"]]],[11,"checked_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",11,[[["self"],["self"]],["option"]]],[11,"checked_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",11,[[["self"],["self"]],["option"]]],[11,"checked_div","","Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`.",11,[[["self"],["self"]],["option"]]],[11,"checked_rem","","Checked integer remainder. Computes `self % rhs`, returning `None` if `rhs == 0`.",11,[[["self"],["self"]],["option"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",11,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",11,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",11,[[["self"]],["option"]]],[11,"saturating_add","","Saturating integer addition. Computes `self + rhs`, saturating at the numeric bounds instead of overflowing.",11,[[["self"],["self"]],["self"]]],[11,"saturating_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",11,[[["self"],["self"]],["self"]]],[11,"saturating_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",11,[[["self"],["self"]],["self"]]],[11,"overflowing_add","","Calculates `self + rhs`.",11,N],[11,"overflowing_sub","","Calculates `self - rhs`.",11,N],[11,"overflowing_mul","","Calculates the multiplication of `self` and `rhs`.",11,N],[11,"overflowing_div","","Calculates the divisor when `self` is divided by `rhs`.",11,N],[11,"overflowing_rem","","Calculates the remainder when `self` is divided by `rhs`.",11,N],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",11,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",11,N],[11,"overflowing_neg","","Negates `self` in an overflowing fashion.",11,N],[11,"random","","Create a random fixed uint with a input random core.",11,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",11,[[],["self"]]],[11,"clone","","",11,[[["self"]],["self"]]],[11,"default","","",11,[[],["self"]]],[11,"eq","","",11,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",11,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",11,[[["self"],["self"]],["ordering"]]],[11,"add","","",11,N],[11,"add_assign","","",11,[[["self"],["rhs"]]]],[11,"add","","",11,N],[11,"add_assign","","",11,[[["self"],["u2048"]]]],[11,"sub","","",11,N],[11,"sub_assign","","",11,[[["self"],["rhs"]]]],[11,"sub","","",11,N],[11,"sub_assign","","",11,[[["self"],["u2048"]]]],[11,"mul","","",11,N],[11,"mul_assign","","",11,[[["self"],["rhs"]]]],[11,"mul","","",11,N],[11,"mul_assign","","",11,[[["self"],["u2048"]]]],[11,"div","","",11,N],[11,"div_assign","","",11,[[["self"],["rhs"]]]],[11,"div","","",11,N],[11,"div_assign","","",11,[[["self"],["u2048"]]]],[11,"rem","","",11,N],[11,"rem_assign","","",11,[[["self"],["rhs"]]]],[11,"rem","","",11,N],[11,"rem_assign","","",11,[[["self"],["u2048"]]]],[11,"bitand","","",11,N],[11,"bitand_assign","","",11,[[["self"],["rhs"]]]],[11,"bitand","","",11,N],[11,"bitand_assign","","",11,[[["self"],["u2048"]]]],[11,"bitor","","",11,N],[11,"bitor_assign","","",11,[[["self"],["rhs"]]]],[11,"bitor","","",11,N],[11,"bitor_assign","","",11,[[["self"],["u2048"]]]],[11,"bitxor","","",11,N],[11,"bitxor_assign","","",11,[[["self"],["rhs"]]]],[11,"bitxor","","",11,N],[11,"bitxor_assign","","",11,[[["self"],["u2048"]]]],[11,"not","","",11,N],[11,"shl","","",11,N],[11,"shl","","",11,N],[11,"shl_assign","","",11,[[["self"],["u8"]]]],[11,"shl_assign","","",11,[[["self"],["u8"]]]],[11,"shl","","",11,N],[11,"shl","","",11,N],[11,"shl_assign","","",11,[[["self"],["u16"]]]],[11,"shl_assign","","",11,[[["self"],["u16"]]]],[11,"shl","","",11,N],[11,"shl","","",11,N],[11,"shl_assign","","",11,[[["self"],["u32"]]]],[11,"shl_assign","","",11,[[["self"],["u32"]]]],[11,"shl","","",11,N],[11,"shl","","",11,N],[11,"shl_assign","","",11,[[["self"],["u64"]]]],[11,"shl_assign","","",11,[[["self"],["u64"]]]],[11,"shl","","",11,N],[11,"shl","","",11,N],[11,"shl_assign","","",11,[[["self"],["u128"]]]],[11,"shl_assign","","",11,[[["self"],["u128"]]]],[11,"shl","","",11,N],[11,"shl","","",11,N],[11,"shl_assign","","",11,[[["self"],["usize"]]]],[11,"shl_assign","","",11,[[["self"],["usize"]]]],[11,"shl","","",11,N],[11,"shl","","",11,N],[11,"shl_assign","","",11,[[["self"],["i8"]]]],[11,"shl_assign","","",11,[[["self"],["i8"]]]],[11,"shl","","",11,N],[11,"shl","","",11,N],[11,"shl_assign","","",11,[[["self"],["i16"]]]],[11,"shl_assign","","",11,[[["self"],["i16"]]]],[11,"shl","","",11,N],[11,"shl","","",11,N],[11,"shl_assign","","",11,[[["self"],["i32"]]]],[11,"shl_assign","","",11,[[["self"],["i32"]]]],[11,"shl","","",11,N],[11,"shl","","",11,N],[11,"shl_assign","","",11,[[["self"],["i64"]]]],[11,"shl_assign","","",11,[[["self"],["i64"]]]],[11,"shl","","",11,N],[11,"shl","","",11,N],[11,"shl_assign","","",11,[[["self"],["i128"]]]],[11,"shl_assign","","",11,[[["self"],["i128"]]]],[11,"shl","","",11,N],[11,"shl","","",11,N],[11,"shl_assign","","",11,[[["self"],["isize"]]]],[11,"shl_assign","","",11,[[["self"],["isize"]]]],[11,"shr","","",11,N],[11,"shr","","",11,N],[11,"shr_assign","","",11,[[["self"],["u8"]]]],[11,"shr_assign","","",11,[[["self"],["u8"]]]],[11,"shr","","",11,N],[11,"shr","","",11,N],[11,"shr_assign","","",11,[[["self"],["u16"]]]],[11,"shr_assign","","",11,[[["self"],["u16"]]]],[11,"shr","","",11,N],[11,"shr","","",11,N],[11,"shr_assign","","",11,[[["self"],["u32"]]]],[11,"shr_assign","","",11,[[["self"],["u32"]]]],[11,"shr","","",11,N],[11,"shr","","",11,N],[11,"shr_assign","","",11,[[["self"],["u64"]]]],[11,"shr_assign","","",11,[[["self"],["u64"]]]],[11,"shr","","",11,N],[11,"shr","","",11,N],[11,"shr_assign","","",11,[[["self"],["u128"]]]],[11,"shr_assign","","",11,[[["self"],["u128"]]]],[11,"shr","","",11,N],[11,"shr","","",11,N],[11,"shr_assign","","",11,[[["self"],["usize"]]]],[11,"shr_assign","","",11,[[["self"],["usize"]]]],[11,"shr","","",11,N],[11,"shr","","",11,N],[11,"shr_assign","","",11,[[["self"],["i8"]]]],[11,"shr_assign","","",11,[[["self"],["i8"]]]],[11,"shr","","",11,N],[11,"shr","","",11,N],[11,"shr_assign","","",11,[[["self"],["i16"]]]],[11,"shr_assign","","",11,[[["self"],["i16"]]]],[11,"shr","","",11,N],[11,"shr","","",11,N],[11,"shr_assign","","",11,[[["self"],["i32"]]]],[11,"shr_assign","","",11,[[["self"],["i32"]]]],[11,"shr","","",11,N],[11,"shr","","",11,N],[11,"shr_assign","","",11,[[["self"],["i64"]]]],[11,"shr_assign","","",11,[[["self"],["i64"]]]],[11,"shr","","",11,N],[11,"shr","","",11,N],[11,"shr_assign","","",11,[[["self"],["i128"]]]],[11,"shr_assign","","",11,[[["self"],["i128"]]]],[11,"shr","","",11,N],[11,"shr","","",11,N],[11,"shr_assign","","",11,[[["self"],["isize"]]]],[11,"shr_assign","","",11,[[["self"],["isize"]]]],[11,"from","","",11,[[["bool"]],["self"]]],[11,"from","","",11,[[["u8"]],["self"]]],[11,"from","","",11,[[["u8"]],["self"]]],[11,"from","","",11,[[["u16"]],["self"]]],[11,"from","","",11,[[["u16"]],["self"]]],[11,"from","","",11,[[["u32"]],["self"]]],[11,"from","","",11,[[["u32"]],["self"]]],[11,"from","","",11,[[["u64"]],["self"]]],[11,"from","","",11,[[["u64"]],["self"]]],[11,"from","","",11,[[["u128"]],["self"]]],[11,"from","","",11,[[["u128"]],["self"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"hash","","",11,[[["self"],["h"]]]],[11,"sum","","",11,[[["i"]],["self"]]],[11,"sum","","",11,[[["i"]],["self"]]],[11,"product","","",11,[[["i"]],["self"]]],[11,"product","","",11,[[["i"]],["self"]]],[11,"zero","","Create a new fixed uint and value is zero.",12,[[],["self"]]],[11,"one","","Create a new fixed uint and value is zero.",12,[[],["self"]]],[11,"is_zero","","Test if a fixed uint is zero.",12,[[["self"]],["bool"]]],[11,"is_max","","Test if a fixed uint is the max value.",12,[[["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",12,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",12,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",12,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",12,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",12,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",12,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",12,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",12,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",12,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",12,[[["self"]],["option",["usize"]]]],[11,"complete_mul","","Calculates the multiplication of `self` and `other`.",12,N],[11,"complete_div","","Calculates both the quotient and the remainder when `self` is divided by `other`.",12,N],[11,"from_little_endian","","Convert from little-endian bytes.",12,N],[11,"from_big_endian","","Convert from big-endian bytes.",12,N],[11,"into_little_endian","","Convert into little-endian bytes.",12,N],[11,"into_big_endian","","Convert into big-endian bytes.",12,N],[11,"from_bin_str","","Convert from a binary string.",12,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_oct_str","","Convert from a octal string.",12,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_hex_str","","Convert from a hexadecimal string.",12,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_dec_str","","Convert from a decimal string.",12,[[["str"]],["result",["fixeduinterror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",12,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",12,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",12,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",12,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",12,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",12,[[["self"]],["u32"]]],[11,"checked_add","","Checked integer addition. Computes `self + rhs`, returning `None` if overflow occurred.",12,[[["self"],["self"]],["option"]]],[11,"checked_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",12,[[["self"],["self"]],["option"]]],[11,"checked_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",12,[[["self"],["self"]],["option"]]],[11,"checked_div","","Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`.",12,[[["self"],["self"]],["option"]]],[11,"checked_rem","","Checked integer remainder. Computes `self % rhs`, returning `None` if `rhs == 0`.",12,[[["self"],["self"]],["option"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",12,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",12,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",12,[[["self"]],["option"]]],[11,"saturating_add","","Saturating integer addition. Computes `self + rhs`, saturating at the numeric bounds instead of overflowing.",12,[[["self"],["self"]],["self"]]],[11,"saturating_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",12,[[["self"],["self"]],["self"]]],[11,"saturating_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",12,[[["self"],["self"]],["self"]]],[11,"overflowing_add","","Calculates `self + rhs`.",12,N],[11,"overflowing_sub","","Calculates `self - rhs`.",12,N],[11,"overflowing_mul","","Calculates the multiplication of `self` and `rhs`.",12,N],[11,"overflowing_div","","Calculates the divisor when `self` is divided by `rhs`.",12,N],[11,"overflowing_rem","","Calculates the remainder when `self` is divided by `rhs`.",12,N],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",12,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",12,N],[11,"overflowing_neg","","Negates `self` in an overflowing fashion.",12,N],[11,"random","","Create a random fixed uint with a input random core.",12,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",12,[[],["self"]]],[11,"clone","","",12,[[["self"]],["self"]]],[11,"default","","",12,[[],["self"]]],[11,"eq","","",12,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",12,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",12,[[["self"],["self"]],["ordering"]]],[11,"add","","",12,N],[11,"add_assign","","",12,[[["self"],["rhs"]]]],[11,"add","","",12,N],[11,"add_assign","","",12,[[["self"],["u4096"]]]],[11,"sub","","",12,N],[11,"sub_assign","","",12,[[["self"],["rhs"]]]],[11,"sub","","",12,N],[11,"sub_assign","","",12,[[["self"],["u4096"]]]],[11,"mul","","",12,N],[11,"mul_assign","","",12,[[["self"],["rhs"]]]],[11,"mul","","",12,N],[11,"mul_assign","","",12,[[["self"],["u4096"]]]],[11,"div","","",12,N],[11,"div_assign","","",12,[[["self"],["rhs"]]]],[11,"div","","",12,N],[11,"div_assign","","",12,[[["self"],["u4096"]]]],[11,"rem","","",12,N],[11,"rem_assign","","",12,[[["self"],["rhs"]]]],[11,"rem","","",12,N],[11,"rem_assign","","",12,[[["self"],["u4096"]]]],[11,"bitand","","",12,N],[11,"bitand_assign","","",12,[[["self"],["rhs"]]]],[11,"bitand","","",12,N],[11,"bitand_assign","","",12,[[["self"],["u4096"]]]],[11,"bitor","","",12,N],[11,"bitor_assign","","",12,[[["self"],["rhs"]]]],[11,"bitor","","",12,N],[11,"bitor_assign","","",12,[[["self"],["u4096"]]]],[11,"bitxor","","",12,N],[11,"bitxor_assign","","",12,[[["self"],["rhs"]]]],[11,"bitxor","","",12,N],[11,"bitxor_assign","","",12,[[["self"],["u4096"]]]],[11,"not","","",12,N],[11,"shl","","",12,N],[11,"shl","","",12,N],[11,"shl_assign","","",12,[[["self"],["u8"]]]],[11,"shl_assign","","",12,[[["self"],["u8"]]]],[11,"shl","","",12,N],[11,"shl","","",12,N],[11,"shl_assign","","",12,[[["self"],["u16"]]]],[11,"shl_assign","","",12,[[["self"],["u16"]]]],[11,"shl","","",12,N],[11,"shl","","",12,N],[11,"shl_assign","","",12,[[["self"],["u32"]]]],[11,"shl_assign","","",12,[[["self"],["u32"]]]],[11,"shl","","",12,N],[11,"shl","","",12,N],[11,"shl_assign","","",12,[[["self"],["u64"]]]],[11,"shl_assign","","",12,[[["self"],["u64"]]]],[11,"shl","","",12,N],[11,"shl","","",12,N],[11,"shl_assign","","",12,[[["self"],["u128"]]]],[11,"shl_assign","","",12,[[["self"],["u128"]]]],[11,"shl","","",12,N],[11,"shl","","",12,N],[11,"shl_assign","","",12,[[["self"],["usize"]]]],[11,"shl_assign","","",12,[[["self"],["usize"]]]],[11,"shl","","",12,N],[11,"shl","","",12,N],[11,"shl_assign","","",12,[[["self"],["i8"]]]],[11,"shl_assign","","",12,[[["self"],["i8"]]]],[11,"shl","","",12,N],[11,"shl","","",12,N],[11,"shl_assign","","",12,[[["self"],["i16"]]]],[11,"shl_assign","","",12,[[["self"],["i16"]]]],[11,"shl","","",12,N],[11,"shl","","",12,N],[11,"shl_assign","","",12,[[["self"],["i32"]]]],[11,"shl_assign","","",12,[[["self"],["i32"]]]],[11,"shl","","",12,N],[11,"shl","","",12,N],[11,"shl_assign","","",12,[[["self"],["i64"]]]],[11,"shl_assign","","",12,[[["self"],["i64"]]]],[11,"shl","","",12,N],[11,"shl","","",12,N],[11,"shl_assign","","",12,[[["self"],["i128"]]]],[11,"shl_assign","","",12,[[["self"],["i128"]]]],[11,"shl","","",12,N],[11,"shl","","",12,N],[11,"shl_assign","","",12,[[["self"],["isize"]]]],[11,"shl_assign","","",12,[[["self"],["isize"]]]],[11,"shr","","",12,N],[11,"shr","","",12,N],[11,"shr_assign","","",12,[[["self"],["u8"]]]],[11,"shr_assign","","",12,[[["self"],["u8"]]]],[11,"shr","","",12,N],[11,"shr","","",12,N],[11,"shr_assign","","",12,[[["self"],["u16"]]]],[11,"shr_assign","","",12,[[["self"],["u16"]]]],[11,"shr","","",12,N],[11,"shr","","",12,N],[11,"shr_assign","","",12,[[["self"],["u32"]]]],[11,"shr_assign","","",12,[[["self"],["u32"]]]],[11,"shr","","",12,N],[11,"shr","","",12,N],[11,"shr_assign","","",12,[[["self"],["u64"]]]],[11,"shr_assign","","",12,[[["self"],["u64"]]]],[11,"shr","","",12,N],[11,"shr","","",12,N],[11,"shr_assign","","",12,[[["self"],["u128"]]]],[11,"shr_assign","","",12,[[["self"],["u128"]]]],[11,"shr","","",12,N],[11,"shr","","",12,N],[11,"shr_assign","","",12,[[["self"],["usize"]]]],[11,"shr_assign","","",12,[[["self"],["usize"]]]],[11,"shr","","",12,N],[11,"shr","","",12,N],[11,"shr_assign","","",12,[[["self"],["i8"]]]],[11,"shr_assign","","",12,[[["self"],["i8"]]]],[11,"shr","","",12,N],[11,"shr","","",12,N],[11,"shr_assign","","",12,[[["self"],["i16"]]]],[11,"shr_assign","","",12,[[["self"],["i16"]]]],[11,"shr","","",12,N],[11,"shr","","",12,N],[11,"shr_assign","","",12,[[["self"],["i32"]]]],[11,"shr_assign","","",12,[[["self"],["i32"]]]],[11,"shr","","",12,N],[11,"shr","","",12,N],[11,"shr_assign","","",12,[[["self"],["i64"]]]],[11,"shr_assign","","",12,[[["self"],["i64"]]]],[11,"shr","","",12,N],[11,"shr","","",12,N],[11,"shr_assign","","",12,[[["self"],["i128"]]]],[11,"shr_assign","","",12,[[["self"],["i128"]]]],[11,"shr","","",12,N],[11,"shr","","",12,N],[11,"shr_assign","","",12,[[["self"],["isize"]]]],[11,"shr_assign","","",12,[[["self"],["isize"]]]],[11,"from","","",12,[[["bool"]],["self"]]],[11,"from","","",12,[[["u8"]],["self"]]],[11,"from","","",12,[[["u8"]],["self"]]],[11,"from","","",12,[[["u16"]],["self"]]],[11,"from","","",12,[[["u16"]],["self"]]],[11,"from","","",12,[[["u32"]],["self"]]],[11,"from","","",12,[[["u32"]],["self"]]],[11,"from","","",12,[[["u64"]],["self"]]],[11,"from","","",12,[[["u64"]],["self"]]],[11,"from","","",12,[[["u128"]],["self"]]],[11,"from","","",12,[[["u128"]],["self"]]],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"hash","","",12,[[["self"],["h"]]]],[11,"sum","","",12,[[["i"]],["self"]]],[11,"sum","","",12,[[["i"]],["self"]]],[11,"product","","",12,[[["i"]],["self"]]],[11,"product","","",12,[[["i"]],["self"]]],[11,"to_owned","","",4,[[["self"]],["t"]]],[11,"clone_into","","",4,N],[11,"from","","",4,[[["t"]],["t"]]],[11,"to_string","","",4,[[["self"]],["string"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"to_owned","","",5,[[["self"]],["t"]]],[11,"clone_into","","",5,N],[11,"from","","",5,[[["t"]],["t"]]],[11,"to_string","","",5,[[["self"]],["string"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"to_owned","","",6,[[["self"]],["t"]]],[11,"clone_into","","",6,N],[11,"from","","",6,[[["t"]],["t"]]],[11,"to_string","","",6,[[["self"]],["string"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"to_owned","","",7,[[["self"]],["t"]]],[11,"clone_into","","",7,N],[11,"from","","",7,[[["t"]],["t"]]],[11,"to_string","","",7,[[["self"]],["string"]]],[11,"into","","",7,[[["self"]],["u"]]],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"get_type_id","","",7,[[["self"]],["typeid"]]],[11,"to_owned","","",8,[[["self"]],["t"]]],[11,"clone_into","","",8,N],[11,"from","","",8,[[["t"]],["t"]]],[11,"to_string","","",8,[[["self"]],["string"]]],[11,"into","","",8,[[["self"]],["u"]]],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"try_into","","",8,[[["self"]],["result"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"get_type_id","","",8,[[["self"]],["typeid"]]],[11,"to_owned","","",9,[[["self"]],["t"]]],[11,"clone_into","","",9,N],[11,"from","","",9,[[["t"]],["t"]]],[11,"to_string","","",9,[[["self"]],["string"]]],[11,"into","","",9,[[["self"]],["u"]]],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"try_into","","",9,[[["self"]],["result"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"get_type_id","","",9,[[["self"]],["typeid"]]],[11,"to_owned","","",10,[[["self"]],["t"]]],[11,"clone_into","","",10,N],[11,"from","","",10,[[["t"]],["t"]]],[11,"to_string","","",10,[[["self"]],["string"]]],[11,"into","","",10,[[["self"]],["u"]]],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"try_into","","",10,[[["self"]],["result"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"get_type_id","","",10,[[["self"]],["typeid"]]],[11,"to_owned","","",11,[[["self"]],["t"]]],[11,"clone_into","","",11,N],[11,"from","","",11,[[["t"]],["t"]]],[11,"to_string","","",11,[[["self"]],["string"]]],[11,"into","","",11,[[["self"]],["u"]]],[11,"try_from","","",11,[[["u"]],["result"]]],[11,"borrow","","",11,[[["self"]],["t"]]],[11,"try_into","","",11,[[["self"]],["result"]]],[11,"borrow_mut","","",11,[[["self"]],["t"]]],[11,"get_type_id","","",11,[[["self"]],["typeid"]]],[11,"to_owned","","",12,[[["self"]],["t"]]],[11,"clone_into","","",12,N],[11,"from","","",12,[[["t"]],["t"]]],[11,"to_string","","",12,[[["self"]],["string"]]],[11,"into","","",12,[[["self"]],["u"]]],[11,"try_from","","",12,[[["u"]],["result"]]],[11,"borrow","","",12,[[["self"]],["t"]]],[11,"try_into","","",12,[[["self"]],["result"]]],[11,"borrow_mut","","",12,[[["self"]],["t"]]],[11,"get_type_id","","",12,[[["self"]],["typeid"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"to_string","","",0,[[["self"]],["string"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"as_fail","","",0,[[["self"]],["fail"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"to_string","","",1,[[["self"]],["string"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"as_fail","","",1,[[["self"]],["fail"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"to_string","","",2,[[["self"]],["string"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"as_fail","","",2,[[["self"]],["fail"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"to_string","","",3,[[["self"]],["string"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"as_fail","","",3,[[["self"]],["fail"]]]],"paths":[[4,"FromBytesError"],[4,"IntoBytesError"],[4,"FromStrError"],[4,"FixedUintError"],[3,"U128"],[3,"U160"],[3,"U224"],[3,"U256"],[3,"U384"],[3,"U512"],[3,"U1024"],[3,"U2048"],[3,"U4096"]]};
searchIndex["numext_fixed_uint_macros"]={"doc":"","items":[[5,"construct_fixed_uints","numext_fixed_uint_macros","",N,[[["tokenstream"]],["tokenstream"]]],[5,"derive_fixed_uint","","",N,[[["tokenstream"]],["tokenstream"]]]],"paths":[]};
searchIndex["numext_fixed_uint_tests"]={"doc":"","items":[[0,"props","numext_fixed_uint_tests","Support proptest.",N,N],[3,"U256LeBytes","numext_fixed_uint_tests::props","",N,N],[12,"inner","","",0,N],[3,"U256LeBytesValueTree","","",N,N],[3,"U256LeBytesParameters","","",N,N],[3,"U256LeBytesStrategy","","",N,N],[3,"U256Pair","","",N,N],[12,"lhs","","",1,N],[12,"rhs","","",1,N],[12,"opr","","",1,N],[3,"U256PairValueTree","","",N,N],[3,"U256PairStrategy","","",N,N],[4,"U256PairParameters","","",N,N],[13,"Random","","",2,N],[13,"CanAdd","","",2,N],[13,"CanSub","","",2,N],[13,"CanMul","","",2,N],[13,"CanDiv","","",2,N],[13,"CanRem","","",2,N],[11,"clone","","",2,[[["self"]],["u256pairparameters"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"default","","",2,[[],["self"]]],[11,"clone","","",0,[[["self"]],["u256lebytes"]]],[11,"eq","","",0,[[["self"],["u256lebytes"]],["bool"]]],[11,"ne","","",0,[[["self"],["u256lebytes"]],["bool"]]],[11,"partial_cmp","","",0,[[["self"],["u256lebytes"]],["option",["ordering"]]]],[11,"lt","","",0,[[["self"],["u256lebytes"]],["bool"]]],[11,"le","","",0,[[["self"],["u256lebytes"]],["bool"]]],[11,"gt","","",0,[[["self"],["u256lebytes"]],["bool"]]],[11,"ge","","",0,[[["self"],["u256lebytes"]],["bool"]]],[11,"cmp","","",0,[[["self"],["u256lebytes"]],["ordering"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"from","","",0,[[["u256"]],["self"]]],[11,"from","","",0,[[["u256"]],["self"]]],[11,"from","","",0,[[["u256"]],["self"]]],[11,"from","","",0,[[["u256"]],["self"]]],[11,"any","","",0,[[["testrng"]],["self"]]],[11,"nonzero","","",0,[[["testrng"]],["self"]]],[11,"bigger","","",0,[[["self"],["testrng"]],["self"]]],[11,"nonzero_pair","","",0,N],[11,"nonzero_pair_asc","","",0,N],[11,"nonzero_pair_desc","","",0,N],[11,"can_add_without_overflow","","",0,N],[11,"can_mul_without_overflow","","",0,N],[11,"new","","",3,[[["testrunner"]],["self"]]],[11,"current","","",3,N],[11,"simplify","","",3,[[["self"]],["bool"]]],[11,"complicate","","",3,[[["self"]],["bool"]]],[11,"clone","","",4,[[["self"]],["u256lebytesparameters"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"default","","",4,[[],["u256lebytesparameters"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"new","","",5,[[["u256lebytesparameters"]],["self"]]],[11,"new_tree","","",5,[[["self"],["testrunner"]],["newtree"]]],[11,"arbitrary_with","","",0,N],[11,"clone","","",1,[[["self"]],["u256pair"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"new","","",1,[[["u256pairparameters"],["testrng"]],["self"]]],[11,"new","","",6,[[["u256pairparameters"],["testrunner"]],["self"]]],[11,"current","","",6,N],[11,"simplify","","",6,[[["self"]],["bool"]]],[11,"complicate","","",6,[[["self"]],["bool"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"new","","",7,[[["u256pairparameters"]],["self"]]],[11,"new_tree","","",7,[[["self"],["testrunner"]],["newtree"]]],[11,"arbitrary_with","","",1,N],[0,"tools","numext_fixed_uint_tests","Testing tools.",N,N],[5,"gen_nonzero","numext_fixed_uint_tests::tools","",N,[[],["t"]]],[5,"pair","","",N,[[["u256pairparameters"]],["u256pair"]]],[5,"lebytes","","",N,[[],["u256lebytes"]]],[11,"to_owned","numext_fixed_uint_tests::props","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"from","","",0,[[["t"]],["t"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"to_owned","","",4,[[["self"]],["t"]]],[11,"clone_into","","",4,N],[11,"from","","",4,[[["t"]],["t"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"from","","",5,[[["t"]],["t"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,N],[11,"from","","",1,[[["t"]],["t"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"from","","",6,[[["t"]],["t"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"from","","",7,[[["t"]],["t"]]],[11,"into","","",7,[[["self"]],["u"]]],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"get_type_id","","",7,[[["self"]],["typeid"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,N],[11,"from","","",2,[[["t"]],["t"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]]],"paths":[[3,"U256LeBytes"],[3,"U256Pair"],[4,"U256PairParameters"],[3,"U256LeBytesValueTree"],[3,"U256LeBytesParameters"],[3,"U256LeBytesStrategy"],[3,"U256PairValueTree"],[3,"U256PairStrategy"]]};
initSearch(searchIndex);
