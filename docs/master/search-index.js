var N = null;var searchIndex = {};
searchIndex["numext_constructor"]={"doc":"","items":[[5,"construct_fixed_uints","numext_constructor","",N,[[["tokenstream"]],["tokenstream"]]],[5,"construct_fixed_hashes","","",N,[[["tokenstream"]],["tokenstream"]]]],"paths":[]};
searchIndex["numext_fixed_hash"]={"doc":"","items":[[3,"H128","numext_fixed_hash","Fixed hash type.",N,N],[12,"0","","",0,N],[3,"H160","","Fixed hash type.",N,N],[12,"0","","",1,N],[3,"H224","","Fixed hash type.",N,N],[12,"0","","",2,N],[3,"H256","","Fixed hash type.",N,N],[12,"0","","",3,N],[3,"H384","","Fixed hash type.",N,N],[12,"0","","",4,N],[3,"H512","","Fixed hash type.",N,N],[12,"0","","",5,N],[3,"H520","","Fixed hash type.",N,N],[12,"0","","",6,N],[3,"H1024","","Fixed hash type.",N,N],[12,"0","","",7,N],[3,"H2048","","Fixed hash type.",N,N],[12,"0","","",8,N],[3,"H4096","","Fixed hash type.",N,N],[12,"0","","",9,N],[4,"FromSliceError","","Error for parse from slice.",N,N],[13,"InvalidLength","","",10,N],[4,"IntoSliceError","","Error for parse from slice.",N,N],[13,"InvalidLength","","",11,N],[4,"FromStrError","","Error for parse from string.",N,N],[13,"InvalidCharacter","","",12,N],[12,"chr","numext_fixed_hash::FromStrError","",12,N],[12,"idx","","",12,N],[13,"InvalidLength","numext_fixed_hash","",12,N],[4,"FixedHashError","","",N,N],[13,"FromSlice","","",13,N],[13,"IntoSlice","","",13,N],[13,"FromStr","","",13,N],[0,"prelude","","",N,N],[8,"HashConvert","numext_fixed_hash::prelude","",N,N],[10,"convert_into","","Convert a fixed hash into another, return the new fixed hash and if it be truncated.",14,N],[11,"fmt","numext_fixed_hash","",10,[[["self"],["formatter"]],["result"]]],[11,"from","","",13,[[["fromsliceerror"]],["fixedhasherror"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"from","","",13,[[["intosliceerror"]],["fixedhasherror"]]],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"from","","",13,[[["fromstrerror"]],["fixedhasherror"]]],[11,"fmt","","",13,[[["self"],["formatter"]],["result"]]],[11,"repeat_byte","","Return a new fixed hash where all bytes are set to the given byte.",0,[[["u8"]],["self"]]],[11,"zero","","Create a new fixed hash and all bits of it are zeros.",0,[[],["self"]]],[11,"is_zero","","Test if all bits of a fixed hash are zero.",0,[[["self"]],["bool"]]],[11,"is_max","","Test if all bits of a fixed hash are one.",0,[[["self"]],["bool"]]],[11,"covers","","Test if all bits set in a hash are also set in `self`.",0,[[["self"],["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",0,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",0,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",0,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",0,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",0,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",0,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",0,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",0,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",0,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",0,[[["self"]],["option",["usize"]]]],[11,"as_bytes","","Get the inner bytes slice of a fixed hash.",0,N],[11,"as_bytes_mut","","Get the mutable inner bytes slice of a fixed hash.",0,N],[11,"as_fixed_bytes","","Get the inner bytes of a fixed hash.",0,N],[11,"as_fixed_bytes_mut","","Get the mutable inner bytes of a fixed hash.",0,N],[11,"into_fixed_bytes","","Get the inner bytes array of a fixed hash.",0,N],[11,"to_vec","","Get a vec of a fixed hash.",0,[[["self"]],["vec",["u8"]]]],[11,"as_ptr","","Get a constant raw pointer to the inner bytes array of a fixed hash.",0,N],[11,"as_mut_ptr","","Get a mutable raw pointer to the inner bytes array of a fixed hash.",0,N],[11,"from_slice","","Convert from slice.",0,N],[11,"into_slice","","Convert into slice.",0,N],[11,"from_hex_str","","Convert from a fixed length hexadecimal string.",0,[[["str"]],["result",["fixedhasherror"]]]],[11,"from_trimmed_hex_str","","Convert from an arbitrary length zero-trimmed hexadecimal string. Fisrt char should not be zero if the input has more than one char.",0,[[["str"]],["result",["fixedhasherror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",0,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",0,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",0,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",0,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",0,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",0,[[["self"]],["u32"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",0,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",0,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",0,[[["self"]],["option"]]],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",0,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",0,N],[11,"random","","Create a random fixed uint with a input random core.",0,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",0,[[],["self"]]],[11,"clone","","",0,[[["self"]],["self"]]],[11,"default","","",0,[[],["self"]]],[11,"as_ref","","",0,N],[11,"as_mut","","",0,N],[11,"from","","",0,N],[11,"from","","",0,N],[11,"eq","","",0,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",0,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",0,[[["self"],["self"]],["ordering"]]],[11,"bitand","","",0,N],[11,"bitand_assign","","",0,[[["self"],["rhs"]]]],[11,"bitand","","",0,N],[11,"bitand_assign","","",0,[[["self"],["h128"]]]],[11,"bitor","","",0,N],[11,"bitor_assign","","",0,[[["self"],["rhs"]]]],[11,"bitor","","",0,N],[11,"bitor_assign","","",0,[[["self"],["h128"]]]],[11,"bitxor","","",0,N],[11,"bitxor_assign","","",0,[[["self"],["rhs"]]]],[11,"bitxor","","",0,N],[11,"bitxor_assign","","",0,[[["self"],["h128"]]]],[11,"not","","",0,N],[11,"shl","","",0,N],[11,"shl","","",0,N],[11,"shl_assign","","",0,[[["self"],["u8"]]]],[11,"shl_assign","","",0,[[["self"],["u8"]]]],[11,"shl","","",0,N],[11,"shl","","",0,N],[11,"shl_assign","","",0,[[["self"],["u16"]]]],[11,"shl_assign","","",0,[[["self"],["u16"]]]],[11,"shl","","",0,N],[11,"shl","","",0,N],[11,"shl_assign","","",0,[[["self"],["u32"]]]],[11,"shl_assign","","",0,[[["self"],["u32"]]]],[11,"shl","","",0,N],[11,"shl","","",0,N],[11,"shl_assign","","",0,[[["self"],["u64"]]]],[11,"shl_assign","","",0,[[["self"],["u64"]]]],[11,"shl","","",0,N],[11,"shl","","",0,N],[11,"shl_assign","","",0,[[["self"],["u128"]]]],[11,"shl_assign","","",0,[[["self"],["u128"]]]],[11,"shl","","",0,N],[11,"shl","","",0,N],[11,"shl_assign","","",0,[[["self"],["usize"]]]],[11,"shl_assign","","",0,[[["self"],["usize"]]]],[11,"shl","","",0,N],[11,"shl","","",0,N],[11,"shl_assign","","",0,[[["self"],["i8"]]]],[11,"shl_assign","","",0,[[["self"],["i8"]]]],[11,"shl","","",0,N],[11,"shl","","",0,N],[11,"shl_assign","","",0,[[["self"],["i16"]]]],[11,"shl_assign","","",0,[[["self"],["i16"]]]],[11,"shl","","",0,N],[11,"shl","","",0,N],[11,"shl_assign","","",0,[[["self"],["i32"]]]],[11,"shl_assign","","",0,[[["self"],["i32"]]]],[11,"shl","","",0,N],[11,"shl","","",0,N],[11,"shl_assign","","",0,[[["self"],["i64"]]]],[11,"shl_assign","","",0,[[["self"],["i64"]]]],[11,"shl","","",0,N],[11,"shl","","",0,N],[11,"shl_assign","","",0,[[["self"],["i128"]]]],[11,"shl_assign","","",0,[[["self"],["i128"]]]],[11,"shl","","",0,N],[11,"shl","","",0,N],[11,"shl_assign","","",0,[[["self"],["isize"]]]],[11,"shl_assign","","",0,[[["self"],["isize"]]]],[11,"shr","","",0,N],[11,"shr","","",0,N],[11,"shr_assign","","",0,[[["self"],["u8"]]]],[11,"shr_assign","","",0,[[["self"],["u8"]]]],[11,"shr","","",0,N],[11,"shr","","",0,N],[11,"shr_assign","","",0,[[["self"],["u16"]]]],[11,"shr_assign","","",0,[[["self"],["u16"]]]],[11,"shr","","",0,N],[11,"shr","","",0,N],[11,"shr_assign","","",0,[[["self"],["u32"]]]],[11,"shr_assign","","",0,[[["self"],["u32"]]]],[11,"shr","","",0,N],[11,"shr","","",0,N],[11,"shr_assign","","",0,[[["self"],["u64"]]]],[11,"shr_assign","","",0,[[["self"],["u64"]]]],[11,"shr","","",0,N],[11,"shr","","",0,N],[11,"shr_assign","","",0,[[["self"],["u128"]]]],[11,"shr_assign","","",0,[[["self"],["u128"]]]],[11,"shr","","",0,N],[11,"shr","","",0,N],[11,"shr_assign","","",0,[[["self"],["usize"]]]],[11,"shr_assign","","",0,[[["self"],["usize"]]]],[11,"shr","","",0,N],[11,"shr","","",0,N],[11,"shr_assign","","",0,[[["self"],["i8"]]]],[11,"shr_assign","","",0,[[["self"],["i8"]]]],[11,"shr","","",0,N],[11,"shr","","",0,N],[11,"shr_assign","","",0,[[["self"],["i16"]]]],[11,"shr_assign","","",0,[[["self"],["i16"]]]],[11,"shr","","",0,N],[11,"shr","","",0,N],[11,"shr_assign","","",0,[[["self"],["i32"]]]],[11,"shr_assign","","",0,[[["self"],["i32"]]]],[11,"shr","","",0,N],[11,"shr","","",0,N],[11,"shr_assign","","",0,[[["self"],["i64"]]]],[11,"shr_assign","","",0,[[["self"],["i64"]]]],[11,"shr","","",0,N],[11,"shr","","",0,N],[11,"shr_assign","","",0,[[["self"],["i128"]]]],[11,"shr_assign","","",0,[[["self"],["i128"]]]],[11,"shr","","",0,N],[11,"shr","","",0,N],[11,"shr_assign","","",0,[[["self"],["isize"]]]],[11,"shr_assign","","",0,[[["self"],["isize"]]]],[11,"index","","",0,N],[11,"index_mut","","",0,N],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"hash","","",0,[[["self"],["h"]]]],[11,"from_str","","Convert from a hexadecimal string.",0,[[["str"]],["result"]]],[11,"as_byte_slice_mut","","",0,N],[11,"to_le","","",0,[[["self"]]]],[11,"heap_size_of_children","","",0,[[["self"]],["usize"]]],[11,"serialize","","",0,[[["self"],["s"]],["result"]]],[11,"deserialize","","",0,[[["d"]],["result"]]],[11,"convert_into","","",1,N],[11,"convert_into","","",0,N],[11,"repeat_byte","","Return a new fixed hash where all bytes are set to the given byte.",1,[[["u8"]],["self"]]],[11,"zero","","Create a new fixed hash and all bits of it are zeros.",1,[[],["self"]]],[11,"is_zero","","Test if all bits of a fixed hash are zero.",1,[[["self"]],["bool"]]],[11,"is_max","","Test if all bits of a fixed hash are one.",1,[[["self"]],["bool"]]],[11,"covers","","Test if all bits set in a hash are also set in `self`.",1,[[["self"],["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",1,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",1,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",1,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",1,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",1,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",1,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",1,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",1,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",1,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",1,[[["self"]],["option",["usize"]]]],[11,"as_bytes","","Get the inner bytes slice of a fixed hash.",1,N],[11,"as_bytes_mut","","Get the mutable inner bytes slice of a fixed hash.",1,N],[11,"as_fixed_bytes","","Get the inner bytes of a fixed hash.",1,N],[11,"as_fixed_bytes_mut","","Get the mutable inner bytes of a fixed hash.",1,N],[11,"into_fixed_bytes","","Get the inner bytes array of a fixed hash.",1,N],[11,"to_vec","","Get a vec of a fixed hash.",1,[[["self"]],["vec",["u8"]]]],[11,"as_ptr","","Get a constant raw pointer to the inner bytes array of a fixed hash.",1,N],[11,"as_mut_ptr","","Get a mutable raw pointer to the inner bytes array of a fixed hash.",1,N],[11,"from_slice","","Convert from slice.",1,N],[11,"into_slice","","Convert into slice.",1,N],[11,"from_hex_str","","Convert from a fixed length hexadecimal string.",1,[[["str"]],["result",["fixedhasherror"]]]],[11,"from_trimmed_hex_str","","Convert from an arbitrary length zero-trimmed hexadecimal string. Fisrt char should not be zero if the input has more than one char.",1,[[["str"]],["result",["fixedhasherror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",1,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",1,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",1,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",1,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",1,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",1,[[["self"]],["u32"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",1,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",1,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",1,[[["self"]],["option"]]],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",1,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",1,N],[11,"random","","Create a random fixed uint with a input random core.",1,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",1,[[],["self"]]],[11,"clone","","",1,[[["self"]],["self"]]],[11,"default","","",1,[[],["self"]]],[11,"as_ref","","",1,N],[11,"as_mut","","",1,N],[11,"from","","",1,N],[11,"from","","",1,N],[11,"eq","","",1,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",1,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",1,[[["self"],["self"]],["ordering"]]],[11,"bitand","","",1,N],[11,"bitand_assign","","",1,[[["self"],["rhs"]]]],[11,"bitand","","",1,N],[11,"bitand_assign","","",1,[[["self"],["h160"]]]],[11,"bitor","","",1,N],[11,"bitor_assign","","",1,[[["self"],["rhs"]]]],[11,"bitor","","",1,N],[11,"bitor_assign","","",1,[[["self"],["h160"]]]],[11,"bitxor","","",1,N],[11,"bitxor_assign","","",1,[[["self"],["rhs"]]]],[11,"bitxor","","",1,N],[11,"bitxor_assign","","",1,[[["self"],["h160"]]]],[11,"not","","",1,N],[11,"shl","","",1,N],[11,"shl","","",1,N],[11,"shl_assign","","",1,[[["self"],["u8"]]]],[11,"shl_assign","","",1,[[["self"],["u8"]]]],[11,"shl","","",1,N],[11,"shl","","",1,N],[11,"shl_assign","","",1,[[["self"],["u16"]]]],[11,"shl_assign","","",1,[[["self"],["u16"]]]],[11,"shl","","",1,N],[11,"shl","","",1,N],[11,"shl_assign","","",1,[[["self"],["u32"]]]],[11,"shl_assign","","",1,[[["self"],["u32"]]]],[11,"shl","","",1,N],[11,"shl","","",1,N],[11,"shl_assign","","",1,[[["self"],["u64"]]]],[11,"shl_assign","","",1,[[["self"],["u64"]]]],[11,"shl","","",1,N],[11,"shl","","",1,N],[11,"shl_assign","","",1,[[["self"],["u128"]]]],[11,"shl_assign","","",1,[[["self"],["u128"]]]],[11,"shl","","",1,N],[11,"shl","","",1,N],[11,"shl_assign","","",1,[[["self"],["usize"]]]],[11,"shl_assign","","",1,[[["self"],["usize"]]]],[11,"shl","","",1,N],[11,"shl","","",1,N],[11,"shl_assign","","",1,[[["self"],["i8"]]]],[11,"shl_assign","","",1,[[["self"],["i8"]]]],[11,"shl","","",1,N],[11,"shl","","",1,N],[11,"shl_assign","","",1,[[["self"],["i16"]]]],[11,"shl_assign","","",1,[[["self"],["i16"]]]],[11,"shl","","",1,N],[11,"shl","","",1,N],[11,"shl_assign","","",1,[[["self"],["i32"]]]],[11,"shl_assign","","",1,[[["self"],["i32"]]]],[11,"shl","","",1,N],[11,"shl","","",1,N],[11,"shl_assign","","",1,[[["self"],["i64"]]]],[11,"shl_assign","","",1,[[["self"],["i64"]]]],[11,"shl","","",1,N],[11,"shl","","",1,N],[11,"shl_assign","","",1,[[["self"],["i128"]]]],[11,"shl_assign","","",1,[[["self"],["i128"]]]],[11,"shl","","",1,N],[11,"shl","","",1,N],[11,"shl_assign","","",1,[[["self"],["isize"]]]],[11,"shl_assign","","",1,[[["self"],["isize"]]]],[11,"shr","","",1,N],[11,"shr","","",1,N],[11,"shr_assign","","",1,[[["self"],["u8"]]]],[11,"shr_assign","","",1,[[["self"],["u8"]]]],[11,"shr","","",1,N],[11,"shr","","",1,N],[11,"shr_assign","","",1,[[["self"],["u16"]]]],[11,"shr_assign","","",1,[[["self"],["u16"]]]],[11,"shr","","",1,N],[11,"shr","","",1,N],[11,"shr_assign","","",1,[[["self"],["u32"]]]],[11,"shr_assign","","",1,[[["self"],["u32"]]]],[11,"shr","","",1,N],[11,"shr","","",1,N],[11,"shr_assign","","",1,[[["self"],["u64"]]]],[11,"shr_assign","","",1,[[["self"],["u64"]]]],[11,"shr","","",1,N],[11,"shr","","",1,N],[11,"shr_assign","","",1,[[["self"],["u128"]]]],[11,"shr_assign","","",1,[[["self"],["u128"]]]],[11,"shr","","",1,N],[11,"shr","","",1,N],[11,"shr_assign","","",1,[[["self"],["usize"]]]],[11,"shr_assign","","",1,[[["self"],["usize"]]]],[11,"shr","","",1,N],[11,"shr","","",1,N],[11,"shr_assign","","",1,[[["self"],["i8"]]]],[11,"shr_assign","","",1,[[["self"],["i8"]]]],[11,"shr","","",1,N],[11,"shr","","",1,N],[11,"shr_assign","","",1,[[["self"],["i16"]]]],[11,"shr_assign","","",1,[[["self"],["i16"]]]],[11,"shr","","",1,N],[11,"shr","","",1,N],[11,"shr_assign","","",1,[[["self"],["i32"]]]],[11,"shr_assign","","",1,[[["self"],["i32"]]]],[11,"shr","","",1,N],[11,"shr","","",1,N],[11,"shr_assign","","",1,[[["self"],["i64"]]]],[11,"shr_assign","","",1,[[["self"],["i64"]]]],[11,"shr","","",1,N],[11,"shr","","",1,N],[11,"shr_assign","","",1,[[["self"],["i128"]]]],[11,"shr_assign","","",1,[[["self"],["i128"]]]],[11,"shr","","",1,N],[11,"shr","","",1,N],[11,"shr_assign","","",1,[[["self"],["isize"]]]],[11,"shr_assign","","",1,[[["self"],["isize"]]]],[11,"index","","",1,N],[11,"index_mut","","",1,N],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"hash","","",1,[[["self"],["h"]]]],[11,"from_str","","Convert from a hexadecimal string.",1,[[["str"]],["result"]]],[11,"as_byte_slice_mut","","",1,N],[11,"to_le","","",1,[[["self"]]]],[11,"heap_size_of_children","","",1,[[["self"]],["usize"]]],[11,"serialize","","",1,[[["self"],["s"]],["result"]]],[11,"deserialize","","",1,[[["d"]],["result"]]],[11,"convert_into","","",2,N],[11,"convert_into","","",0,N],[11,"convert_into","","",2,N],[11,"convert_into","","",1,N],[11,"repeat_byte","","Return a new fixed hash where all bytes are set to the given byte.",2,[[["u8"]],["self"]]],[11,"zero","","Create a new fixed hash and all bits of it are zeros.",2,[[],["self"]]],[11,"is_zero","","Test if all bits of a fixed hash are zero.",2,[[["self"]],["bool"]]],[11,"is_max","","Test if all bits of a fixed hash are one.",2,[[["self"]],["bool"]]],[11,"covers","","Test if all bits set in a hash are also set in `self`.",2,[[["self"],["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",2,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",2,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",2,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",2,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",2,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",2,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",2,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",2,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",2,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",2,[[["self"]],["option",["usize"]]]],[11,"as_bytes","","Get the inner bytes slice of a fixed hash.",2,N],[11,"as_bytes_mut","","Get the mutable inner bytes slice of a fixed hash.",2,N],[11,"as_fixed_bytes","","Get the inner bytes of a fixed hash.",2,N],[11,"as_fixed_bytes_mut","","Get the mutable inner bytes of a fixed hash.",2,N],[11,"into_fixed_bytes","","Get the inner bytes array of a fixed hash.",2,N],[11,"to_vec","","Get a vec of a fixed hash.",2,[[["self"]],["vec",["u8"]]]],[11,"as_ptr","","Get a constant raw pointer to the inner bytes array of a fixed hash.",2,N],[11,"as_mut_ptr","","Get a mutable raw pointer to the inner bytes array of a fixed hash.",2,N],[11,"from_slice","","Convert from slice.",2,N],[11,"into_slice","","Convert into slice.",2,N],[11,"from_hex_str","","Convert from a fixed length hexadecimal string.",2,[[["str"]],["result",["fixedhasherror"]]]],[11,"from_trimmed_hex_str","","Convert from an arbitrary length zero-trimmed hexadecimal string. Fisrt char should not be zero if the input has more than one char.",2,[[["str"]],["result",["fixedhasherror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",2,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",2,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",2,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",2,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",2,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",2,[[["self"]],["u32"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",2,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",2,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",2,[[["self"]],["option"]]],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",2,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",2,N],[11,"random","","Create a random fixed uint with a input random core.",2,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",2,[[],["self"]]],[11,"clone","","",2,[[["self"]],["self"]]],[11,"default","","",2,[[],["self"]]],[11,"as_ref","","",2,N],[11,"as_mut","","",2,N],[11,"from","","",2,N],[11,"from","","",2,N],[11,"eq","","",2,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",2,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",2,[[["self"],["self"]],["ordering"]]],[11,"bitand","","",2,N],[11,"bitand_assign","","",2,[[["self"],["rhs"]]]],[11,"bitand","","",2,N],[11,"bitand_assign","","",2,[[["self"],["h224"]]]],[11,"bitor","","",2,N],[11,"bitor_assign","","",2,[[["self"],["rhs"]]]],[11,"bitor","","",2,N],[11,"bitor_assign","","",2,[[["self"],["h224"]]]],[11,"bitxor","","",2,N],[11,"bitxor_assign","","",2,[[["self"],["rhs"]]]],[11,"bitxor","","",2,N],[11,"bitxor_assign","","",2,[[["self"],["h224"]]]],[11,"not","","",2,N],[11,"shl","","",2,N],[11,"shl","","",2,N],[11,"shl_assign","","",2,[[["self"],["u8"]]]],[11,"shl_assign","","",2,[[["self"],["u8"]]]],[11,"shl","","",2,N],[11,"shl","","",2,N],[11,"shl_assign","","",2,[[["self"],["u16"]]]],[11,"shl_assign","","",2,[[["self"],["u16"]]]],[11,"shl","","",2,N],[11,"shl","","",2,N],[11,"shl_assign","","",2,[[["self"],["u32"]]]],[11,"shl_assign","","",2,[[["self"],["u32"]]]],[11,"shl","","",2,N],[11,"shl","","",2,N],[11,"shl_assign","","",2,[[["self"],["u64"]]]],[11,"shl_assign","","",2,[[["self"],["u64"]]]],[11,"shl","","",2,N],[11,"shl","","",2,N],[11,"shl_assign","","",2,[[["self"],["u128"]]]],[11,"shl_assign","","",2,[[["self"],["u128"]]]],[11,"shl","","",2,N],[11,"shl","","",2,N],[11,"shl_assign","","",2,[[["self"],["usize"]]]],[11,"shl_assign","","",2,[[["self"],["usize"]]]],[11,"shl","","",2,N],[11,"shl","","",2,N],[11,"shl_assign","","",2,[[["self"],["i8"]]]],[11,"shl_assign","","",2,[[["self"],["i8"]]]],[11,"shl","","",2,N],[11,"shl","","",2,N],[11,"shl_assign","","",2,[[["self"],["i16"]]]],[11,"shl_assign","","",2,[[["self"],["i16"]]]],[11,"shl","","",2,N],[11,"shl","","",2,N],[11,"shl_assign","","",2,[[["self"],["i32"]]]],[11,"shl_assign","","",2,[[["self"],["i32"]]]],[11,"shl","","",2,N],[11,"shl","","",2,N],[11,"shl_assign","","",2,[[["self"],["i64"]]]],[11,"shl_assign","","",2,[[["self"],["i64"]]]],[11,"shl","","",2,N],[11,"shl","","",2,N],[11,"shl_assign","","",2,[[["self"],["i128"]]]],[11,"shl_assign","","",2,[[["self"],["i128"]]]],[11,"shl","","",2,N],[11,"shl","","",2,N],[11,"shl_assign","","",2,[[["self"],["isize"]]]],[11,"shl_assign","","",2,[[["self"],["isize"]]]],[11,"shr","","",2,N],[11,"shr","","",2,N],[11,"shr_assign","","",2,[[["self"],["u8"]]]],[11,"shr_assign","","",2,[[["self"],["u8"]]]],[11,"shr","","",2,N],[11,"shr","","",2,N],[11,"shr_assign","","",2,[[["self"],["u16"]]]],[11,"shr_assign","","",2,[[["self"],["u16"]]]],[11,"shr","","",2,N],[11,"shr","","",2,N],[11,"shr_assign","","",2,[[["self"],["u32"]]]],[11,"shr_assign","","",2,[[["self"],["u32"]]]],[11,"shr","","",2,N],[11,"shr","","",2,N],[11,"shr_assign","","",2,[[["self"],["u64"]]]],[11,"shr_assign","","",2,[[["self"],["u64"]]]],[11,"shr","","",2,N],[11,"shr","","",2,N],[11,"shr_assign","","",2,[[["self"],["u128"]]]],[11,"shr_assign","","",2,[[["self"],["u128"]]]],[11,"shr","","",2,N],[11,"shr","","",2,N],[11,"shr_assign","","",2,[[["self"],["usize"]]]],[11,"shr_assign","","",2,[[["self"],["usize"]]]],[11,"shr","","",2,N],[11,"shr","","",2,N],[11,"shr_assign","","",2,[[["self"],["i8"]]]],[11,"shr_assign","","",2,[[["self"],["i8"]]]],[11,"shr","","",2,N],[11,"shr","","",2,N],[11,"shr_assign","","",2,[[["self"],["i16"]]]],[11,"shr_assign","","",2,[[["self"],["i16"]]]],[11,"shr","","",2,N],[11,"shr","","",2,N],[11,"shr_assign","","",2,[[["self"],["i32"]]]],[11,"shr_assign","","",2,[[["self"],["i32"]]]],[11,"shr","","",2,N],[11,"shr","","",2,N],[11,"shr_assign","","",2,[[["self"],["i64"]]]],[11,"shr_assign","","",2,[[["self"],["i64"]]]],[11,"shr","","",2,N],[11,"shr","","",2,N],[11,"shr_assign","","",2,[[["self"],["i128"]]]],[11,"shr_assign","","",2,[[["self"],["i128"]]]],[11,"shr","","",2,N],[11,"shr","","",2,N],[11,"shr_assign","","",2,[[["self"],["isize"]]]],[11,"shr_assign","","",2,[[["self"],["isize"]]]],[11,"index","","",2,N],[11,"index_mut","","",2,N],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"hash","","",2,[[["self"],["h"]]]],[11,"from_str","","Convert from a hexadecimal string.",2,[[["str"]],["result"]]],[11,"as_byte_slice_mut","","",2,N],[11,"to_le","","",2,[[["self"]]]],[11,"heap_size_of_children","","",2,[[["self"]],["usize"]]],[11,"serialize","","",2,[[["self"],["s"]],["result"]]],[11,"deserialize","","",2,[[["d"]],["result"]]],[11,"convert_into","","",3,N],[11,"convert_into","","",0,N],[11,"convert_into","","",3,N],[11,"convert_into","","",1,N],[11,"convert_into","","",3,N],[11,"convert_into","","",2,N],[11,"repeat_byte","","Return a new fixed hash where all bytes are set to the given byte.",3,[[["u8"]],["self"]]],[11,"zero","","Create a new fixed hash and all bits of it are zeros.",3,[[],["self"]]],[11,"is_zero","","Test if all bits of a fixed hash are zero.",3,[[["self"]],["bool"]]],[11,"is_max","","Test if all bits of a fixed hash are one.",3,[[["self"]],["bool"]]],[11,"covers","","Test if all bits set in a hash are also set in `self`.",3,[[["self"],["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",3,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",3,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",3,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",3,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",3,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",3,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",3,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",3,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",3,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",3,[[["self"]],["option",["usize"]]]],[11,"as_bytes","","Get the inner bytes slice of a fixed hash.",3,N],[11,"as_bytes_mut","","Get the mutable inner bytes slice of a fixed hash.",3,N],[11,"as_fixed_bytes","","Get the inner bytes of a fixed hash.",3,N],[11,"as_fixed_bytes_mut","","Get the mutable inner bytes of a fixed hash.",3,N],[11,"into_fixed_bytes","","Get the inner bytes array of a fixed hash.",3,N],[11,"to_vec","","Get a vec of a fixed hash.",3,[[["self"]],["vec",["u8"]]]],[11,"as_ptr","","Get a constant raw pointer to the inner bytes array of a fixed hash.",3,N],[11,"as_mut_ptr","","Get a mutable raw pointer to the inner bytes array of a fixed hash.",3,N],[11,"from_slice","","Convert from slice.",3,N],[11,"into_slice","","Convert into slice.",3,N],[11,"from_hex_str","","Convert from a fixed length hexadecimal string.",3,[[["str"]],["result",["fixedhasherror"]]]],[11,"from_trimmed_hex_str","","Convert from an arbitrary length zero-trimmed hexadecimal string. Fisrt char should not be zero if the input has more than one char.",3,[[["str"]],["result",["fixedhasherror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",3,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",3,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",3,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",3,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",3,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",3,[[["self"]],["u32"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",3,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",3,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",3,[[["self"]],["option"]]],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",3,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",3,N],[11,"random","","Create a random fixed uint with a input random core.",3,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",3,[[],["self"]]],[11,"clone","","",3,[[["self"]],["self"]]],[11,"default","","",3,[[],["self"]]],[11,"as_ref","","",3,N],[11,"as_mut","","",3,N],[11,"from","","",3,N],[11,"from","","",3,N],[11,"eq","","",3,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",3,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",3,[[["self"],["self"]],["ordering"]]],[11,"bitand","","",3,N],[11,"bitand_assign","","",3,[[["self"],["rhs"]]]],[11,"bitand","","",3,N],[11,"bitand_assign","","",3,[[["self"],["h256"]]]],[11,"bitor","","",3,N],[11,"bitor_assign","","",3,[[["self"],["rhs"]]]],[11,"bitor","","",3,N],[11,"bitor_assign","","",3,[[["self"],["h256"]]]],[11,"bitxor","","",3,N],[11,"bitxor_assign","","",3,[[["self"],["rhs"]]]],[11,"bitxor","","",3,N],[11,"bitxor_assign","","",3,[[["self"],["h256"]]]],[11,"not","","",3,N],[11,"shl","","",3,N],[11,"shl","","",3,N],[11,"shl_assign","","",3,[[["self"],["u8"]]]],[11,"shl_assign","","",3,[[["self"],["u8"]]]],[11,"shl","","",3,N],[11,"shl","","",3,N],[11,"shl_assign","","",3,[[["self"],["u16"]]]],[11,"shl_assign","","",3,[[["self"],["u16"]]]],[11,"shl","","",3,N],[11,"shl","","",3,N],[11,"shl_assign","","",3,[[["self"],["u32"]]]],[11,"shl_assign","","",3,[[["self"],["u32"]]]],[11,"shl","","",3,N],[11,"shl","","",3,N],[11,"shl_assign","","",3,[[["self"],["u64"]]]],[11,"shl_assign","","",3,[[["self"],["u64"]]]],[11,"shl","","",3,N],[11,"shl","","",3,N],[11,"shl_assign","","",3,[[["self"],["u128"]]]],[11,"shl_assign","","",3,[[["self"],["u128"]]]],[11,"shl","","",3,N],[11,"shl","","",3,N],[11,"shl_assign","","",3,[[["self"],["usize"]]]],[11,"shl_assign","","",3,[[["self"],["usize"]]]],[11,"shl","","",3,N],[11,"shl","","",3,N],[11,"shl_assign","","",3,[[["self"],["i8"]]]],[11,"shl_assign","","",3,[[["self"],["i8"]]]],[11,"shl","","",3,N],[11,"shl","","",3,N],[11,"shl_assign","","",3,[[["self"],["i16"]]]],[11,"shl_assign","","",3,[[["self"],["i16"]]]],[11,"shl","","",3,N],[11,"shl","","",3,N],[11,"shl_assign","","",3,[[["self"],["i32"]]]],[11,"shl_assign","","",3,[[["self"],["i32"]]]],[11,"shl","","",3,N],[11,"shl","","",3,N],[11,"shl_assign","","",3,[[["self"],["i64"]]]],[11,"shl_assign","","",3,[[["self"],["i64"]]]],[11,"shl","","",3,N],[11,"shl","","",3,N],[11,"shl_assign","","",3,[[["self"],["i128"]]]],[11,"shl_assign","","",3,[[["self"],["i128"]]]],[11,"shl","","",3,N],[11,"shl","","",3,N],[11,"shl_assign","","",3,[[["self"],["isize"]]]],[11,"shl_assign","","",3,[[["self"],["isize"]]]],[11,"shr","","",3,N],[11,"shr","","",3,N],[11,"shr_assign","","",3,[[["self"],["u8"]]]],[11,"shr_assign","","",3,[[["self"],["u8"]]]],[11,"shr","","",3,N],[11,"shr","","",3,N],[11,"shr_assign","","",3,[[["self"],["u16"]]]],[11,"shr_assign","","",3,[[["self"],["u16"]]]],[11,"shr","","",3,N],[11,"shr","","",3,N],[11,"shr_assign","","",3,[[["self"],["u32"]]]],[11,"shr_assign","","",3,[[["self"],["u32"]]]],[11,"shr","","",3,N],[11,"shr","","",3,N],[11,"shr_assign","","",3,[[["self"],["u64"]]]],[11,"shr_assign","","",3,[[["self"],["u64"]]]],[11,"shr","","",3,N],[11,"shr","","",3,N],[11,"shr_assign","","",3,[[["self"],["u128"]]]],[11,"shr_assign","","",3,[[["self"],["u128"]]]],[11,"shr","","",3,N],[11,"shr","","",3,N],[11,"shr_assign","","",3,[[["self"],["usize"]]]],[11,"shr_assign","","",3,[[["self"],["usize"]]]],[11,"shr","","",3,N],[11,"shr","","",3,N],[11,"shr_assign","","",3,[[["self"],["i8"]]]],[11,"shr_assign","","",3,[[["self"],["i8"]]]],[11,"shr","","",3,N],[11,"shr","","",3,N],[11,"shr_assign","","",3,[[["self"],["i16"]]]],[11,"shr_assign","","",3,[[["self"],["i16"]]]],[11,"shr","","",3,N],[11,"shr","","",3,N],[11,"shr_assign","","",3,[[["self"],["i32"]]]],[11,"shr_assign","","",3,[[["self"],["i32"]]]],[11,"shr","","",3,N],[11,"shr","","",3,N],[11,"shr_assign","","",3,[[["self"],["i64"]]]],[11,"shr_assign","","",3,[[["self"],["i64"]]]],[11,"shr","","",3,N],[11,"shr","","",3,N],[11,"shr_assign","","",3,[[["self"],["i128"]]]],[11,"shr_assign","","",3,[[["self"],["i128"]]]],[11,"shr","","",3,N],[11,"shr","","",3,N],[11,"shr_assign","","",3,[[["self"],["isize"]]]],[11,"shr_assign","","",3,[[["self"],["isize"]]]],[11,"index","","",3,N],[11,"index_mut","","",3,N],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"hash","","",3,[[["self"],["h"]]]],[11,"from_str","","Convert from a hexadecimal string.",3,[[["str"]],["result"]]],[11,"as_byte_slice_mut","","",3,N],[11,"to_le","","",3,[[["self"]]]],[11,"heap_size_of_children","","",3,[[["self"]],["usize"]]],[11,"serialize","","",3,[[["self"],["s"]],["result"]]],[11,"deserialize","","",3,[[["d"]],["result"]]],[11,"convert_into","","",4,N],[11,"convert_into","","",0,N],[11,"convert_into","","",4,N],[11,"convert_into","","",1,N],[11,"convert_into","","",4,N],[11,"convert_into","","",2,N],[11,"convert_into","","",4,N],[11,"convert_into","","",3,N],[11,"repeat_byte","","Return a new fixed hash where all bytes are set to the given byte.",4,[[["u8"]],["self"]]],[11,"zero","","Create a new fixed hash and all bits of it are zeros.",4,[[],["self"]]],[11,"is_zero","","Test if all bits of a fixed hash are zero.",4,[[["self"]],["bool"]]],[11,"is_max","","Test if all bits of a fixed hash are one.",4,[[["self"]],["bool"]]],[11,"covers","","Test if all bits set in a hash are also set in `self`.",4,[[["self"],["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",4,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",4,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",4,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",4,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",4,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",4,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",4,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",4,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",4,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",4,[[["self"]],["option",["usize"]]]],[11,"as_bytes","","Get the inner bytes slice of a fixed hash.",4,N],[11,"as_bytes_mut","","Get the mutable inner bytes slice of a fixed hash.",4,N],[11,"as_fixed_bytes","","Get the inner bytes of a fixed hash.",4,N],[11,"as_fixed_bytes_mut","","Get the mutable inner bytes of a fixed hash.",4,N],[11,"into_fixed_bytes","","Get the inner bytes array of a fixed hash.",4,N],[11,"to_vec","","Get a vec of a fixed hash.",4,[[["self"]],["vec",["u8"]]]],[11,"as_ptr","","Get a constant raw pointer to the inner bytes array of a fixed hash.",4,N],[11,"as_mut_ptr","","Get a mutable raw pointer to the inner bytes array of a fixed hash.",4,N],[11,"from_slice","","Convert from slice.",4,N],[11,"into_slice","","Convert into slice.",4,N],[11,"from_hex_str","","Convert from a fixed length hexadecimal string.",4,[[["str"]],["result",["fixedhasherror"]]]],[11,"from_trimmed_hex_str","","Convert from an arbitrary length zero-trimmed hexadecimal string. Fisrt char should not be zero if the input has more than one char.",4,[[["str"]],["result",["fixedhasherror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",4,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",4,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",4,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",4,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",4,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",4,[[["self"]],["u32"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",4,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",4,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",4,[[["self"]],["option"]]],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",4,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",4,N],[11,"random","","Create a random fixed uint with a input random core.",4,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",4,[[],["self"]]],[11,"clone","","",4,[[["self"]],["self"]]],[11,"default","","",4,[[],["self"]]],[11,"as_ref","","",4,N],[11,"as_mut","","",4,N],[11,"from","","",4,N],[11,"from","","",4,N],[11,"eq","","",4,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",4,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",4,[[["self"],["self"]],["ordering"]]],[11,"bitand","","",4,N],[11,"bitand_assign","","",4,[[["self"],["rhs"]]]],[11,"bitand","","",4,N],[11,"bitand_assign","","",4,[[["self"],["h384"]]]],[11,"bitor","","",4,N],[11,"bitor_assign","","",4,[[["self"],["rhs"]]]],[11,"bitor","","",4,N],[11,"bitor_assign","","",4,[[["self"],["h384"]]]],[11,"bitxor","","",4,N],[11,"bitxor_assign","","",4,[[["self"],["rhs"]]]],[11,"bitxor","","",4,N],[11,"bitxor_assign","","",4,[[["self"],["h384"]]]],[11,"not","","",4,N],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["u8"]]]],[11,"shl_assign","","",4,[[["self"],["u8"]]]],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["u16"]]]],[11,"shl_assign","","",4,[[["self"],["u16"]]]],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["u32"]]]],[11,"shl_assign","","",4,[[["self"],["u32"]]]],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["u64"]]]],[11,"shl_assign","","",4,[[["self"],["u64"]]]],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["u128"]]]],[11,"shl_assign","","",4,[[["self"],["u128"]]]],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["usize"]]]],[11,"shl_assign","","",4,[[["self"],["usize"]]]],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["i8"]]]],[11,"shl_assign","","",4,[[["self"],["i8"]]]],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["i16"]]]],[11,"shl_assign","","",4,[[["self"],["i16"]]]],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["i32"]]]],[11,"shl_assign","","",4,[[["self"],["i32"]]]],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["i64"]]]],[11,"shl_assign","","",4,[[["self"],["i64"]]]],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["i128"]]]],[11,"shl_assign","","",4,[[["self"],["i128"]]]],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["isize"]]]],[11,"shl_assign","","",4,[[["self"],["isize"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["u8"]]]],[11,"shr_assign","","",4,[[["self"],["u8"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["u16"]]]],[11,"shr_assign","","",4,[[["self"],["u16"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["u32"]]]],[11,"shr_assign","","",4,[[["self"],["u32"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["u64"]]]],[11,"shr_assign","","",4,[[["self"],["u64"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["u128"]]]],[11,"shr_assign","","",4,[[["self"],["u128"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["usize"]]]],[11,"shr_assign","","",4,[[["self"],["usize"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["i8"]]]],[11,"shr_assign","","",4,[[["self"],["i8"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["i16"]]]],[11,"shr_assign","","",4,[[["self"],["i16"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["i32"]]]],[11,"shr_assign","","",4,[[["self"],["i32"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["i64"]]]],[11,"shr_assign","","",4,[[["self"],["i64"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["i128"]]]],[11,"shr_assign","","",4,[[["self"],["i128"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["isize"]]]],[11,"shr_assign","","",4,[[["self"],["isize"]]]],[11,"index","","",4,N],[11,"index_mut","","",4,N],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"hash","","",4,[[["self"],["h"]]]],[11,"from_str","","Convert from a hexadecimal string.",4,[[["str"]],["result"]]],[11,"as_byte_slice_mut","","",4,N],[11,"to_le","","",4,[[["self"]]]],[11,"heap_size_of_children","","",4,[[["self"]],["usize"]]],[11,"serialize","","",4,[[["self"],["s"]],["result"]]],[11,"deserialize","","",4,[[["d"]],["result"]]],[11,"convert_into","","",5,N],[11,"convert_into","","",0,N],[11,"convert_into","","",5,N],[11,"convert_into","","",1,N],[11,"convert_into","","",5,N],[11,"convert_into","","",2,N],[11,"convert_into","","",5,N],[11,"convert_into","","",3,N],[11,"convert_into","","",5,N],[11,"convert_into","","",4,N],[11,"repeat_byte","","Return a new fixed hash where all bytes are set to the given byte.",5,[[["u8"]],["self"]]],[11,"zero","","Create a new fixed hash and all bits of it are zeros.",5,[[],["self"]]],[11,"is_zero","","Test if all bits of a fixed hash are zero.",5,[[["self"]],["bool"]]],[11,"is_max","","Test if all bits of a fixed hash are one.",5,[[["self"]],["bool"]]],[11,"covers","","Test if all bits set in a hash are also set in `self`.",5,[[["self"],["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",5,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",5,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",5,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",5,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",5,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",5,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",5,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",5,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",5,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",5,[[["self"]],["option",["usize"]]]],[11,"as_bytes","","Get the inner bytes slice of a fixed hash.",5,N],[11,"as_bytes_mut","","Get the mutable inner bytes slice of a fixed hash.",5,N],[11,"as_fixed_bytes","","Get the inner bytes of a fixed hash.",5,N],[11,"as_fixed_bytes_mut","","Get the mutable inner bytes of a fixed hash.",5,N],[11,"into_fixed_bytes","","Get the inner bytes array of a fixed hash.",5,N],[11,"to_vec","","Get a vec of a fixed hash.",5,[[["self"]],["vec",["u8"]]]],[11,"as_ptr","","Get a constant raw pointer to the inner bytes array of a fixed hash.",5,N],[11,"as_mut_ptr","","Get a mutable raw pointer to the inner bytes array of a fixed hash.",5,N],[11,"from_slice","","Convert from slice.",5,N],[11,"into_slice","","Convert into slice.",5,N],[11,"from_hex_str","","Convert from a fixed length hexadecimal string.",5,[[["str"]],["result",["fixedhasherror"]]]],[11,"from_trimmed_hex_str","","Convert from an arbitrary length zero-trimmed hexadecimal string. Fisrt char should not be zero if the input has more than one char.",5,[[["str"]],["result",["fixedhasherror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",5,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",5,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",5,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",5,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",5,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",5,[[["self"]],["u32"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",5,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",5,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",5,[[["self"]],["option"]]],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",5,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",5,N],[11,"random","","Create a random fixed uint with a input random core.",5,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",5,[[],["self"]]],[11,"clone","","",5,[[["self"]],["self"]]],[11,"default","","",5,[[],["self"]]],[11,"as_ref","","",5,N],[11,"as_mut","","",5,N],[11,"from","","",5,N],[11,"from","","",5,N],[11,"eq","","",5,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",5,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",5,[[["self"],["self"]],["ordering"]]],[11,"bitand","","",5,N],[11,"bitand_assign","","",5,[[["self"],["rhs"]]]],[11,"bitand","","",5,N],[11,"bitand_assign","","",5,[[["self"],["h512"]]]],[11,"bitor","","",5,N],[11,"bitor_assign","","",5,[[["self"],["rhs"]]]],[11,"bitor","","",5,N],[11,"bitor_assign","","",5,[[["self"],["h512"]]]],[11,"bitxor","","",5,N],[11,"bitxor_assign","","",5,[[["self"],["rhs"]]]],[11,"bitxor","","",5,N],[11,"bitxor_assign","","",5,[[["self"],["h512"]]]],[11,"not","","",5,N],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["u8"]]]],[11,"shl_assign","","",5,[[["self"],["u8"]]]],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["u16"]]]],[11,"shl_assign","","",5,[[["self"],["u16"]]]],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["u32"]]]],[11,"shl_assign","","",5,[[["self"],["u32"]]]],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["u64"]]]],[11,"shl_assign","","",5,[[["self"],["u64"]]]],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["u128"]]]],[11,"shl_assign","","",5,[[["self"],["u128"]]]],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["usize"]]]],[11,"shl_assign","","",5,[[["self"],["usize"]]]],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["i8"]]]],[11,"shl_assign","","",5,[[["self"],["i8"]]]],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["i16"]]]],[11,"shl_assign","","",5,[[["self"],["i16"]]]],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["i32"]]]],[11,"shl_assign","","",5,[[["self"],["i32"]]]],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["i64"]]]],[11,"shl_assign","","",5,[[["self"],["i64"]]]],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["i128"]]]],[11,"shl_assign","","",5,[[["self"],["i128"]]]],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["isize"]]]],[11,"shl_assign","","",5,[[["self"],["isize"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["u8"]]]],[11,"shr_assign","","",5,[[["self"],["u8"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["u16"]]]],[11,"shr_assign","","",5,[[["self"],["u16"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["u32"]]]],[11,"shr_assign","","",5,[[["self"],["u32"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["u64"]]]],[11,"shr_assign","","",5,[[["self"],["u64"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["u128"]]]],[11,"shr_assign","","",5,[[["self"],["u128"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["usize"]]]],[11,"shr_assign","","",5,[[["self"],["usize"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["i8"]]]],[11,"shr_assign","","",5,[[["self"],["i8"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["i16"]]]],[11,"shr_assign","","",5,[[["self"],["i16"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["i32"]]]],[11,"shr_assign","","",5,[[["self"],["i32"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["i64"]]]],[11,"shr_assign","","",5,[[["self"],["i64"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["i128"]]]],[11,"shr_assign","","",5,[[["self"],["i128"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["isize"]]]],[11,"shr_assign","","",5,[[["self"],["isize"]]]],[11,"index","","",5,N],[11,"index_mut","","",5,N],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"hash","","",5,[[["self"],["h"]]]],[11,"from_str","","Convert from a hexadecimal string.",5,[[["str"]],["result"]]],[11,"as_byte_slice_mut","","",5,N],[11,"to_le","","",5,[[["self"]]]],[11,"heap_size_of_children","","",5,[[["self"]],["usize"]]],[11,"serialize","","",5,[[["self"],["s"]],["result"]]],[11,"deserialize","","",5,[[["d"]],["result"]]],[11,"convert_into","","",6,N],[11,"convert_into","","",0,N],[11,"convert_into","","",6,N],[11,"convert_into","","",1,N],[11,"convert_into","","",6,N],[11,"convert_into","","",2,N],[11,"convert_into","","",6,N],[11,"convert_into","","",3,N],[11,"convert_into","","",6,N],[11,"convert_into","","",4,N],[11,"convert_into","","",6,N],[11,"convert_into","","",5,N],[11,"repeat_byte","","Return a new fixed hash where all bytes are set to the given byte.",6,[[["u8"]],["self"]]],[11,"zero","","Create a new fixed hash and all bits of it are zeros.",6,[[],["self"]]],[11,"is_zero","","Test if all bits of a fixed hash are zero.",6,[[["self"]],["bool"]]],[11,"is_max","","Test if all bits of a fixed hash are one.",6,[[["self"]],["bool"]]],[11,"covers","","Test if all bits set in a hash are also set in `self`.",6,[[["self"],["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",6,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",6,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",6,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",6,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",6,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",6,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",6,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",6,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",6,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",6,[[["self"]],["option",["usize"]]]],[11,"as_bytes","","Get the inner bytes slice of a fixed hash.",6,N],[11,"as_bytes_mut","","Get the mutable inner bytes slice of a fixed hash.",6,N],[11,"as_fixed_bytes","","Get the inner bytes of a fixed hash.",6,N],[11,"as_fixed_bytes_mut","","Get the mutable inner bytes of a fixed hash.",6,N],[11,"into_fixed_bytes","","Get the inner bytes array of a fixed hash.",6,N],[11,"to_vec","","Get a vec of a fixed hash.",6,[[["self"]],["vec",["u8"]]]],[11,"as_ptr","","Get a constant raw pointer to the inner bytes array of a fixed hash.",6,N],[11,"as_mut_ptr","","Get a mutable raw pointer to the inner bytes array of a fixed hash.",6,N],[11,"from_slice","","Convert from slice.",6,N],[11,"into_slice","","Convert into slice.",6,N],[11,"from_hex_str","","Convert from a fixed length hexadecimal string.",6,[[["str"]],["result",["fixedhasherror"]]]],[11,"from_trimmed_hex_str","","Convert from an arbitrary length zero-trimmed hexadecimal string. Fisrt char should not be zero if the input has more than one char.",6,[[["str"]],["result",["fixedhasherror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",6,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",6,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",6,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",6,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",6,[[["self"]],["u32"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",6,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",6,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",6,[[["self"]],["option"]]],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",6,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",6,N],[11,"random","","Create a random fixed uint with a input random core.",6,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",6,[[],["self"]]],[11,"clone","","",6,[[["self"]],["self"]]],[11,"default","","",6,[[],["self"]]],[11,"as_ref","","",6,N],[11,"as_mut","","",6,N],[11,"from","","",6,N],[11,"from","","",6,N],[11,"eq","","",6,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",6,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",6,[[["self"],["self"]],["ordering"]]],[11,"bitand","","",6,N],[11,"bitand_assign","","",6,[[["self"],["rhs"]]]],[11,"bitand","","",6,N],[11,"bitand_assign","","",6,[[["self"],["h520"]]]],[11,"bitor","","",6,N],[11,"bitor_assign","","",6,[[["self"],["rhs"]]]],[11,"bitor","","",6,N],[11,"bitor_assign","","",6,[[["self"],["h520"]]]],[11,"bitxor","","",6,N],[11,"bitxor_assign","","",6,[[["self"],["rhs"]]]],[11,"bitxor","","",6,N],[11,"bitxor_assign","","",6,[[["self"],["h520"]]]],[11,"not","","",6,N],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["u8"]]]],[11,"shl_assign","","",6,[[["self"],["u8"]]]],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["u16"]]]],[11,"shl_assign","","",6,[[["self"],["u16"]]]],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["u32"]]]],[11,"shl_assign","","",6,[[["self"],["u32"]]]],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["u64"]]]],[11,"shl_assign","","",6,[[["self"],["u64"]]]],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["u128"]]]],[11,"shl_assign","","",6,[[["self"],["u128"]]]],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["usize"]]]],[11,"shl_assign","","",6,[[["self"],["usize"]]]],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["i8"]]]],[11,"shl_assign","","",6,[[["self"],["i8"]]]],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["i16"]]]],[11,"shl_assign","","",6,[[["self"],["i16"]]]],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["i32"]]]],[11,"shl_assign","","",6,[[["self"],["i32"]]]],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["i64"]]]],[11,"shl_assign","","",6,[[["self"],["i64"]]]],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["i128"]]]],[11,"shl_assign","","",6,[[["self"],["i128"]]]],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["isize"]]]],[11,"shl_assign","","",6,[[["self"],["isize"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["u8"]]]],[11,"shr_assign","","",6,[[["self"],["u8"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["u16"]]]],[11,"shr_assign","","",6,[[["self"],["u16"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["u32"]]]],[11,"shr_assign","","",6,[[["self"],["u32"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["u64"]]]],[11,"shr_assign","","",6,[[["self"],["u64"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["u128"]]]],[11,"shr_assign","","",6,[[["self"],["u128"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["usize"]]]],[11,"shr_assign","","",6,[[["self"],["usize"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["i8"]]]],[11,"shr_assign","","",6,[[["self"],["i8"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["i16"]]]],[11,"shr_assign","","",6,[[["self"],["i16"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["i32"]]]],[11,"shr_assign","","",6,[[["self"],["i32"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["i64"]]]],[11,"shr_assign","","",6,[[["self"],["i64"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["i128"]]]],[11,"shr_assign","","",6,[[["self"],["i128"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["isize"]]]],[11,"shr_assign","","",6,[[["self"],["isize"]]]],[11,"index","","",6,N],[11,"index_mut","","",6,N],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"hash","","",6,[[["self"],["h"]]]],[11,"from_str","","Convert from a hexadecimal string.",6,[[["str"]],["result"]]],[11,"as_byte_slice_mut","","",6,N],[11,"to_le","","",6,[[["self"]]]],[11,"heap_size_of_children","","",6,[[["self"]],["usize"]]],[11,"serialize","","",6,[[["self"],["s"]],["result"]]],[11,"deserialize","","",6,[[["d"]],["result"]]],[11,"convert_into","","",7,N],[11,"convert_into","","",0,N],[11,"convert_into","","",7,N],[11,"convert_into","","",1,N],[11,"convert_into","","",7,N],[11,"convert_into","","",2,N],[11,"convert_into","","",7,N],[11,"convert_into","","",3,N],[11,"convert_into","","",7,N],[11,"convert_into","","",4,N],[11,"convert_into","","",7,N],[11,"convert_into","","",5,N],[11,"convert_into","","",7,N],[11,"convert_into","","",6,N],[11,"repeat_byte","","Return a new fixed hash where all bytes are set to the given byte.",7,[[["u8"]],["self"]]],[11,"zero","","Create a new fixed hash and all bits of it are zeros.",7,[[],["self"]]],[11,"is_zero","","Test if all bits of a fixed hash are zero.",7,[[["self"]],["bool"]]],[11,"is_max","","Test if all bits of a fixed hash are one.",7,[[["self"]],["bool"]]],[11,"covers","","Test if all bits set in a hash are also set in `self`.",7,[[["self"],["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",7,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",7,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",7,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",7,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",7,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",7,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",7,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",7,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",7,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",7,[[["self"]],["option",["usize"]]]],[11,"as_bytes","","Get the inner bytes slice of a fixed hash.",7,N],[11,"as_bytes_mut","","Get the mutable inner bytes slice of a fixed hash.",7,N],[11,"as_fixed_bytes","","Get the inner bytes of a fixed hash.",7,N],[11,"as_fixed_bytes_mut","","Get the mutable inner bytes of a fixed hash.",7,N],[11,"into_fixed_bytes","","Get the inner bytes array of a fixed hash.",7,N],[11,"to_vec","","Get a vec of a fixed hash.",7,[[["self"]],["vec",["u8"]]]],[11,"as_ptr","","Get a constant raw pointer to the inner bytes array of a fixed hash.",7,N],[11,"as_mut_ptr","","Get a mutable raw pointer to the inner bytes array of a fixed hash.",7,N],[11,"from_slice","","Convert from slice.",7,N],[11,"into_slice","","Convert into slice.",7,N],[11,"from_hex_str","","Convert from a fixed length hexadecimal string.",7,[[["str"]],["result",["fixedhasherror"]]]],[11,"from_trimmed_hex_str","","Convert from an arbitrary length zero-trimmed hexadecimal string. Fisrt char should not be zero if the input has more than one char.",7,[[["str"]],["result",["fixedhasherror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",7,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",7,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",7,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",7,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",7,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",7,[[["self"]],["u32"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",7,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",7,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",7,[[["self"]],["option"]]],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",7,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",7,N],[11,"random","","Create a random fixed uint with a input random core.",7,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",7,[[],["self"]]],[11,"clone","","",7,[[["self"]],["self"]]],[11,"default","","",7,[[],["self"]]],[11,"as_ref","","",7,N],[11,"as_mut","","",7,N],[11,"from","","",7,N],[11,"from","","",7,N],[11,"eq","","",7,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",7,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",7,[[["self"],["self"]],["ordering"]]],[11,"bitand","","",7,N],[11,"bitand_assign","","",7,[[["self"],["rhs"]]]],[11,"bitand","","",7,N],[11,"bitand_assign","","",7,[[["self"],["h1024"]]]],[11,"bitor","","",7,N],[11,"bitor_assign","","",7,[[["self"],["rhs"]]]],[11,"bitor","","",7,N],[11,"bitor_assign","","",7,[[["self"],["h1024"]]]],[11,"bitxor","","",7,N],[11,"bitxor_assign","","",7,[[["self"],["rhs"]]]],[11,"bitxor","","",7,N],[11,"bitxor_assign","","",7,[[["self"],["h1024"]]]],[11,"not","","",7,N],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["u8"]]]],[11,"shl_assign","","",7,[[["self"],["u8"]]]],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["u16"]]]],[11,"shl_assign","","",7,[[["self"],["u16"]]]],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["u32"]]]],[11,"shl_assign","","",7,[[["self"],["u32"]]]],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["u64"]]]],[11,"shl_assign","","",7,[[["self"],["u64"]]]],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["u128"]]]],[11,"shl_assign","","",7,[[["self"],["u128"]]]],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["usize"]]]],[11,"shl_assign","","",7,[[["self"],["usize"]]]],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["i8"]]]],[11,"shl_assign","","",7,[[["self"],["i8"]]]],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["i16"]]]],[11,"shl_assign","","",7,[[["self"],["i16"]]]],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["i32"]]]],[11,"shl_assign","","",7,[[["self"],["i32"]]]],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["i64"]]]],[11,"shl_assign","","",7,[[["self"],["i64"]]]],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["i128"]]]],[11,"shl_assign","","",7,[[["self"],["i128"]]]],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["isize"]]]],[11,"shl_assign","","",7,[[["self"],["isize"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["u8"]]]],[11,"shr_assign","","",7,[[["self"],["u8"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["u16"]]]],[11,"shr_assign","","",7,[[["self"],["u16"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["u32"]]]],[11,"shr_assign","","",7,[[["self"],["u32"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["u64"]]]],[11,"shr_assign","","",7,[[["self"],["u64"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["u128"]]]],[11,"shr_assign","","",7,[[["self"],["u128"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["usize"]]]],[11,"shr_assign","","",7,[[["self"],["usize"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["i8"]]]],[11,"shr_assign","","",7,[[["self"],["i8"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["i16"]]]],[11,"shr_assign","","",7,[[["self"],["i16"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["i32"]]]],[11,"shr_assign","","",7,[[["self"],["i32"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["i64"]]]],[11,"shr_assign","","",7,[[["self"],["i64"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["i128"]]]],[11,"shr_assign","","",7,[[["self"],["i128"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["isize"]]]],[11,"shr_assign","","",7,[[["self"],["isize"]]]],[11,"index","","",7,N],[11,"index_mut","","",7,N],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"hash","","",7,[[["self"],["h"]]]],[11,"from_str","","Convert from a hexadecimal string.",7,[[["str"]],["result"]]],[11,"as_byte_slice_mut","","",7,N],[11,"to_le","","",7,[[["self"]]]],[11,"heap_size_of_children","","",7,[[["self"]],["usize"]]],[11,"serialize","","",7,[[["self"],["s"]],["result"]]],[11,"deserialize","","",7,[[["d"]],["result"]]],[11,"convert_into","","",8,N],[11,"convert_into","","",0,N],[11,"convert_into","","",8,N],[11,"convert_into","","",1,N],[11,"convert_into","","",8,N],[11,"convert_into","","",2,N],[11,"convert_into","","",8,N],[11,"convert_into","","",3,N],[11,"convert_into","","",8,N],[11,"convert_into","","",4,N],[11,"convert_into","","",8,N],[11,"convert_into","","",5,N],[11,"convert_into","","",8,N],[11,"convert_into","","",6,N],[11,"convert_into","","",8,N],[11,"convert_into","","",7,N],[11,"repeat_byte","","Return a new fixed hash where all bytes are set to the given byte.",8,[[["u8"]],["self"]]],[11,"zero","","Create a new fixed hash and all bits of it are zeros.",8,[[],["self"]]],[11,"is_zero","","Test if all bits of a fixed hash are zero.",8,[[["self"]],["bool"]]],[11,"is_max","","Test if all bits of a fixed hash are one.",8,[[["self"]],["bool"]]],[11,"covers","","Test if all bits set in a hash are also set in `self`.",8,[[["self"],["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",8,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",8,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",8,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",8,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",8,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",8,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",8,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",8,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",8,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",8,[[["self"]],["option",["usize"]]]],[11,"as_bytes","","Get the inner bytes slice of a fixed hash.",8,N],[11,"as_bytes_mut","","Get the mutable inner bytes slice of a fixed hash.",8,N],[11,"as_fixed_bytes","","Get the inner bytes of a fixed hash.",8,N],[11,"as_fixed_bytes_mut","","Get the mutable inner bytes of a fixed hash.",8,N],[11,"into_fixed_bytes","","Get the inner bytes array of a fixed hash.",8,N],[11,"to_vec","","Get a vec of a fixed hash.",8,[[["self"]],["vec",["u8"]]]],[11,"as_ptr","","Get a constant raw pointer to the inner bytes array of a fixed hash.",8,N],[11,"as_mut_ptr","","Get a mutable raw pointer to the inner bytes array of a fixed hash.",8,N],[11,"from_slice","","Convert from slice.",8,N],[11,"into_slice","","Convert into slice.",8,N],[11,"from_hex_str","","Convert from a fixed length hexadecimal string.",8,[[["str"]],["result",["fixedhasherror"]]]],[11,"from_trimmed_hex_str","","Convert from an arbitrary length zero-trimmed hexadecimal string. Fisrt char should not be zero if the input has more than one char.",8,[[["str"]],["result",["fixedhasherror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",8,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",8,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",8,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",8,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",8,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",8,[[["self"]],["u32"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",8,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",8,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",8,[[["self"]],["option"]]],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",8,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",8,N],[11,"random","","Create a random fixed uint with a input random core.",8,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",8,[[],["self"]]],[11,"clone","","",8,[[["self"]],["self"]]],[11,"default","","",8,[[],["self"]]],[11,"as_ref","","",8,N],[11,"as_mut","","",8,N],[11,"from","","",8,N],[11,"from","","",8,N],[11,"eq","","",8,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",8,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",8,[[["self"],["self"]],["ordering"]]],[11,"bitand","","",8,N],[11,"bitand_assign","","",8,[[["self"],["rhs"]]]],[11,"bitand","","",8,N],[11,"bitand_assign","","",8,[[["self"],["h2048"]]]],[11,"bitor","","",8,N],[11,"bitor_assign","","",8,[[["self"],["rhs"]]]],[11,"bitor","","",8,N],[11,"bitor_assign","","",8,[[["self"],["h2048"]]]],[11,"bitxor","","",8,N],[11,"bitxor_assign","","",8,[[["self"],["rhs"]]]],[11,"bitxor","","",8,N],[11,"bitxor_assign","","",8,[[["self"],["h2048"]]]],[11,"not","","",8,N],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["u8"]]]],[11,"shl_assign","","",8,[[["self"],["u8"]]]],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["u16"]]]],[11,"shl_assign","","",8,[[["self"],["u16"]]]],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["u32"]]]],[11,"shl_assign","","",8,[[["self"],["u32"]]]],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["u64"]]]],[11,"shl_assign","","",8,[[["self"],["u64"]]]],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["u128"]]]],[11,"shl_assign","","",8,[[["self"],["u128"]]]],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["usize"]]]],[11,"shl_assign","","",8,[[["self"],["usize"]]]],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["i8"]]]],[11,"shl_assign","","",8,[[["self"],["i8"]]]],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["i16"]]]],[11,"shl_assign","","",8,[[["self"],["i16"]]]],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["i32"]]]],[11,"shl_assign","","",8,[[["self"],["i32"]]]],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["i64"]]]],[11,"shl_assign","","",8,[[["self"],["i64"]]]],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["i128"]]]],[11,"shl_assign","","",8,[[["self"],["i128"]]]],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["isize"]]]],[11,"shl_assign","","",8,[[["self"],["isize"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["u8"]]]],[11,"shr_assign","","",8,[[["self"],["u8"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["u16"]]]],[11,"shr_assign","","",8,[[["self"],["u16"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["u32"]]]],[11,"shr_assign","","",8,[[["self"],["u32"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["u64"]]]],[11,"shr_assign","","",8,[[["self"],["u64"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["u128"]]]],[11,"shr_assign","","",8,[[["self"],["u128"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["usize"]]]],[11,"shr_assign","","",8,[[["self"],["usize"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["i8"]]]],[11,"shr_assign","","",8,[[["self"],["i8"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["i16"]]]],[11,"shr_assign","","",8,[[["self"],["i16"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["i32"]]]],[11,"shr_assign","","",8,[[["self"],["i32"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["i64"]]]],[11,"shr_assign","","",8,[[["self"],["i64"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["i128"]]]],[11,"shr_assign","","",8,[[["self"],["i128"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["isize"]]]],[11,"shr_assign","","",8,[[["self"],["isize"]]]],[11,"index","","",8,N],[11,"index_mut","","",8,N],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"hash","","",8,[[["self"],["h"]]]],[11,"from_str","","Convert from a hexadecimal string.",8,[[["str"]],["result"]]],[11,"as_byte_slice_mut","","",8,N],[11,"to_le","","",8,[[["self"]]]],[11,"heap_size_of_children","","",8,[[["self"]],["usize"]]],[11,"serialize","","",8,[[["self"],["s"]],["result"]]],[11,"deserialize","","",8,[[["d"]],["result"]]],[11,"convert_into","","",9,N],[11,"convert_into","","",0,N],[11,"convert_into","","",9,N],[11,"convert_into","","",1,N],[11,"convert_into","","",9,N],[11,"convert_into","","",2,N],[11,"convert_into","","",9,N],[11,"convert_into","","",3,N],[11,"convert_into","","",9,N],[11,"convert_into","","",4,N],[11,"convert_into","","",9,N],[11,"convert_into","","",5,N],[11,"convert_into","","",9,N],[11,"convert_into","","",6,N],[11,"convert_into","","",9,N],[11,"convert_into","","",7,N],[11,"convert_into","","",9,N],[11,"convert_into","","",8,N],[11,"repeat_byte","","Return a new fixed hash where all bytes are set to the given byte.",9,[[["u8"]],["self"]]],[11,"zero","","Create a new fixed hash and all bits of it are zeros.",9,[[],["self"]]],[11,"is_zero","","Test if all bits of a fixed hash are zero.",9,[[["self"]],["bool"]]],[11,"is_max","","Test if all bits of a fixed hash are one.",9,[[["self"]],["bool"]]],[11,"covers","","Test if all bits set in a hash are also set in `self`.",9,[[["self"],["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",9,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",9,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",9,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",9,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",9,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",9,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",9,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",9,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",9,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",9,[[["self"]],["option",["usize"]]]],[11,"as_bytes","","Get the inner bytes slice of a fixed hash.",9,N],[11,"as_bytes_mut","","Get the mutable inner bytes slice of a fixed hash.",9,N],[11,"as_fixed_bytes","","Get the inner bytes of a fixed hash.",9,N],[11,"as_fixed_bytes_mut","","Get the mutable inner bytes of a fixed hash.",9,N],[11,"into_fixed_bytes","","Get the inner bytes array of a fixed hash.",9,N],[11,"to_vec","","Get a vec of a fixed hash.",9,[[["self"]],["vec",["u8"]]]],[11,"as_ptr","","Get a constant raw pointer to the inner bytes array of a fixed hash.",9,N],[11,"as_mut_ptr","","Get a mutable raw pointer to the inner bytes array of a fixed hash.",9,N],[11,"from_slice","","Convert from slice.",9,N],[11,"into_slice","","Convert into slice.",9,N],[11,"from_hex_str","","Convert from a fixed length hexadecimal string.",9,[[["str"]],["result",["fixedhasherror"]]]],[11,"from_trimmed_hex_str","","Convert from an arbitrary length zero-trimmed hexadecimal string. Fisrt char should not be zero if the input has more than one char.",9,[[["str"]],["result",["fixedhasherror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",9,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",9,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",9,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",9,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",9,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",9,[[["self"]],["u32"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",9,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",9,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",9,[[["self"]],["option"]]],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",9,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",9,N],[11,"random","","Create a random fixed uint with a input random core.",9,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",9,[[],["self"]]],[11,"clone","","",9,[[["self"]],["self"]]],[11,"default","","",9,[[],["self"]]],[11,"as_ref","","",9,N],[11,"as_mut","","",9,N],[11,"from","","",9,N],[11,"from","","",9,N],[11,"eq","","",9,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",9,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",9,[[["self"],["self"]],["ordering"]]],[11,"bitand","","",9,N],[11,"bitand_assign","","",9,[[["self"],["rhs"]]]],[11,"bitand","","",9,N],[11,"bitand_assign","","",9,[[["self"],["h4096"]]]],[11,"bitor","","",9,N],[11,"bitor_assign","","",9,[[["self"],["rhs"]]]],[11,"bitor","","",9,N],[11,"bitor_assign","","",9,[[["self"],["h4096"]]]],[11,"bitxor","","",9,N],[11,"bitxor_assign","","",9,[[["self"],["rhs"]]]],[11,"bitxor","","",9,N],[11,"bitxor_assign","","",9,[[["self"],["h4096"]]]],[11,"not","","",9,N],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["u8"]]]],[11,"shl_assign","","",9,[[["self"],["u8"]]]],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["u16"]]]],[11,"shl_assign","","",9,[[["self"],["u16"]]]],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["u32"]]]],[11,"shl_assign","","",9,[[["self"],["u32"]]]],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["u64"]]]],[11,"shl_assign","","",9,[[["self"],["u64"]]]],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["u128"]]]],[11,"shl_assign","","",9,[[["self"],["u128"]]]],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["usize"]]]],[11,"shl_assign","","",9,[[["self"],["usize"]]]],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["i8"]]]],[11,"shl_assign","","",9,[[["self"],["i8"]]]],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["i16"]]]],[11,"shl_assign","","",9,[[["self"],["i16"]]]],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["i32"]]]],[11,"shl_assign","","",9,[[["self"],["i32"]]]],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["i64"]]]],[11,"shl_assign","","",9,[[["self"],["i64"]]]],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["i128"]]]],[11,"shl_assign","","",9,[[["self"],["i128"]]]],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["isize"]]]],[11,"shl_assign","","",9,[[["self"],["isize"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["u8"]]]],[11,"shr_assign","","",9,[[["self"],["u8"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["u16"]]]],[11,"shr_assign","","",9,[[["self"],["u16"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["u32"]]]],[11,"shr_assign","","",9,[[["self"],["u32"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["u64"]]]],[11,"shr_assign","","",9,[[["self"],["u64"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["u128"]]]],[11,"shr_assign","","",9,[[["self"],["u128"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["usize"]]]],[11,"shr_assign","","",9,[[["self"],["usize"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["i8"]]]],[11,"shr_assign","","",9,[[["self"],["i8"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["i16"]]]],[11,"shr_assign","","",9,[[["self"],["i16"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["i32"]]]],[11,"shr_assign","","",9,[[["self"],["i32"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["i64"]]]],[11,"shr_assign","","",9,[[["self"],["i64"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["i128"]]]],[11,"shr_assign","","",9,[[["self"],["i128"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["isize"]]]],[11,"shr_assign","","",9,[[["self"],["isize"]]]],[11,"index","","",9,N],[11,"index_mut","","",9,N],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"hash","","",9,[[["self"],["h"]]]],[11,"from_str","","Convert from a hexadecimal string.",9,[[["str"]],["result"]]],[11,"as_byte_slice_mut","","",9,N],[11,"to_le","","",9,[[["self"]]]],[11,"heap_size_of_children","","",9,[[["self"]],["usize"]]],[11,"serialize","","",9,[[["self"],["s"]],["result"]]],[11,"deserialize","","",9,[[["d"]],["result"]]],[11,"from","","",0,[[["u128"]],["self"]]],[11,"from","","",0,[[["u128"]],["self"]]],[11,"from","","",1,[[["u160"]],["self"]]],[11,"from","","",1,[[["u160"]],["self"]]],[11,"from","","",2,[[["u224"]],["self"]]],[11,"from","","",2,[[["u224"]],["self"]]],[11,"from","","",3,[[["u256"]],["self"]]],[11,"from","","",3,[[["u256"]],["self"]]],[11,"from","","",4,[[["u384"]],["self"]]],[11,"from","","",4,[[["u384"]],["self"]]],[11,"from","","",5,[[["u512"]],["self"]]],[11,"from","","",5,[[["u512"]],["self"]]],[11,"from","","",7,[[["u1024"]],["self"]]],[11,"from","","",7,[[["u1024"]],["self"]]],[11,"from","","",8,[[["u2048"]],["self"]]],[11,"from","","",8,[[["u2048"]],["self"]]],[11,"from","","",9,[[["u4096"]],["self"]]],[11,"from","","",9,[[["u4096"]],["self"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"from","","",0,[[["t"]],["t"]]],[11,"to_string","","",0,[[["self"]],["string"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,N],[11,"from","","",1,[[["t"]],["t"]]],[11,"to_string","","",1,[[["self"]],["string"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,N],[11,"from","","",2,[[["t"]],["t"]]],[11,"to_string","","",2,[[["self"]],["string"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"to_owned","","",3,[[["self"]],["t"]]],[11,"clone_into","","",3,N],[11,"from","","",3,[[["t"]],["t"]]],[11,"to_string","","",3,[[["self"]],["string"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"to_owned","","",4,[[["self"]],["t"]]],[11,"clone_into","","",4,N],[11,"from","","",4,[[["t"]],["t"]]],[11,"to_string","","",4,[[["self"]],["string"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"to_owned","","",5,[[["self"]],["t"]]],[11,"clone_into","","",5,N],[11,"from","","",5,[[["t"]],["t"]]],[11,"to_string","","",5,[[["self"]],["string"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"to_owned","","",6,[[["self"]],["t"]]],[11,"clone_into","","",6,N],[11,"from","","",6,[[["t"]],["t"]]],[11,"to_string","","",6,[[["self"]],["string"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"to_owned","","",7,[[["self"]],["t"]]],[11,"clone_into","","",7,N],[11,"from","","",7,[[["t"]],["t"]]],[11,"to_string","","",7,[[["self"]],["string"]]],[11,"into","","",7,[[["self"]],["u"]]],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"get_type_id","","",7,[[["self"]],["typeid"]]],[11,"to_owned","","",8,[[["self"]],["t"]]],[11,"clone_into","","",8,N],[11,"from","","",8,[[["t"]],["t"]]],[11,"to_string","","",8,[[["self"]],["string"]]],[11,"into","","",8,[[["self"]],["u"]]],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"try_into","","",8,[[["self"]],["result"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"get_type_id","","",8,[[["self"]],["typeid"]]],[11,"to_owned","","",9,[[["self"]],["t"]]],[11,"clone_into","","",9,N],[11,"from","","",9,[[["t"]],["t"]]],[11,"to_string","","",9,[[["self"]],["string"]]],[11,"into","","",9,[[["self"]],["u"]]],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"try_into","","",9,[[["self"]],["result"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"get_type_id","","",9,[[["self"]],["typeid"]]],[11,"from","","",10,[[["t"]],["t"]]],[11,"to_string","","",10,[[["self"]],["string"]]],[11,"into","","",10,[[["self"]],["u"]]],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"try_into","","",10,[[["self"]],["result"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"get_type_id","","",10,[[["self"]],["typeid"]]],[11,"as_fail","","",10,[[["self"]],["fail"]]],[11,"from","","",11,[[["t"]],["t"]]],[11,"to_string","","",11,[[["self"]],["string"]]],[11,"into","","",11,[[["self"]],["u"]]],[11,"try_from","","",11,[[["u"]],["result"]]],[11,"borrow","","",11,[[["self"]],["t"]]],[11,"try_into","","",11,[[["self"]],["result"]]],[11,"borrow_mut","","",11,[[["self"]],["t"]]],[11,"get_type_id","","",11,[[["self"]],["typeid"]]],[11,"as_fail","","",11,[[["self"]],["fail"]]],[11,"from","","",12,[[["t"]],["t"]]],[11,"to_string","","",12,[[["self"]],["string"]]],[11,"into","","",12,[[["self"]],["u"]]],[11,"try_from","","",12,[[["u"]],["result"]]],[11,"borrow","","",12,[[["self"]],["t"]]],[11,"try_into","","",12,[[["self"]],["result"]]],[11,"borrow_mut","","",12,[[["self"]],["t"]]],[11,"get_type_id","","",12,[[["self"]],["typeid"]]],[11,"as_fail","","",12,[[["self"]],["fail"]]],[11,"from","","",13,[[["t"]],["t"]]],[11,"to_string","","",13,[[["self"]],["string"]]],[11,"into","","",13,[[["self"]],["u"]]],[11,"try_from","","",13,[[["u"]],["result"]]],[11,"borrow","","",13,[[["self"]],["t"]]],[11,"try_into","","",13,[[["self"]],["result"]]],[11,"borrow_mut","","",13,[[["self"]],["t"]]],[11,"get_type_id","","",13,[[["self"]],["typeid"]]],[11,"as_fail","","",13,[[["self"]],["fail"]]]],"paths":[[3,"H128"],[3,"H160"],[3,"H224"],[3,"H256"],[3,"H384"],[3,"H512"],[3,"H520"],[3,"H1024"],[3,"H2048"],[3,"H4096"],[4,"FromSliceError"],[4,"IntoSliceError"],[4,"FromStrError"],[4,"FixedHashError"],[8,"HashConvert"]]};
searchIndex["numext_fixed_hash_tests"]={"doc":"","items":[[0,"props","numext_fixed_hash_tests","Support proptest.",N,N],[3,"H256Bytes","numext_fixed_hash_tests::props","",N,N],[12,"inner","","",0,N],[3,"H256BytesValueTree","","",N,N],[3,"H256BytesParameters","","",N,N],[3,"H256BytesStrategy","","",N,N],[11,"clone","","",0,[[["self"]],["h256bytes"]]],[11,"eq","","",0,[[["self"],["h256bytes"]],["bool"]]],[11,"ne","","",0,[[["self"],["h256bytes"]],["bool"]]],[11,"partial_cmp","","",0,[[["self"],["h256bytes"]],["option",["ordering"]]]],[11,"lt","","",0,[[["self"],["h256bytes"]],["bool"]]],[11,"le","","",0,[[["self"],["h256bytes"]],["bool"]]],[11,"gt","","",0,[[["self"],["h256bytes"]],["bool"]]],[11,"ge","","",0,[[["self"],["h256bytes"]],["bool"]]],[11,"cmp","","",0,[[["self"],["h256bytes"]],["ordering"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"from","","",0,[[["h256"]],["self"]]],[11,"from","","",0,[[["h256"]],["self"]]],[11,"from","","",0,[[["h256"]],["self"]]],[11,"from","","",0,[[["h256"]],["self"]]],[11,"any","","",0,[[["testrng"]],["self"]]],[11,"nonzero","","",0,[[["testrng"]],["self"]]],[11,"new","","",1,[[["testrunner"]],["self"]]],[11,"current","","",1,N],[11,"simplify","","",1,[[["self"]],["bool"]]],[11,"complicate","","",1,[[["self"]],["bool"]]],[11,"clone","","",2,[[["self"]],["h256bytesparameters"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"default","","",2,[[],["h256bytesparameters"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"new","","",3,[[["h256bytesparameters"]],["self"]]],[11,"new_tree","","",3,[[["self"],["testrunner"]],["newtree"]]],[11,"arbitrary_with","","",0,N],[0,"tools","numext_fixed_hash_tests","Testing tools.",N,N],[5,"gen_nonzero","numext_fixed_hash_tests::tools","",N,[[],["t"]]],[5,"bytes","","",N,[[],["h256bytes"]]],[5,"padding_str","","",N,[[["str"],["usize"]],["string"]]],[11,"to_owned","numext_fixed_hash_tests::props","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"from","","",0,[[["t"]],["t"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,N],[11,"from","","",2,[[["t"]],["t"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]]],"paths":[[3,"H256Bytes"],[3,"H256BytesValueTree"],[3,"H256BytesParameters"],[3,"H256BytesStrategy"]]};
searchIndex["numext_fixed_uint"]={"doc":"","items":[[3,"U128","numext_fixed_uint","Little-endian fixed integer type.",N,N],[12,"0","","",0,N],[3,"U160","","Little-endian fixed integer type.",N,N],[12,"0","","",1,N],[3,"U224","","Little-endian fixed integer type.",N,N],[12,"0","","",2,N],[3,"U256","","Little-endian fixed integer type.",N,N],[12,"0","","",3,N],[3,"U384","","Little-endian fixed integer type.",N,N],[12,"0","","",4,N],[3,"U512","","Little-endian fixed integer type.",N,N],[12,"0","","",5,N],[3,"U520","","Little-endian fixed integer type.",N,N],[12,"0","","",6,N],[3,"U1024","","Little-endian fixed integer type.",N,N],[12,"0","","",7,N],[3,"U2048","","Little-endian fixed integer type.",N,N],[12,"0","","",8,N],[3,"U4096","","Little-endian fixed integer type.",N,N],[12,"0","","",9,N],[4,"FromSliceError","","Error for parse from slice.",N,N],[13,"InvalidLength","","",10,N],[4,"IntoSliceError","","Error for parse from slice.",N,N],[13,"InvalidLength","","",11,N],[4,"FromStrError","","Error for parse from string.",N,N],[13,"InvalidCharacter","","",12,N],[12,"chr","numext_fixed_uint::FromStrError","",12,N],[12,"idx","","",12,N],[13,"InvalidLength","numext_fixed_uint","",12,N],[13,"Overflow","","",12,N],[4,"FixedUintError","","",N,N],[13,"FromSlice","","",13,N],[13,"IntoSlice","","",13,N],[13,"FromStr","","",13,N],[0,"prelude","","",N,N],[8,"UintConvert","numext_fixed_uint::prelude","",N,N],[10,"convert_into","","Convert a fixed uint into another, return the new fixed uint and if it be truncated.",14,N],[11,"fmt","numext_fixed_uint","",10,[[["self"],["formatter"]],["result"]]],[11,"from","","",13,[[["fromsliceerror"]],["fixeduinterror"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"from","","",13,[[["intosliceerror"]],["fixeduinterror"]]],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"from","","",13,[[["fromstrerror"]],["fixeduinterror"]]],[11,"fmt","","",13,[[["self"],["formatter"]],["result"]]],[11,"zero","","Create a new fixed uint and value is zero.",0,[[],["self"]]],[11,"one","","Create a new fixed uint and value is zero.",0,[[],["self"]]],[11,"is_zero","","Test if a fixed uint is zero.",0,[[["self"]],["bool"]]],[11,"is_max","","Test if a fixed uint is the max value.",0,[[["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",0,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",0,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",0,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",0,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",0,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",0,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",0,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",0,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",0,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",0,[[["self"]],["option",["usize"]]]],[11,"complete_mul","","Calculates the multiplication of `self` and `other`.",0,N],[11,"complete_div","","Calculates both the quotient and the remainder when `self` is divided by `other`.",0,N],[11,"gcd","","Calculates the Greatest Common Divisor (GCD).",0,[[["self"],["self"]],["self"]]],[11,"from_little_endian","","Convert from little-endian slice.",0,N],[11,"from_big_endian","","Convert from big-endian slice.",0,N],[11,"into_little_endian","","Convert into little-endian slice.",0,N],[11,"into_big_endian","","Convert into big-endian slice.",0,N],[11,"from_bin_str","","Convert from a binary string.",0,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_oct_str","","Convert from a octal string.",0,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_hex_str","","Convert from a hexadecimal string.",0,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_dec_str","","Convert from a decimal string.",0,[[["str"]],["result",["fixeduinterror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",0,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",0,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",0,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",0,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",0,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",0,[[["self"]],["u32"]]],[11,"checked_add","","Checked integer addition. Computes `self + rhs`, returning `None` if overflow occurred.",0,[[["self"],["self"]],["option"]]],[11,"checked_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",0,[[["self"],["self"]],["option"]]],[11,"checked_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",0,[[["self"],["self"]],["option"]]],[11,"checked_div","","Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`.",0,[[["self"],["self"]],["option"]]],[11,"checked_rem","","Checked integer remainder. Computes `self % rhs`, returning `None` if `rhs == 0`.",0,[[["self"],["self"]],["option"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",0,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",0,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",0,[[["self"]],["option"]]],[11,"saturating_add","","Saturating integer addition. Computes `self + rhs`, saturating at the numeric bounds instead of overflowing.",0,[[["self"],["self"]],["self"]]],[11,"saturating_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",0,[[["self"],["self"]],["self"]]],[11,"saturating_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",0,[[["self"],["self"]],["self"]]],[11,"overflowing_add","","Calculates `self + rhs`.",0,N],[11,"overflowing_sub","","Calculates `self - rhs`.",0,N],[11,"overflowing_mul","","Calculates the multiplication of `self` and `rhs`.",0,N],[11,"overflowing_div","","Calculates the divisor when `self` is divided by `rhs`.",0,N],[11,"overflowing_rem","","Calculates the remainder when `self` is divided by `rhs`.",0,N],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",0,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",0,N],[11,"overflowing_neg","","Negates `self` in an overflowing fashion.",0,N],[11,"random","","Create a random fixed uint with a input random core.",0,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",0,[[],["self"]]],[11,"clone","","",0,[[["self"]],["self"]]],[11,"default","","",0,[[],["self"]]],[11,"eq","","",0,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",0,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",0,[[["self"],["self"]],["ordering"]]],[11,"add","","",0,N],[11,"add_assign","","",0,[[["self"],["rhs"]]]],[11,"add","","",0,N],[11,"add_assign","","",0,[[["self"],["u128"]]]],[11,"sub","","",0,N],[11,"sub_assign","","",0,[[["self"],["rhs"]]]],[11,"sub","","",0,N],[11,"sub_assign","","",0,[[["self"],["u128"]]]],[11,"mul","","",0,N],[11,"mul_assign","","",0,[[["self"],["rhs"]]]],[11,"mul","","",0,N],[11,"mul_assign","","",0,[[["self"],["u128"]]]],[11,"div","","",0,N],[11,"div_assign","","",0,[[["self"],["rhs"]]]],[11,"div","","",0,N],[11,"div_assign","","",0,[[["self"],["u128"]]]],[11,"rem","","",0,N],[11,"rem_assign","","",0,[[["self"],["rhs"]]]],[11,"rem","","",0,N],[11,"rem_assign","","",0,[[["self"],["u128"]]]],[11,"bitand","","",0,N],[11,"bitand_assign","","",0,[[["self"],["rhs"]]]],[11,"bitand","","",0,N],[11,"bitand_assign","","",0,[[["self"],["u128"]]]],[11,"bitor","","",0,N],[11,"bitor_assign","","",0,[[["self"],["rhs"]]]],[11,"bitor","","",0,N],[11,"bitor_assign","","",0,[[["self"],["u128"]]]],[11,"bitxor","","",0,N],[11,"bitxor_assign","","",0,[[["self"],["rhs"]]]],[11,"bitxor","","",0,N],[11,"bitxor_assign","","",0,[[["self"],["u128"]]]],[11,"not","","",0,N],[11,"shl","","",0,N],[11,"shl","","",0,N],[11,"shl_assign","","",0,[[["self"],["u8"]]]],[11,"shl_assign","","",0,[[["self"],["u8"]]]],[11,"shl","","",0,N],[11,"shl","","",0,N],[11,"shl_assign","","",0,[[["self"],["u16"]]]],[11,"shl_assign","","",0,[[["self"],["u16"]]]],[11,"shl","","",0,N],[11,"shl","","",0,N],[11,"shl_assign","","",0,[[["self"],["u32"]]]],[11,"shl_assign","","",0,[[["self"],["u32"]]]],[11,"shl","","",0,N],[11,"shl","","",0,N],[11,"shl_assign","","",0,[[["self"],["u64"]]]],[11,"shl_assign","","",0,[[["self"],["u64"]]]],[11,"shl","","",0,N],[11,"shl","","",0,N],[11,"shl_assign","","",0,[[["self"],["u128"]]]],[11,"shl_assign","","",0,[[["self"],["u128"]]]],[11,"shl","","",0,N],[11,"shl","","",0,N],[11,"shl_assign","","",0,[[["self"],["usize"]]]],[11,"shl_assign","","",0,[[["self"],["usize"]]]],[11,"shl","","",0,N],[11,"shl","","",0,N],[11,"shl_assign","","",0,[[["self"],["i8"]]]],[11,"shl_assign","","",0,[[["self"],["i8"]]]],[11,"shl","","",0,N],[11,"shl","","",0,N],[11,"shl_assign","","",0,[[["self"],["i16"]]]],[11,"shl_assign","","",0,[[["self"],["i16"]]]],[11,"shl","","",0,N],[11,"shl","","",0,N],[11,"shl_assign","","",0,[[["self"],["i32"]]]],[11,"shl_assign","","",0,[[["self"],["i32"]]]],[11,"shl","","",0,N],[11,"shl","","",0,N],[11,"shl_assign","","",0,[[["self"],["i64"]]]],[11,"shl_assign","","",0,[[["self"],["i64"]]]],[11,"shl","","",0,N],[11,"shl","","",0,N],[11,"shl_assign","","",0,[[["self"],["i128"]]]],[11,"shl_assign","","",0,[[["self"],["i128"]]]],[11,"shl","","",0,N],[11,"shl","","",0,N],[11,"shl_assign","","",0,[[["self"],["isize"]]]],[11,"shl_assign","","",0,[[["self"],["isize"]]]],[11,"shr","","",0,N],[11,"shr","","",0,N],[11,"shr_assign","","",0,[[["self"],["u8"]]]],[11,"shr_assign","","",0,[[["self"],["u8"]]]],[11,"shr","","",0,N],[11,"shr","","",0,N],[11,"shr_assign","","",0,[[["self"],["u16"]]]],[11,"shr_assign","","",0,[[["self"],["u16"]]]],[11,"shr","","",0,N],[11,"shr","","",0,N],[11,"shr_assign","","",0,[[["self"],["u32"]]]],[11,"shr_assign","","",0,[[["self"],["u32"]]]],[11,"shr","","",0,N],[11,"shr","","",0,N],[11,"shr_assign","","",0,[[["self"],["u64"]]]],[11,"shr_assign","","",0,[[["self"],["u64"]]]],[11,"shr","","",0,N],[11,"shr","","",0,N],[11,"shr_assign","","",0,[[["self"],["u128"]]]],[11,"shr_assign","","",0,[[["self"],["u128"]]]],[11,"shr","","",0,N],[11,"shr","","",0,N],[11,"shr_assign","","",0,[[["self"],["usize"]]]],[11,"shr_assign","","",0,[[["self"],["usize"]]]],[11,"shr","","",0,N],[11,"shr","","",0,N],[11,"shr_assign","","",0,[[["self"],["i8"]]]],[11,"shr_assign","","",0,[[["self"],["i8"]]]],[11,"shr","","",0,N],[11,"shr","","",0,N],[11,"shr_assign","","",0,[[["self"],["i16"]]]],[11,"shr_assign","","",0,[[["self"],["i16"]]]],[11,"shr","","",0,N],[11,"shr","","",0,N],[11,"shr_assign","","",0,[[["self"],["i32"]]]],[11,"shr_assign","","",0,[[["self"],["i32"]]]],[11,"shr","","",0,N],[11,"shr","","",0,N],[11,"shr_assign","","",0,[[["self"],["i64"]]]],[11,"shr_assign","","",0,[[["self"],["i64"]]]],[11,"shr","","",0,N],[11,"shr","","",0,N],[11,"shr_assign","","",0,[[["self"],["i128"]]]],[11,"shr_assign","","",0,[[["self"],["i128"]]]],[11,"shr","","",0,N],[11,"shr","","",0,N],[11,"shr_assign","","",0,[[["self"],["isize"]]]],[11,"shr_assign","","",0,[[["self"],["isize"]]]],[11,"from","","",0,[[["bool"]],["self"]]],[11,"from","","",0,[[["u8"]],["self"]]],[11,"from","","",0,[[["u8"]],["self"]]],[11,"from","","",0,[[["u16"]],["self"]]],[11,"from","","",0,[[["u16"]],["self"]]],[11,"from","","",0,[[["u32"]],["self"]]],[11,"from","","",0,[[["u32"]],["self"]]],[11,"from","","",0,[[["u64"]],["self"]]],[11,"from","","",0,[[["u64"]],["self"]]],[11,"from","","",0,[[["u128"]],["self"]]],[11,"from","","",0,[[["u128"]],["self"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"hash","","",0,[[["self"],["h"]]]],[11,"sum","","",0,[[["i"]],["self"]]],[11,"sum","","",0,[[["i"]],["self"]]],[11,"product","","",0,[[["i"]],["self"]]],[11,"product","","",0,[[["i"]],["self"]]],[11,"as_byte_slice_mut","","",0,N],[11,"to_le","","",0,[[["self"]]]],[11,"heap_size_of_children","","",0,[[["self"]],["usize"]]],[11,"serialize","","",0,[[["self"],["s"]],["result"]]],[11,"deserialize","","",0,[[["d"]],["result"]]],[11,"convert_into","","",1,N],[11,"convert_into","","",0,N],[11,"zero","","Create a new fixed uint and value is zero.",1,[[],["self"]]],[11,"one","","Create a new fixed uint and value is zero.",1,[[],["self"]]],[11,"is_zero","","Test if a fixed uint is zero.",1,[[["self"]],["bool"]]],[11,"is_max","","Test if a fixed uint is the max value.",1,[[["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",1,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",1,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",1,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",1,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",1,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",1,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",1,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",1,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",1,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",1,[[["self"]],["option",["usize"]]]],[11,"complete_mul","","Calculates the multiplication of `self` and `other`.",1,N],[11,"complete_div","","Calculates both the quotient and the remainder when `self` is divided by `other`.",1,N],[11,"gcd","","Calculates the Greatest Common Divisor (GCD).",1,[[["self"],["self"]],["self"]]],[11,"from_little_endian","","Convert from little-endian slice.",1,N],[11,"from_big_endian","","Convert from big-endian slice.",1,N],[11,"into_little_endian","","Convert into little-endian slice.",1,N],[11,"into_big_endian","","Convert into big-endian slice.",1,N],[11,"from_bin_str","","Convert from a binary string.",1,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_oct_str","","Convert from a octal string.",1,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_hex_str","","Convert from a hexadecimal string.",1,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_dec_str","","Convert from a decimal string.",1,[[["str"]],["result",["fixeduinterror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",1,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",1,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",1,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",1,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",1,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",1,[[["self"]],["u32"]]],[11,"checked_add","","Checked integer addition. Computes `self + rhs`, returning `None` if overflow occurred.",1,[[["self"],["self"]],["option"]]],[11,"checked_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",1,[[["self"],["self"]],["option"]]],[11,"checked_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",1,[[["self"],["self"]],["option"]]],[11,"checked_div","","Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`.",1,[[["self"],["self"]],["option"]]],[11,"checked_rem","","Checked integer remainder. Computes `self % rhs`, returning `None` if `rhs == 0`.",1,[[["self"],["self"]],["option"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",1,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",1,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",1,[[["self"]],["option"]]],[11,"saturating_add","","Saturating integer addition. Computes `self + rhs`, saturating at the numeric bounds instead of overflowing.",1,[[["self"],["self"]],["self"]]],[11,"saturating_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",1,[[["self"],["self"]],["self"]]],[11,"saturating_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",1,[[["self"],["self"]],["self"]]],[11,"overflowing_add","","Calculates `self + rhs`.",1,N],[11,"overflowing_sub","","Calculates `self - rhs`.",1,N],[11,"overflowing_mul","","Calculates the multiplication of `self` and `rhs`.",1,N],[11,"overflowing_div","","Calculates the divisor when `self` is divided by `rhs`.",1,N],[11,"overflowing_rem","","Calculates the remainder when `self` is divided by `rhs`.",1,N],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",1,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",1,N],[11,"overflowing_neg","","Negates `self` in an overflowing fashion.",1,N],[11,"random","","Create a random fixed uint with a input random core.",1,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",1,[[],["self"]]],[11,"clone","","",1,[[["self"]],["self"]]],[11,"default","","",1,[[],["self"]]],[11,"eq","","",1,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",1,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",1,[[["self"],["self"]],["ordering"]]],[11,"add","","",1,N],[11,"add_assign","","",1,[[["self"],["rhs"]]]],[11,"add","","",1,N],[11,"add_assign","","",1,[[["self"],["u160"]]]],[11,"sub","","",1,N],[11,"sub_assign","","",1,[[["self"],["rhs"]]]],[11,"sub","","",1,N],[11,"sub_assign","","",1,[[["self"],["u160"]]]],[11,"mul","","",1,N],[11,"mul_assign","","",1,[[["self"],["rhs"]]]],[11,"mul","","",1,N],[11,"mul_assign","","",1,[[["self"],["u160"]]]],[11,"div","","",1,N],[11,"div_assign","","",1,[[["self"],["rhs"]]]],[11,"div","","",1,N],[11,"div_assign","","",1,[[["self"],["u160"]]]],[11,"rem","","",1,N],[11,"rem_assign","","",1,[[["self"],["rhs"]]]],[11,"rem","","",1,N],[11,"rem_assign","","",1,[[["self"],["u160"]]]],[11,"bitand","","",1,N],[11,"bitand_assign","","",1,[[["self"],["rhs"]]]],[11,"bitand","","",1,N],[11,"bitand_assign","","",1,[[["self"],["u160"]]]],[11,"bitor","","",1,N],[11,"bitor_assign","","",1,[[["self"],["rhs"]]]],[11,"bitor","","",1,N],[11,"bitor_assign","","",1,[[["self"],["u160"]]]],[11,"bitxor","","",1,N],[11,"bitxor_assign","","",1,[[["self"],["rhs"]]]],[11,"bitxor","","",1,N],[11,"bitxor_assign","","",1,[[["self"],["u160"]]]],[11,"not","","",1,N],[11,"shl","","",1,N],[11,"shl","","",1,N],[11,"shl_assign","","",1,[[["self"],["u8"]]]],[11,"shl_assign","","",1,[[["self"],["u8"]]]],[11,"shl","","",1,N],[11,"shl","","",1,N],[11,"shl_assign","","",1,[[["self"],["u16"]]]],[11,"shl_assign","","",1,[[["self"],["u16"]]]],[11,"shl","","",1,N],[11,"shl","","",1,N],[11,"shl_assign","","",1,[[["self"],["u32"]]]],[11,"shl_assign","","",1,[[["self"],["u32"]]]],[11,"shl","","",1,N],[11,"shl","","",1,N],[11,"shl_assign","","",1,[[["self"],["u64"]]]],[11,"shl_assign","","",1,[[["self"],["u64"]]]],[11,"shl","","",1,N],[11,"shl","","",1,N],[11,"shl_assign","","",1,[[["self"],["u128"]]]],[11,"shl_assign","","",1,[[["self"],["u128"]]]],[11,"shl","","",1,N],[11,"shl","","",1,N],[11,"shl_assign","","",1,[[["self"],["usize"]]]],[11,"shl_assign","","",1,[[["self"],["usize"]]]],[11,"shl","","",1,N],[11,"shl","","",1,N],[11,"shl_assign","","",1,[[["self"],["i8"]]]],[11,"shl_assign","","",1,[[["self"],["i8"]]]],[11,"shl","","",1,N],[11,"shl","","",1,N],[11,"shl_assign","","",1,[[["self"],["i16"]]]],[11,"shl_assign","","",1,[[["self"],["i16"]]]],[11,"shl","","",1,N],[11,"shl","","",1,N],[11,"shl_assign","","",1,[[["self"],["i32"]]]],[11,"shl_assign","","",1,[[["self"],["i32"]]]],[11,"shl","","",1,N],[11,"shl","","",1,N],[11,"shl_assign","","",1,[[["self"],["i64"]]]],[11,"shl_assign","","",1,[[["self"],["i64"]]]],[11,"shl","","",1,N],[11,"shl","","",1,N],[11,"shl_assign","","",1,[[["self"],["i128"]]]],[11,"shl_assign","","",1,[[["self"],["i128"]]]],[11,"shl","","",1,N],[11,"shl","","",1,N],[11,"shl_assign","","",1,[[["self"],["isize"]]]],[11,"shl_assign","","",1,[[["self"],["isize"]]]],[11,"shr","","",1,N],[11,"shr","","",1,N],[11,"shr_assign","","",1,[[["self"],["u8"]]]],[11,"shr_assign","","",1,[[["self"],["u8"]]]],[11,"shr","","",1,N],[11,"shr","","",1,N],[11,"shr_assign","","",1,[[["self"],["u16"]]]],[11,"shr_assign","","",1,[[["self"],["u16"]]]],[11,"shr","","",1,N],[11,"shr","","",1,N],[11,"shr_assign","","",1,[[["self"],["u32"]]]],[11,"shr_assign","","",1,[[["self"],["u32"]]]],[11,"shr","","",1,N],[11,"shr","","",1,N],[11,"shr_assign","","",1,[[["self"],["u64"]]]],[11,"shr_assign","","",1,[[["self"],["u64"]]]],[11,"shr","","",1,N],[11,"shr","","",1,N],[11,"shr_assign","","",1,[[["self"],["u128"]]]],[11,"shr_assign","","",1,[[["self"],["u128"]]]],[11,"shr","","",1,N],[11,"shr","","",1,N],[11,"shr_assign","","",1,[[["self"],["usize"]]]],[11,"shr_assign","","",1,[[["self"],["usize"]]]],[11,"shr","","",1,N],[11,"shr","","",1,N],[11,"shr_assign","","",1,[[["self"],["i8"]]]],[11,"shr_assign","","",1,[[["self"],["i8"]]]],[11,"shr","","",1,N],[11,"shr","","",1,N],[11,"shr_assign","","",1,[[["self"],["i16"]]]],[11,"shr_assign","","",1,[[["self"],["i16"]]]],[11,"shr","","",1,N],[11,"shr","","",1,N],[11,"shr_assign","","",1,[[["self"],["i32"]]]],[11,"shr_assign","","",1,[[["self"],["i32"]]]],[11,"shr","","",1,N],[11,"shr","","",1,N],[11,"shr_assign","","",1,[[["self"],["i64"]]]],[11,"shr_assign","","",1,[[["self"],["i64"]]]],[11,"shr","","",1,N],[11,"shr","","",1,N],[11,"shr_assign","","",1,[[["self"],["i128"]]]],[11,"shr_assign","","",1,[[["self"],["i128"]]]],[11,"shr","","",1,N],[11,"shr","","",1,N],[11,"shr_assign","","",1,[[["self"],["isize"]]]],[11,"shr_assign","","",1,[[["self"],["isize"]]]],[11,"from","","",1,[[["bool"]],["self"]]],[11,"from","","",1,[[["u8"]],["self"]]],[11,"from","","",1,[[["u8"]],["self"]]],[11,"from","","",1,[[["u16"]],["self"]]],[11,"from","","",1,[[["u16"]],["self"]]],[11,"from","","",1,[[["u32"]],["self"]]],[11,"from","","",1,[[["u32"]],["self"]]],[11,"from","","",1,[[["u64"]],["self"]]],[11,"from","","",1,[[["u64"]],["self"]]],[11,"from","","",1,[[["u128"]],["self"]]],[11,"from","","",1,[[["u128"]],["self"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"hash","","",1,[[["self"],["h"]]]],[11,"sum","","",1,[[["i"]],["self"]]],[11,"sum","","",1,[[["i"]],["self"]]],[11,"product","","",1,[[["i"]],["self"]]],[11,"product","","",1,[[["i"]],["self"]]],[11,"as_byte_slice_mut","","",1,N],[11,"to_le","","",1,[[["self"]]]],[11,"heap_size_of_children","","",1,[[["self"]],["usize"]]],[11,"serialize","","",1,[[["self"],["s"]],["result"]]],[11,"deserialize","","",1,[[["d"]],["result"]]],[11,"convert_into","","",2,N],[11,"convert_into","","",0,N],[11,"convert_into","","",2,N],[11,"convert_into","","",1,N],[11,"zero","","Create a new fixed uint and value is zero.",2,[[],["self"]]],[11,"one","","Create a new fixed uint and value is zero.",2,[[],["self"]]],[11,"is_zero","","Test if a fixed uint is zero.",2,[[["self"]],["bool"]]],[11,"is_max","","Test if a fixed uint is the max value.",2,[[["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",2,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",2,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",2,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",2,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",2,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",2,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",2,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",2,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",2,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",2,[[["self"]],["option",["usize"]]]],[11,"complete_mul","","Calculates the multiplication of `self` and `other`.",2,N],[11,"complete_div","","Calculates both the quotient and the remainder when `self` is divided by `other`.",2,N],[11,"gcd","","Calculates the Greatest Common Divisor (GCD).",2,[[["self"],["self"]],["self"]]],[11,"from_little_endian","","Convert from little-endian slice.",2,N],[11,"from_big_endian","","Convert from big-endian slice.",2,N],[11,"into_little_endian","","Convert into little-endian slice.",2,N],[11,"into_big_endian","","Convert into big-endian slice.",2,N],[11,"from_bin_str","","Convert from a binary string.",2,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_oct_str","","Convert from a octal string.",2,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_hex_str","","Convert from a hexadecimal string.",2,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_dec_str","","Convert from a decimal string.",2,[[["str"]],["result",["fixeduinterror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",2,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",2,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",2,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",2,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",2,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",2,[[["self"]],["u32"]]],[11,"checked_add","","Checked integer addition. Computes `self + rhs`, returning `None` if overflow occurred.",2,[[["self"],["self"]],["option"]]],[11,"checked_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",2,[[["self"],["self"]],["option"]]],[11,"checked_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",2,[[["self"],["self"]],["option"]]],[11,"checked_div","","Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`.",2,[[["self"],["self"]],["option"]]],[11,"checked_rem","","Checked integer remainder. Computes `self % rhs`, returning `None` if `rhs == 0`.",2,[[["self"],["self"]],["option"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",2,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",2,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",2,[[["self"]],["option"]]],[11,"saturating_add","","Saturating integer addition. Computes `self + rhs`, saturating at the numeric bounds instead of overflowing.",2,[[["self"],["self"]],["self"]]],[11,"saturating_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",2,[[["self"],["self"]],["self"]]],[11,"saturating_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",2,[[["self"],["self"]],["self"]]],[11,"overflowing_add","","Calculates `self + rhs`.",2,N],[11,"overflowing_sub","","Calculates `self - rhs`.",2,N],[11,"overflowing_mul","","Calculates the multiplication of `self` and `rhs`.",2,N],[11,"overflowing_div","","Calculates the divisor when `self` is divided by `rhs`.",2,N],[11,"overflowing_rem","","Calculates the remainder when `self` is divided by `rhs`.",2,N],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",2,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",2,N],[11,"overflowing_neg","","Negates `self` in an overflowing fashion.",2,N],[11,"random","","Create a random fixed uint with a input random core.",2,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",2,[[],["self"]]],[11,"clone","","",2,[[["self"]],["self"]]],[11,"default","","",2,[[],["self"]]],[11,"eq","","",2,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",2,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",2,[[["self"],["self"]],["ordering"]]],[11,"add","","",2,N],[11,"add_assign","","",2,[[["self"],["rhs"]]]],[11,"add","","",2,N],[11,"add_assign","","",2,[[["self"],["u224"]]]],[11,"sub","","",2,N],[11,"sub_assign","","",2,[[["self"],["rhs"]]]],[11,"sub","","",2,N],[11,"sub_assign","","",2,[[["self"],["u224"]]]],[11,"mul","","",2,N],[11,"mul_assign","","",2,[[["self"],["rhs"]]]],[11,"mul","","",2,N],[11,"mul_assign","","",2,[[["self"],["u224"]]]],[11,"div","","",2,N],[11,"div_assign","","",2,[[["self"],["rhs"]]]],[11,"div","","",2,N],[11,"div_assign","","",2,[[["self"],["u224"]]]],[11,"rem","","",2,N],[11,"rem_assign","","",2,[[["self"],["rhs"]]]],[11,"rem","","",2,N],[11,"rem_assign","","",2,[[["self"],["u224"]]]],[11,"bitand","","",2,N],[11,"bitand_assign","","",2,[[["self"],["rhs"]]]],[11,"bitand","","",2,N],[11,"bitand_assign","","",2,[[["self"],["u224"]]]],[11,"bitor","","",2,N],[11,"bitor_assign","","",2,[[["self"],["rhs"]]]],[11,"bitor","","",2,N],[11,"bitor_assign","","",2,[[["self"],["u224"]]]],[11,"bitxor","","",2,N],[11,"bitxor_assign","","",2,[[["self"],["rhs"]]]],[11,"bitxor","","",2,N],[11,"bitxor_assign","","",2,[[["self"],["u224"]]]],[11,"not","","",2,N],[11,"shl","","",2,N],[11,"shl","","",2,N],[11,"shl_assign","","",2,[[["self"],["u8"]]]],[11,"shl_assign","","",2,[[["self"],["u8"]]]],[11,"shl","","",2,N],[11,"shl","","",2,N],[11,"shl_assign","","",2,[[["self"],["u16"]]]],[11,"shl_assign","","",2,[[["self"],["u16"]]]],[11,"shl","","",2,N],[11,"shl","","",2,N],[11,"shl_assign","","",2,[[["self"],["u32"]]]],[11,"shl_assign","","",2,[[["self"],["u32"]]]],[11,"shl","","",2,N],[11,"shl","","",2,N],[11,"shl_assign","","",2,[[["self"],["u64"]]]],[11,"shl_assign","","",2,[[["self"],["u64"]]]],[11,"shl","","",2,N],[11,"shl","","",2,N],[11,"shl_assign","","",2,[[["self"],["u128"]]]],[11,"shl_assign","","",2,[[["self"],["u128"]]]],[11,"shl","","",2,N],[11,"shl","","",2,N],[11,"shl_assign","","",2,[[["self"],["usize"]]]],[11,"shl_assign","","",2,[[["self"],["usize"]]]],[11,"shl","","",2,N],[11,"shl","","",2,N],[11,"shl_assign","","",2,[[["self"],["i8"]]]],[11,"shl_assign","","",2,[[["self"],["i8"]]]],[11,"shl","","",2,N],[11,"shl","","",2,N],[11,"shl_assign","","",2,[[["self"],["i16"]]]],[11,"shl_assign","","",2,[[["self"],["i16"]]]],[11,"shl","","",2,N],[11,"shl","","",2,N],[11,"shl_assign","","",2,[[["self"],["i32"]]]],[11,"shl_assign","","",2,[[["self"],["i32"]]]],[11,"shl","","",2,N],[11,"shl","","",2,N],[11,"shl_assign","","",2,[[["self"],["i64"]]]],[11,"shl_assign","","",2,[[["self"],["i64"]]]],[11,"shl","","",2,N],[11,"shl","","",2,N],[11,"shl_assign","","",2,[[["self"],["i128"]]]],[11,"shl_assign","","",2,[[["self"],["i128"]]]],[11,"shl","","",2,N],[11,"shl","","",2,N],[11,"shl_assign","","",2,[[["self"],["isize"]]]],[11,"shl_assign","","",2,[[["self"],["isize"]]]],[11,"shr","","",2,N],[11,"shr","","",2,N],[11,"shr_assign","","",2,[[["self"],["u8"]]]],[11,"shr_assign","","",2,[[["self"],["u8"]]]],[11,"shr","","",2,N],[11,"shr","","",2,N],[11,"shr_assign","","",2,[[["self"],["u16"]]]],[11,"shr_assign","","",2,[[["self"],["u16"]]]],[11,"shr","","",2,N],[11,"shr","","",2,N],[11,"shr_assign","","",2,[[["self"],["u32"]]]],[11,"shr_assign","","",2,[[["self"],["u32"]]]],[11,"shr","","",2,N],[11,"shr","","",2,N],[11,"shr_assign","","",2,[[["self"],["u64"]]]],[11,"shr_assign","","",2,[[["self"],["u64"]]]],[11,"shr","","",2,N],[11,"shr","","",2,N],[11,"shr_assign","","",2,[[["self"],["u128"]]]],[11,"shr_assign","","",2,[[["self"],["u128"]]]],[11,"shr","","",2,N],[11,"shr","","",2,N],[11,"shr_assign","","",2,[[["self"],["usize"]]]],[11,"shr_assign","","",2,[[["self"],["usize"]]]],[11,"shr","","",2,N],[11,"shr","","",2,N],[11,"shr_assign","","",2,[[["self"],["i8"]]]],[11,"shr_assign","","",2,[[["self"],["i8"]]]],[11,"shr","","",2,N],[11,"shr","","",2,N],[11,"shr_assign","","",2,[[["self"],["i16"]]]],[11,"shr_assign","","",2,[[["self"],["i16"]]]],[11,"shr","","",2,N],[11,"shr","","",2,N],[11,"shr_assign","","",2,[[["self"],["i32"]]]],[11,"shr_assign","","",2,[[["self"],["i32"]]]],[11,"shr","","",2,N],[11,"shr","","",2,N],[11,"shr_assign","","",2,[[["self"],["i64"]]]],[11,"shr_assign","","",2,[[["self"],["i64"]]]],[11,"shr","","",2,N],[11,"shr","","",2,N],[11,"shr_assign","","",2,[[["self"],["i128"]]]],[11,"shr_assign","","",2,[[["self"],["i128"]]]],[11,"shr","","",2,N],[11,"shr","","",2,N],[11,"shr_assign","","",2,[[["self"],["isize"]]]],[11,"shr_assign","","",2,[[["self"],["isize"]]]],[11,"from","","",2,[[["bool"]],["self"]]],[11,"from","","",2,[[["u8"]],["self"]]],[11,"from","","",2,[[["u8"]],["self"]]],[11,"from","","",2,[[["u16"]],["self"]]],[11,"from","","",2,[[["u16"]],["self"]]],[11,"from","","",2,[[["u32"]],["self"]]],[11,"from","","",2,[[["u32"]],["self"]]],[11,"from","","",2,[[["u64"]],["self"]]],[11,"from","","",2,[[["u64"]],["self"]]],[11,"from","","",2,[[["u128"]],["self"]]],[11,"from","","",2,[[["u128"]],["self"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"hash","","",2,[[["self"],["h"]]]],[11,"sum","","",2,[[["i"]],["self"]]],[11,"sum","","",2,[[["i"]],["self"]]],[11,"product","","",2,[[["i"]],["self"]]],[11,"product","","",2,[[["i"]],["self"]]],[11,"as_byte_slice_mut","","",2,N],[11,"to_le","","",2,[[["self"]]]],[11,"heap_size_of_children","","",2,[[["self"]],["usize"]]],[11,"serialize","","",2,[[["self"],["s"]],["result"]]],[11,"deserialize","","",2,[[["d"]],["result"]]],[11,"convert_into","","",3,N],[11,"convert_into","","",0,N],[11,"convert_into","","",3,N],[11,"convert_into","","",1,N],[11,"convert_into","","",3,N],[11,"convert_into","","",2,N],[11,"zero","","Create a new fixed uint and value is zero.",3,[[],["self"]]],[11,"one","","Create a new fixed uint and value is zero.",3,[[],["self"]]],[11,"is_zero","","Test if a fixed uint is zero.",3,[[["self"]],["bool"]]],[11,"is_max","","Test if a fixed uint is the max value.",3,[[["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",3,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",3,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",3,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",3,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",3,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",3,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",3,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",3,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",3,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",3,[[["self"]],["option",["usize"]]]],[11,"complete_mul","","Calculates the multiplication of `self` and `other`.",3,N],[11,"complete_div","","Calculates both the quotient and the remainder when `self` is divided by `other`.",3,N],[11,"gcd","","Calculates the Greatest Common Divisor (GCD).",3,[[["self"],["self"]],["self"]]],[11,"from_little_endian","","Convert from little-endian slice.",3,N],[11,"from_big_endian","","Convert from big-endian slice.",3,N],[11,"into_little_endian","","Convert into little-endian slice.",3,N],[11,"into_big_endian","","Convert into big-endian slice.",3,N],[11,"from_bin_str","","Convert from a binary string.",3,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_oct_str","","Convert from a octal string.",3,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_hex_str","","Convert from a hexadecimal string.",3,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_dec_str","","Convert from a decimal string.",3,[[["str"]],["result",["fixeduinterror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",3,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",3,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",3,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",3,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",3,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",3,[[["self"]],["u32"]]],[11,"checked_add","","Checked integer addition. Computes `self + rhs`, returning `None` if overflow occurred.",3,[[["self"],["self"]],["option"]]],[11,"checked_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",3,[[["self"],["self"]],["option"]]],[11,"checked_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",3,[[["self"],["self"]],["option"]]],[11,"checked_div","","Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`.",3,[[["self"],["self"]],["option"]]],[11,"checked_rem","","Checked integer remainder. Computes `self % rhs`, returning `None` if `rhs == 0`.",3,[[["self"],["self"]],["option"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",3,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",3,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",3,[[["self"]],["option"]]],[11,"saturating_add","","Saturating integer addition. Computes `self + rhs`, saturating at the numeric bounds instead of overflowing.",3,[[["self"],["self"]],["self"]]],[11,"saturating_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",3,[[["self"],["self"]],["self"]]],[11,"saturating_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",3,[[["self"],["self"]],["self"]]],[11,"overflowing_add","","Calculates `self + rhs`.",3,N],[11,"overflowing_sub","","Calculates `self - rhs`.",3,N],[11,"overflowing_mul","","Calculates the multiplication of `self` and `rhs`.",3,N],[11,"overflowing_div","","Calculates the divisor when `self` is divided by `rhs`.",3,N],[11,"overflowing_rem","","Calculates the remainder when `self` is divided by `rhs`.",3,N],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",3,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",3,N],[11,"overflowing_neg","","Negates `self` in an overflowing fashion.",3,N],[11,"random","","Create a random fixed uint with a input random core.",3,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",3,[[],["self"]]],[11,"clone","","",3,[[["self"]],["self"]]],[11,"default","","",3,[[],["self"]]],[11,"eq","","",3,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",3,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",3,[[["self"],["self"]],["ordering"]]],[11,"add","","",3,N],[11,"add_assign","","",3,[[["self"],["rhs"]]]],[11,"add","","",3,N],[11,"add_assign","","",3,[[["self"],["u256"]]]],[11,"sub","","",3,N],[11,"sub_assign","","",3,[[["self"],["rhs"]]]],[11,"sub","","",3,N],[11,"sub_assign","","",3,[[["self"],["u256"]]]],[11,"mul","","",3,N],[11,"mul_assign","","",3,[[["self"],["rhs"]]]],[11,"mul","","",3,N],[11,"mul_assign","","",3,[[["self"],["u256"]]]],[11,"div","","",3,N],[11,"div_assign","","",3,[[["self"],["rhs"]]]],[11,"div","","",3,N],[11,"div_assign","","",3,[[["self"],["u256"]]]],[11,"rem","","",3,N],[11,"rem_assign","","",3,[[["self"],["rhs"]]]],[11,"rem","","",3,N],[11,"rem_assign","","",3,[[["self"],["u256"]]]],[11,"bitand","","",3,N],[11,"bitand_assign","","",3,[[["self"],["rhs"]]]],[11,"bitand","","",3,N],[11,"bitand_assign","","",3,[[["self"],["u256"]]]],[11,"bitor","","",3,N],[11,"bitor_assign","","",3,[[["self"],["rhs"]]]],[11,"bitor","","",3,N],[11,"bitor_assign","","",3,[[["self"],["u256"]]]],[11,"bitxor","","",3,N],[11,"bitxor_assign","","",3,[[["self"],["rhs"]]]],[11,"bitxor","","",3,N],[11,"bitxor_assign","","",3,[[["self"],["u256"]]]],[11,"not","","",3,N],[11,"shl","","",3,N],[11,"shl","","",3,N],[11,"shl_assign","","",3,[[["self"],["u8"]]]],[11,"shl_assign","","",3,[[["self"],["u8"]]]],[11,"shl","","",3,N],[11,"shl","","",3,N],[11,"shl_assign","","",3,[[["self"],["u16"]]]],[11,"shl_assign","","",3,[[["self"],["u16"]]]],[11,"shl","","",3,N],[11,"shl","","",3,N],[11,"shl_assign","","",3,[[["self"],["u32"]]]],[11,"shl_assign","","",3,[[["self"],["u32"]]]],[11,"shl","","",3,N],[11,"shl","","",3,N],[11,"shl_assign","","",3,[[["self"],["u64"]]]],[11,"shl_assign","","",3,[[["self"],["u64"]]]],[11,"shl","","",3,N],[11,"shl","","",3,N],[11,"shl_assign","","",3,[[["self"],["u128"]]]],[11,"shl_assign","","",3,[[["self"],["u128"]]]],[11,"shl","","",3,N],[11,"shl","","",3,N],[11,"shl_assign","","",3,[[["self"],["usize"]]]],[11,"shl_assign","","",3,[[["self"],["usize"]]]],[11,"shl","","",3,N],[11,"shl","","",3,N],[11,"shl_assign","","",3,[[["self"],["i8"]]]],[11,"shl_assign","","",3,[[["self"],["i8"]]]],[11,"shl","","",3,N],[11,"shl","","",3,N],[11,"shl_assign","","",3,[[["self"],["i16"]]]],[11,"shl_assign","","",3,[[["self"],["i16"]]]],[11,"shl","","",3,N],[11,"shl","","",3,N],[11,"shl_assign","","",3,[[["self"],["i32"]]]],[11,"shl_assign","","",3,[[["self"],["i32"]]]],[11,"shl","","",3,N],[11,"shl","","",3,N],[11,"shl_assign","","",3,[[["self"],["i64"]]]],[11,"shl_assign","","",3,[[["self"],["i64"]]]],[11,"shl","","",3,N],[11,"shl","","",3,N],[11,"shl_assign","","",3,[[["self"],["i128"]]]],[11,"shl_assign","","",3,[[["self"],["i128"]]]],[11,"shl","","",3,N],[11,"shl","","",3,N],[11,"shl_assign","","",3,[[["self"],["isize"]]]],[11,"shl_assign","","",3,[[["self"],["isize"]]]],[11,"shr","","",3,N],[11,"shr","","",3,N],[11,"shr_assign","","",3,[[["self"],["u8"]]]],[11,"shr_assign","","",3,[[["self"],["u8"]]]],[11,"shr","","",3,N],[11,"shr","","",3,N],[11,"shr_assign","","",3,[[["self"],["u16"]]]],[11,"shr_assign","","",3,[[["self"],["u16"]]]],[11,"shr","","",3,N],[11,"shr","","",3,N],[11,"shr_assign","","",3,[[["self"],["u32"]]]],[11,"shr_assign","","",3,[[["self"],["u32"]]]],[11,"shr","","",3,N],[11,"shr","","",3,N],[11,"shr_assign","","",3,[[["self"],["u64"]]]],[11,"shr_assign","","",3,[[["self"],["u64"]]]],[11,"shr","","",3,N],[11,"shr","","",3,N],[11,"shr_assign","","",3,[[["self"],["u128"]]]],[11,"shr_assign","","",3,[[["self"],["u128"]]]],[11,"shr","","",3,N],[11,"shr","","",3,N],[11,"shr_assign","","",3,[[["self"],["usize"]]]],[11,"shr_assign","","",3,[[["self"],["usize"]]]],[11,"shr","","",3,N],[11,"shr","","",3,N],[11,"shr_assign","","",3,[[["self"],["i8"]]]],[11,"shr_assign","","",3,[[["self"],["i8"]]]],[11,"shr","","",3,N],[11,"shr","","",3,N],[11,"shr_assign","","",3,[[["self"],["i16"]]]],[11,"shr_assign","","",3,[[["self"],["i16"]]]],[11,"shr","","",3,N],[11,"shr","","",3,N],[11,"shr_assign","","",3,[[["self"],["i32"]]]],[11,"shr_assign","","",3,[[["self"],["i32"]]]],[11,"shr","","",3,N],[11,"shr","","",3,N],[11,"shr_assign","","",3,[[["self"],["i64"]]]],[11,"shr_assign","","",3,[[["self"],["i64"]]]],[11,"shr","","",3,N],[11,"shr","","",3,N],[11,"shr_assign","","",3,[[["self"],["i128"]]]],[11,"shr_assign","","",3,[[["self"],["i128"]]]],[11,"shr","","",3,N],[11,"shr","","",3,N],[11,"shr_assign","","",3,[[["self"],["isize"]]]],[11,"shr_assign","","",3,[[["self"],["isize"]]]],[11,"from","","",3,[[["bool"]],["self"]]],[11,"from","","",3,[[["u8"]],["self"]]],[11,"from","","",3,[[["u8"]],["self"]]],[11,"from","","",3,[[["u16"]],["self"]]],[11,"from","","",3,[[["u16"]],["self"]]],[11,"from","","",3,[[["u32"]],["self"]]],[11,"from","","",3,[[["u32"]],["self"]]],[11,"from","","",3,[[["u64"]],["self"]]],[11,"from","","",3,[[["u64"]],["self"]]],[11,"from","","",3,[[["u128"]],["self"]]],[11,"from","","",3,[[["u128"]],["self"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"hash","","",3,[[["self"],["h"]]]],[11,"sum","","",3,[[["i"]],["self"]]],[11,"sum","","",3,[[["i"]],["self"]]],[11,"product","","",3,[[["i"]],["self"]]],[11,"product","","",3,[[["i"]],["self"]]],[11,"as_byte_slice_mut","","",3,N],[11,"to_le","","",3,[[["self"]]]],[11,"heap_size_of_children","","",3,[[["self"]],["usize"]]],[11,"serialize","","",3,[[["self"],["s"]],["result"]]],[11,"deserialize","","",3,[[["d"]],["result"]]],[11,"convert_into","","",4,N],[11,"convert_into","","",0,N],[11,"convert_into","","",4,N],[11,"convert_into","","",1,N],[11,"convert_into","","",4,N],[11,"convert_into","","",2,N],[11,"convert_into","","",4,N],[11,"convert_into","","",3,N],[11,"zero","","Create a new fixed uint and value is zero.",4,[[],["self"]]],[11,"one","","Create a new fixed uint and value is zero.",4,[[],["self"]]],[11,"is_zero","","Test if a fixed uint is zero.",4,[[["self"]],["bool"]]],[11,"is_max","","Test if a fixed uint is the max value.",4,[[["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",4,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",4,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",4,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",4,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",4,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",4,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",4,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",4,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",4,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",4,[[["self"]],["option",["usize"]]]],[11,"complete_mul","","Calculates the multiplication of `self` and `other`.",4,N],[11,"complete_div","","Calculates both the quotient and the remainder when `self` is divided by `other`.",4,N],[11,"gcd","","Calculates the Greatest Common Divisor (GCD).",4,[[["self"],["self"]],["self"]]],[11,"from_little_endian","","Convert from little-endian slice.",4,N],[11,"from_big_endian","","Convert from big-endian slice.",4,N],[11,"into_little_endian","","Convert into little-endian slice.",4,N],[11,"into_big_endian","","Convert into big-endian slice.",4,N],[11,"from_bin_str","","Convert from a binary string.",4,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_oct_str","","Convert from a octal string.",4,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_hex_str","","Convert from a hexadecimal string.",4,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_dec_str","","Convert from a decimal string.",4,[[["str"]],["result",["fixeduinterror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",4,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",4,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",4,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",4,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",4,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",4,[[["self"]],["u32"]]],[11,"checked_add","","Checked integer addition. Computes `self + rhs`, returning `None` if overflow occurred.",4,[[["self"],["self"]],["option"]]],[11,"checked_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",4,[[["self"],["self"]],["option"]]],[11,"checked_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",4,[[["self"],["self"]],["option"]]],[11,"checked_div","","Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`.",4,[[["self"],["self"]],["option"]]],[11,"checked_rem","","Checked integer remainder. Computes `self % rhs`, returning `None` if `rhs == 0`.",4,[[["self"],["self"]],["option"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",4,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",4,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",4,[[["self"]],["option"]]],[11,"saturating_add","","Saturating integer addition. Computes `self + rhs`, saturating at the numeric bounds instead of overflowing.",4,[[["self"],["self"]],["self"]]],[11,"saturating_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",4,[[["self"],["self"]],["self"]]],[11,"saturating_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",4,[[["self"],["self"]],["self"]]],[11,"overflowing_add","","Calculates `self + rhs`.",4,N],[11,"overflowing_sub","","Calculates `self - rhs`.",4,N],[11,"overflowing_mul","","Calculates the multiplication of `self` and `rhs`.",4,N],[11,"overflowing_div","","Calculates the divisor when `self` is divided by `rhs`.",4,N],[11,"overflowing_rem","","Calculates the remainder when `self` is divided by `rhs`.",4,N],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",4,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",4,N],[11,"overflowing_neg","","Negates `self` in an overflowing fashion.",4,N],[11,"random","","Create a random fixed uint with a input random core.",4,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",4,[[],["self"]]],[11,"clone","","",4,[[["self"]],["self"]]],[11,"default","","",4,[[],["self"]]],[11,"eq","","",4,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",4,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",4,[[["self"],["self"]],["ordering"]]],[11,"add","","",4,N],[11,"add_assign","","",4,[[["self"],["rhs"]]]],[11,"add","","",4,N],[11,"add_assign","","",4,[[["self"],["u384"]]]],[11,"sub","","",4,N],[11,"sub_assign","","",4,[[["self"],["rhs"]]]],[11,"sub","","",4,N],[11,"sub_assign","","",4,[[["self"],["u384"]]]],[11,"mul","","",4,N],[11,"mul_assign","","",4,[[["self"],["rhs"]]]],[11,"mul","","",4,N],[11,"mul_assign","","",4,[[["self"],["u384"]]]],[11,"div","","",4,N],[11,"div_assign","","",4,[[["self"],["rhs"]]]],[11,"div","","",4,N],[11,"div_assign","","",4,[[["self"],["u384"]]]],[11,"rem","","",4,N],[11,"rem_assign","","",4,[[["self"],["rhs"]]]],[11,"rem","","",4,N],[11,"rem_assign","","",4,[[["self"],["u384"]]]],[11,"bitand","","",4,N],[11,"bitand_assign","","",4,[[["self"],["rhs"]]]],[11,"bitand","","",4,N],[11,"bitand_assign","","",4,[[["self"],["u384"]]]],[11,"bitor","","",4,N],[11,"bitor_assign","","",4,[[["self"],["rhs"]]]],[11,"bitor","","",4,N],[11,"bitor_assign","","",4,[[["self"],["u384"]]]],[11,"bitxor","","",4,N],[11,"bitxor_assign","","",4,[[["self"],["rhs"]]]],[11,"bitxor","","",4,N],[11,"bitxor_assign","","",4,[[["self"],["u384"]]]],[11,"not","","",4,N],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["u8"]]]],[11,"shl_assign","","",4,[[["self"],["u8"]]]],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["u16"]]]],[11,"shl_assign","","",4,[[["self"],["u16"]]]],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["u32"]]]],[11,"shl_assign","","",4,[[["self"],["u32"]]]],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["u64"]]]],[11,"shl_assign","","",4,[[["self"],["u64"]]]],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["u128"]]]],[11,"shl_assign","","",4,[[["self"],["u128"]]]],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["usize"]]]],[11,"shl_assign","","",4,[[["self"],["usize"]]]],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["i8"]]]],[11,"shl_assign","","",4,[[["self"],["i8"]]]],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["i16"]]]],[11,"shl_assign","","",4,[[["self"],["i16"]]]],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["i32"]]]],[11,"shl_assign","","",4,[[["self"],["i32"]]]],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["i64"]]]],[11,"shl_assign","","",4,[[["self"],["i64"]]]],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["i128"]]]],[11,"shl_assign","","",4,[[["self"],["i128"]]]],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["isize"]]]],[11,"shl_assign","","",4,[[["self"],["isize"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["u8"]]]],[11,"shr_assign","","",4,[[["self"],["u8"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["u16"]]]],[11,"shr_assign","","",4,[[["self"],["u16"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["u32"]]]],[11,"shr_assign","","",4,[[["self"],["u32"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["u64"]]]],[11,"shr_assign","","",4,[[["self"],["u64"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["u128"]]]],[11,"shr_assign","","",4,[[["self"],["u128"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["usize"]]]],[11,"shr_assign","","",4,[[["self"],["usize"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["i8"]]]],[11,"shr_assign","","",4,[[["self"],["i8"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["i16"]]]],[11,"shr_assign","","",4,[[["self"],["i16"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["i32"]]]],[11,"shr_assign","","",4,[[["self"],["i32"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["i64"]]]],[11,"shr_assign","","",4,[[["self"],["i64"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["i128"]]]],[11,"shr_assign","","",4,[[["self"],["i128"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["isize"]]]],[11,"shr_assign","","",4,[[["self"],["isize"]]]],[11,"from","","",4,[[["bool"]],["self"]]],[11,"from","","",4,[[["u8"]],["self"]]],[11,"from","","",4,[[["u8"]],["self"]]],[11,"from","","",4,[[["u16"]],["self"]]],[11,"from","","",4,[[["u16"]],["self"]]],[11,"from","","",4,[[["u32"]],["self"]]],[11,"from","","",4,[[["u32"]],["self"]]],[11,"from","","",4,[[["u64"]],["self"]]],[11,"from","","",4,[[["u64"]],["self"]]],[11,"from","","",4,[[["u128"]],["self"]]],[11,"from","","",4,[[["u128"]],["self"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"hash","","",4,[[["self"],["h"]]]],[11,"sum","","",4,[[["i"]],["self"]]],[11,"sum","","",4,[[["i"]],["self"]]],[11,"product","","",4,[[["i"]],["self"]]],[11,"product","","",4,[[["i"]],["self"]]],[11,"as_byte_slice_mut","","",4,N],[11,"to_le","","",4,[[["self"]]]],[11,"heap_size_of_children","","",4,[[["self"]],["usize"]]],[11,"serialize","","",4,[[["self"],["s"]],["result"]]],[11,"deserialize","","",4,[[["d"]],["result"]]],[11,"convert_into","","",5,N],[11,"convert_into","","",0,N],[11,"convert_into","","",5,N],[11,"convert_into","","",1,N],[11,"convert_into","","",5,N],[11,"convert_into","","",2,N],[11,"convert_into","","",5,N],[11,"convert_into","","",3,N],[11,"convert_into","","",5,N],[11,"convert_into","","",4,N],[11,"zero","","Create a new fixed uint and value is zero.",5,[[],["self"]]],[11,"one","","Create a new fixed uint and value is zero.",5,[[],["self"]]],[11,"is_zero","","Test if a fixed uint is zero.",5,[[["self"]],["bool"]]],[11,"is_max","","Test if a fixed uint is the max value.",5,[[["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",5,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",5,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",5,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",5,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",5,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",5,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",5,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",5,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",5,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",5,[[["self"]],["option",["usize"]]]],[11,"complete_mul","","Calculates the multiplication of `self` and `other`.",5,N],[11,"complete_div","","Calculates both the quotient and the remainder when `self` is divided by `other`.",5,N],[11,"gcd","","Calculates the Greatest Common Divisor (GCD).",5,[[["self"],["self"]],["self"]]],[11,"from_little_endian","","Convert from little-endian slice.",5,N],[11,"from_big_endian","","Convert from big-endian slice.",5,N],[11,"into_little_endian","","Convert into little-endian slice.",5,N],[11,"into_big_endian","","Convert into big-endian slice.",5,N],[11,"from_bin_str","","Convert from a binary string.",5,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_oct_str","","Convert from a octal string.",5,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_hex_str","","Convert from a hexadecimal string.",5,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_dec_str","","Convert from a decimal string.",5,[[["str"]],["result",["fixeduinterror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",5,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",5,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",5,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",5,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",5,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",5,[[["self"]],["u32"]]],[11,"checked_add","","Checked integer addition. Computes `self + rhs`, returning `None` if overflow occurred.",5,[[["self"],["self"]],["option"]]],[11,"checked_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",5,[[["self"],["self"]],["option"]]],[11,"checked_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",5,[[["self"],["self"]],["option"]]],[11,"checked_div","","Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`.",5,[[["self"],["self"]],["option"]]],[11,"checked_rem","","Checked integer remainder. Computes `self % rhs`, returning `None` if `rhs == 0`.",5,[[["self"],["self"]],["option"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",5,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",5,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",5,[[["self"]],["option"]]],[11,"saturating_add","","Saturating integer addition. Computes `self + rhs`, saturating at the numeric bounds instead of overflowing.",5,[[["self"],["self"]],["self"]]],[11,"saturating_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",5,[[["self"],["self"]],["self"]]],[11,"saturating_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",5,[[["self"],["self"]],["self"]]],[11,"overflowing_add","","Calculates `self + rhs`.",5,N],[11,"overflowing_sub","","Calculates `self - rhs`.",5,N],[11,"overflowing_mul","","Calculates the multiplication of `self` and `rhs`.",5,N],[11,"overflowing_div","","Calculates the divisor when `self` is divided by `rhs`.",5,N],[11,"overflowing_rem","","Calculates the remainder when `self` is divided by `rhs`.",5,N],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",5,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",5,N],[11,"overflowing_neg","","Negates `self` in an overflowing fashion.",5,N],[11,"random","","Create a random fixed uint with a input random core.",5,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",5,[[],["self"]]],[11,"clone","","",5,[[["self"]],["self"]]],[11,"default","","",5,[[],["self"]]],[11,"eq","","",5,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",5,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",5,[[["self"],["self"]],["ordering"]]],[11,"add","","",5,N],[11,"add_assign","","",5,[[["self"],["rhs"]]]],[11,"add","","",5,N],[11,"add_assign","","",5,[[["self"],["u512"]]]],[11,"sub","","",5,N],[11,"sub_assign","","",5,[[["self"],["rhs"]]]],[11,"sub","","",5,N],[11,"sub_assign","","",5,[[["self"],["u512"]]]],[11,"mul","","",5,N],[11,"mul_assign","","",5,[[["self"],["rhs"]]]],[11,"mul","","",5,N],[11,"mul_assign","","",5,[[["self"],["u512"]]]],[11,"div","","",5,N],[11,"div_assign","","",5,[[["self"],["rhs"]]]],[11,"div","","",5,N],[11,"div_assign","","",5,[[["self"],["u512"]]]],[11,"rem","","",5,N],[11,"rem_assign","","",5,[[["self"],["rhs"]]]],[11,"rem","","",5,N],[11,"rem_assign","","",5,[[["self"],["u512"]]]],[11,"bitand","","",5,N],[11,"bitand_assign","","",5,[[["self"],["rhs"]]]],[11,"bitand","","",5,N],[11,"bitand_assign","","",5,[[["self"],["u512"]]]],[11,"bitor","","",5,N],[11,"bitor_assign","","",5,[[["self"],["rhs"]]]],[11,"bitor","","",5,N],[11,"bitor_assign","","",5,[[["self"],["u512"]]]],[11,"bitxor","","",5,N],[11,"bitxor_assign","","",5,[[["self"],["rhs"]]]],[11,"bitxor","","",5,N],[11,"bitxor_assign","","",5,[[["self"],["u512"]]]],[11,"not","","",5,N],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["u8"]]]],[11,"shl_assign","","",5,[[["self"],["u8"]]]],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["u16"]]]],[11,"shl_assign","","",5,[[["self"],["u16"]]]],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["u32"]]]],[11,"shl_assign","","",5,[[["self"],["u32"]]]],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["u64"]]]],[11,"shl_assign","","",5,[[["self"],["u64"]]]],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["u128"]]]],[11,"shl_assign","","",5,[[["self"],["u128"]]]],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["usize"]]]],[11,"shl_assign","","",5,[[["self"],["usize"]]]],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["i8"]]]],[11,"shl_assign","","",5,[[["self"],["i8"]]]],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["i16"]]]],[11,"shl_assign","","",5,[[["self"],["i16"]]]],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["i32"]]]],[11,"shl_assign","","",5,[[["self"],["i32"]]]],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["i64"]]]],[11,"shl_assign","","",5,[[["self"],["i64"]]]],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["i128"]]]],[11,"shl_assign","","",5,[[["self"],["i128"]]]],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["isize"]]]],[11,"shl_assign","","",5,[[["self"],["isize"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["u8"]]]],[11,"shr_assign","","",5,[[["self"],["u8"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["u16"]]]],[11,"shr_assign","","",5,[[["self"],["u16"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["u32"]]]],[11,"shr_assign","","",5,[[["self"],["u32"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["u64"]]]],[11,"shr_assign","","",5,[[["self"],["u64"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["u128"]]]],[11,"shr_assign","","",5,[[["self"],["u128"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["usize"]]]],[11,"shr_assign","","",5,[[["self"],["usize"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["i8"]]]],[11,"shr_assign","","",5,[[["self"],["i8"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["i16"]]]],[11,"shr_assign","","",5,[[["self"],["i16"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["i32"]]]],[11,"shr_assign","","",5,[[["self"],["i32"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["i64"]]]],[11,"shr_assign","","",5,[[["self"],["i64"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["i128"]]]],[11,"shr_assign","","",5,[[["self"],["i128"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["isize"]]]],[11,"shr_assign","","",5,[[["self"],["isize"]]]],[11,"from","","",5,[[["bool"]],["self"]]],[11,"from","","",5,[[["u8"]],["self"]]],[11,"from","","",5,[[["u8"]],["self"]]],[11,"from","","",5,[[["u16"]],["self"]]],[11,"from","","",5,[[["u16"]],["self"]]],[11,"from","","",5,[[["u32"]],["self"]]],[11,"from","","",5,[[["u32"]],["self"]]],[11,"from","","",5,[[["u64"]],["self"]]],[11,"from","","",5,[[["u64"]],["self"]]],[11,"from","","",5,[[["u128"]],["self"]]],[11,"from","","",5,[[["u128"]],["self"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"hash","","",5,[[["self"],["h"]]]],[11,"sum","","",5,[[["i"]],["self"]]],[11,"sum","","",5,[[["i"]],["self"]]],[11,"product","","",5,[[["i"]],["self"]]],[11,"product","","",5,[[["i"]],["self"]]],[11,"as_byte_slice_mut","","",5,N],[11,"to_le","","",5,[[["self"]]]],[11,"heap_size_of_children","","",5,[[["self"]],["usize"]]],[11,"serialize","","",5,[[["self"],["s"]],["result"]]],[11,"deserialize","","",5,[[["d"]],["result"]]],[11,"convert_into","","",6,N],[11,"convert_into","","",0,N],[11,"convert_into","","",6,N],[11,"convert_into","","",1,N],[11,"convert_into","","",6,N],[11,"convert_into","","",2,N],[11,"convert_into","","",6,N],[11,"convert_into","","",3,N],[11,"convert_into","","",6,N],[11,"convert_into","","",4,N],[11,"convert_into","","",6,N],[11,"convert_into","","",5,N],[11,"zero","","Create a new fixed uint and value is zero.",6,[[],["self"]]],[11,"one","","Create a new fixed uint and value is zero.",6,[[],["self"]]],[11,"is_zero","","Test if a fixed uint is zero.",6,[[["self"]],["bool"]]],[11,"is_max","","Test if a fixed uint is the max value.",6,[[["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",6,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",6,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",6,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",6,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",6,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",6,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",6,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",6,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",6,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",6,[[["self"]],["option",["usize"]]]],[11,"complete_mul","","Calculates the multiplication of `self` and `other`.",6,N],[11,"complete_div","","Calculates both the quotient and the remainder when `self` is divided by `other`.",6,N],[11,"gcd","","Calculates the Greatest Common Divisor (GCD).",6,[[["self"],["self"]],["self"]]],[11,"from_little_endian","","Convert from little-endian slice.",6,N],[11,"from_big_endian","","Convert from big-endian slice.",6,N],[11,"into_little_endian","","Convert into little-endian slice.",6,N],[11,"into_big_endian","","Convert into big-endian slice.",6,N],[11,"from_bin_str","","Convert from a binary string.",6,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_oct_str","","Convert from a octal string.",6,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_hex_str","","Convert from a hexadecimal string.",6,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_dec_str","","Convert from a decimal string.",6,[[["str"]],["result",["fixeduinterror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",6,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",6,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",6,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",6,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",6,[[["self"]],["u32"]]],[11,"checked_add","","Checked integer addition. Computes `self + rhs`, returning `None` if overflow occurred.",6,[[["self"],["self"]],["option"]]],[11,"checked_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",6,[[["self"],["self"]],["option"]]],[11,"checked_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",6,[[["self"],["self"]],["option"]]],[11,"checked_div","","Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`.",6,[[["self"],["self"]],["option"]]],[11,"checked_rem","","Checked integer remainder. Computes `self % rhs`, returning `None` if `rhs == 0`.",6,[[["self"],["self"]],["option"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",6,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",6,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",6,[[["self"]],["option"]]],[11,"saturating_add","","Saturating integer addition. Computes `self + rhs`, saturating at the numeric bounds instead of overflowing.",6,[[["self"],["self"]],["self"]]],[11,"saturating_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",6,[[["self"],["self"]],["self"]]],[11,"saturating_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",6,[[["self"],["self"]],["self"]]],[11,"overflowing_add","","Calculates `self + rhs`.",6,N],[11,"overflowing_sub","","Calculates `self - rhs`.",6,N],[11,"overflowing_mul","","Calculates the multiplication of `self` and `rhs`.",6,N],[11,"overflowing_div","","Calculates the divisor when `self` is divided by `rhs`.",6,N],[11,"overflowing_rem","","Calculates the remainder when `self` is divided by `rhs`.",6,N],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",6,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",6,N],[11,"overflowing_neg","","Negates `self` in an overflowing fashion.",6,N],[11,"random","","Create a random fixed uint with a input random core.",6,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",6,[[],["self"]]],[11,"clone","","",6,[[["self"]],["self"]]],[11,"default","","",6,[[],["self"]]],[11,"eq","","",6,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",6,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",6,[[["self"],["self"]],["ordering"]]],[11,"add","","",6,N],[11,"add_assign","","",6,[[["self"],["rhs"]]]],[11,"add","","",6,N],[11,"add_assign","","",6,[[["self"],["u520"]]]],[11,"sub","","",6,N],[11,"sub_assign","","",6,[[["self"],["rhs"]]]],[11,"sub","","",6,N],[11,"sub_assign","","",6,[[["self"],["u520"]]]],[11,"mul","","",6,N],[11,"mul_assign","","",6,[[["self"],["rhs"]]]],[11,"mul","","",6,N],[11,"mul_assign","","",6,[[["self"],["u520"]]]],[11,"div","","",6,N],[11,"div_assign","","",6,[[["self"],["rhs"]]]],[11,"div","","",6,N],[11,"div_assign","","",6,[[["self"],["u520"]]]],[11,"rem","","",6,N],[11,"rem_assign","","",6,[[["self"],["rhs"]]]],[11,"rem","","",6,N],[11,"rem_assign","","",6,[[["self"],["u520"]]]],[11,"bitand","","",6,N],[11,"bitand_assign","","",6,[[["self"],["rhs"]]]],[11,"bitand","","",6,N],[11,"bitand_assign","","",6,[[["self"],["u520"]]]],[11,"bitor","","",6,N],[11,"bitor_assign","","",6,[[["self"],["rhs"]]]],[11,"bitor","","",6,N],[11,"bitor_assign","","",6,[[["self"],["u520"]]]],[11,"bitxor","","",6,N],[11,"bitxor_assign","","",6,[[["self"],["rhs"]]]],[11,"bitxor","","",6,N],[11,"bitxor_assign","","",6,[[["self"],["u520"]]]],[11,"not","","",6,N],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["u8"]]]],[11,"shl_assign","","",6,[[["self"],["u8"]]]],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["u16"]]]],[11,"shl_assign","","",6,[[["self"],["u16"]]]],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["u32"]]]],[11,"shl_assign","","",6,[[["self"],["u32"]]]],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["u64"]]]],[11,"shl_assign","","",6,[[["self"],["u64"]]]],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["u128"]]]],[11,"shl_assign","","",6,[[["self"],["u128"]]]],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["usize"]]]],[11,"shl_assign","","",6,[[["self"],["usize"]]]],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["i8"]]]],[11,"shl_assign","","",6,[[["self"],["i8"]]]],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["i16"]]]],[11,"shl_assign","","",6,[[["self"],["i16"]]]],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["i32"]]]],[11,"shl_assign","","",6,[[["self"],["i32"]]]],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["i64"]]]],[11,"shl_assign","","",6,[[["self"],["i64"]]]],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["i128"]]]],[11,"shl_assign","","",6,[[["self"],["i128"]]]],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["isize"]]]],[11,"shl_assign","","",6,[[["self"],["isize"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["u8"]]]],[11,"shr_assign","","",6,[[["self"],["u8"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["u16"]]]],[11,"shr_assign","","",6,[[["self"],["u16"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["u32"]]]],[11,"shr_assign","","",6,[[["self"],["u32"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["u64"]]]],[11,"shr_assign","","",6,[[["self"],["u64"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["u128"]]]],[11,"shr_assign","","",6,[[["self"],["u128"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["usize"]]]],[11,"shr_assign","","",6,[[["self"],["usize"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["i8"]]]],[11,"shr_assign","","",6,[[["self"],["i8"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["i16"]]]],[11,"shr_assign","","",6,[[["self"],["i16"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["i32"]]]],[11,"shr_assign","","",6,[[["self"],["i32"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["i64"]]]],[11,"shr_assign","","",6,[[["self"],["i64"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["i128"]]]],[11,"shr_assign","","",6,[[["self"],["i128"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["isize"]]]],[11,"shr_assign","","",6,[[["self"],["isize"]]]],[11,"from","","",6,[[["bool"]],["self"]]],[11,"from","","",6,[[["u8"]],["self"]]],[11,"from","","",6,[[["u8"]],["self"]]],[11,"from","","",6,[[["u16"]],["self"]]],[11,"from","","",6,[[["u16"]],["self"]]],[11,"from","","",6,[[["u32"]],["self"]]],[11,"from","","",6,[[["u32"]],["self"]]],[11,"from","","",6,[[["u64"]],["self"]]],[11,"from","","",6,[[["u64"]],["self"]]],[11,"from","","",6,[[["u128"]],["self"]]],[11,"from","","",6,[[["u128"]],["self"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"hash","","",6,[[["self"],["h"]]]],[11,"sum","","",6,[[["i"]],["self"]]],[11,"sum","","",6,[[["i"]],["self"]]],[11,"product","","",6,[[["i"]],["self"]]],[11,"product","","",6,[[["i"]],["self"]]],[11,"as_byte_slice_mut","","",6,N],[11,"to_le","","",6,[[["self"]]]],[11,"heap_size_of_children","","",6,[[["self"]],["usize"]]],[11,"serialize","","",6,[[["self"],["s"]],["result"]]],[11,"deserialize","","",6,[[["d"]],["result"]]],[11,"convert_into","","",7,N],[11,"convert_into","","",0,N],[11,"convert_into","","",7,N],[11,"convert_into","","",1,N],[11,"convert_into","","",7,N],[11,"convert_into","","",2,N],[11,"convert_into","","",7,N],[11,"convert_into","","",3,N],[11,"convert_into","","",7,N],[11,"convert_into","","",4,N],[11,"convert_into","","",7,N],[11,"convert_into","","",5,N],[11,"convert_into","","",7,N],[11,"convert_into","","",6,N],[11,"zero","","Create a new fixed uint and value is zero.",7,[[],["self"]]],[11,"one","","Create a new fixed uint and value is zero.",7,[[],["self"]]],[11,"is_zero","","Test if a fixed uint is zero.",7,[[["self"]],["bool"]]],[11,"is_max","","Test if a fixed uint is the max value.",7,[[["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",7,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",7,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",7,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",7,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",7,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",7,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",7,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",7,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",7,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",7,[[["self"]],["option",["usize"]]]],[11,"complete_mul","","Calculates the multiplication of `self` and `other`.",7,N],[11,"complete_div","","Calculates both the quotient and the remainder when `self` is divided by `other`.",7,N],[11,"gcd","","Calculates the Greatest Common Divisor (GCD).",7,[[["self"],["self"]],["self"]]],[11,"from_little_endian","","Convert from little-endian slice.",7,N],[11,"from_big_endian","","Convert from big-endian slice.",7,N],[11,"into_little_endian","","Convert into little-endian slice.",7,N],[11,"into_big_endian","","Convert into big-endian slice.",7,N],[11,"from_bin_str","","Convert from a binary string.",7,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_oct_str","","Convert from a octal string.",7,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_hex_str","","Convert from a hexadecimal string.",7,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_dec_str","","Convert from a decimal string.",7,[[["str"]],["result",["fixeduinterror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",7,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",7,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",7,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",7,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",7,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",7,[[["self"]],["u32"]]],[11,"checked_add","","Checked integer addition. Computes `self + rhs`, returning `None` if overflow occurred.",7,[[["self"],["self"]],["option"]]],[11,"checked_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",7,[[["self"],["self"]],["option"]]],[11,"checked_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",7,[[["self"],["self"]],["option"]]],[11,"checked_div","","Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`.",7,[[["self"],["self"]],["option"]]],[11,"checked_rem","","Checked integer remainder. Computes `self % rhs`, returning `None` if `rhs == 0`.",7,[[["self"],["self"]],["option"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",7,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",7,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",7,[[["self"]],["option"]]],[11,"saturating_add","","Saturating integer addition. Computes `self + rhs`, saturating at the numeric bounds instead of overflowing.",7,[[["self"],["self"]],["self"]]],[11,"saturating_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",7,[[["self"],["self"]],["self"]]],[11,"saturating_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",7,[[["self"],["self"]],["self"]]],[11,"overflowing_add","","Calculates `self + rhs`.",7,N],[11,"overflowing_sub","","Calculates `self - rhs`.",7,N],[11,"overflowing_mul","","Calculates the multiplication of `self` and `rhs`.",7,N],[11,"overflowing_div","","Calculates the divisor when `self` is divided by `rhs`.",7,N],[11,"overflowing_rem","","Calculates the remainder when `self` is divided by `rhs`.",7,N],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",7,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",7,N],[11,"overflowing_neg","","Negates `self` in an overflowing fashion.",7,N],[11,"random","","Create a random fixed uint with a input random core.",7,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",7,[[],["self"]]],[11,"clone","","",7,[[["self"]],["self"]]],[11,"default","","",7,[[],["self"]]],[11,"eq","","",7,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",7,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",7,[[["self"],["self"]],["ordering"]]],[11,"add","","",7,N],[11,"add_assign","","",7,[[["self"],["rhs"]]]],[11,"add","","",7,N],[11,"add_assign","","",7,[[["self"],["u1024"]]]],[11,"sub","","",7,N],[11,"sub_assign","","",7,[[["self"],["rhs"]]]],[11,"sub","","",7,N],[11,"sub_assign","","",7,[[["self"],["u1024"]]]],[11,"mul","","",7,N],[11,"mul_assign","","",7,[[["self"],["rhs"]]]],[11,"mul","","",7,N],[11,"mul_assign","","",7,[[["self"],["u1024"]]]],[11,"div","","",7,N],[11,"div_assign","","",7,[[["self"],["rhs"]]]],[11,"div","","",7,N],[11,"div_assign","","",7,[[["self"],["u1024"]]]],[11,"rem","","",7,N],[11,"rem_assign","","",7,[[["self"],["rhs"]]]],[11,"rem","","",7,N],[11,"rem_assign","","",7,[[["self"],["u1024"]]]],[11,"bitand","","",7,N],[11,"bitand_assign","","",7,[[["self"],["rhs"]]]],[11,"bitand","","",7,N],[11,"bitand_assign","","",7,[[["self"],["u1024"]]]],[11,"bitor","","",7,N],[11,"bitor_assign","","",7,[[["self"],["rhs"]]]],[11,"bitor","","",7,N],[11,"bitor_assign","","",7,[[["self"],["u1024"]]]],[11,"bitxor","","",7,N],[11,"bitxor_assign","","",7,[[["self"],["rhs"]]]],[11,"bitxor","","",7,N],[11,"bitxor_assign","","",7,[[["self"],["u1024"]]]],[11,"not","","",7,N],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["u8"]]]],[11,"shl_assign","","",7,[[["self"],["u8"]]]],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["u16"]]]],[11,"shl_assign","","",7,[[["self"],["u16"]]]],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["u32"]]]],[11,"shl_assign","","",7,[[["self"],["u32"]]]],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["u64"]]]],[11,"shl_assign","","",7,[[["self"],["u64"]]]],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["u128"]]]],[11,"shl_assign","","",7,[[["self"],["u128"]]]],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["usize"]]]],[11,"shl_assign","","",7,[[["self"],["usize"]]]],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["i8"]]]],[11,"shl_assign","","",7,[[["self"],["i8"]]]],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["i16"]]]],[11,"shl_assign","","",7,[[["self"],["i16"]]]],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["i32"]]]],[11,"shl_assign","","",7,[[["self"],["i32"]]]],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["i64"]]]],[11,"shl_assign","","",7,[[["self"],["i64"]]]],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["i128"]]]],[11,"shl_assign","","",7,[[["self"],["i128"]]]],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["isize"]]]],[11,"shl_assign","","",7,[[["self"],["isize"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["u8"]]]],[11,"shr_assign","","",7,[[["self"],["u8"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["u16"]]]],[11,"shr_assign","","",7,[[["self"],["u16"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["u32"]]]],[11,"shr_assign","","",7,[[["self"],["u32"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["u64"]]]],[11,"shr_assign","","",7,[[["self"],["u64"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["u128"]]]],[11,"shr_assign","","",7,[[["self"],["u128"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["usize"]]]],[11,"shr_assign","","",7,[[["self"],["usize"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["i8"]]]],[11,"shr_assign","","",7,[[["self"],["i8"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["i16"]]]],[11,"shr_assign","","",7,[[["self"],["i16"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["i32"]]]],[11,"shr_assign","","",7,[[["self"],["i32"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["i64"]]]],[11,"shr_assign","","",7,[[["self"],["i64"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["i128"]]]],[11,"shr_assign","","",7,[[["self"],["i128"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["isize"]]]],[11,"shr_assign","","",7,[[["self"],["isize"]]]],[11,"from","","",7,[[["bool"]],["self"]]],[11,"from","","",7,[[["u8"]],["self"]]],[11,"from","","",7,[[["u8"]],["self"]]],[11,"from","","",7,[[["u16"]],["self"]]],[11,"from","","",7,[[["u16"]],["self"]]],[11,"from","","",7,[[["u32"]],["self"]]],[11,"from","","",7,[[["u32"]],["self"]]],[11,"from","","",7,[[["u64"]],["self"]]],[11,"from","","",7,[[["u64"]],["self"]]],[11,"from","","",7,[[["u128"]],["self"]]],[11,"from","","",7,[[["u128"]],["self"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"hash","","",7,[[["self"],["h"]]]],[11,"sum","","",7,[[["i"]],["self"]]],[11,"sum","","",7,[[["i"]],["self"]]],[11,"product","","",7,[[["i"]],["self"]]],[11,"product","","",7,[[["i"]],["self"]]],[11,"as_byte_slice_mut","","",7,N],[11,"to_le","","",7,[[["self"]]]],[11,"heap_size_of_children","","",7,[[["self"]],["usize"]]],[11,"serialize","","",7,[[["self"],["s"]],["result"]]],[11,"deserialize","","",7,[[["d"]],["result"]]],[11,"convert_into","","",8,N],[11,"convert_into","","",0,N],[11,"convert_into","","",8,N],[11,"convert_into","","",1,N],[11,"convert_into","","",8,N],[11,"convert_into","","",2,N],[11,"convert_into","","",8,N],[11,"convert_into","","",3,N],[11,"convert_into","","",8,N],[11,"convert_into","","",4,N],[11,"convert_into","","",8,N],[11,"convert_into","","",5,N],[11,"convert_into","","",8,N],[11,"convert_into","","",6,N],[11,"convert_into","","",8,N],[11,"convert_into","","",7,N],[11,"zero","","Create a new fixed uint and value is zero.",8,[[],["self"]]],[11,"one","","Create a new fixed uint and value is zero.",8,[[],["self"]]],[11,"is_zero","","Test if a fixed uint is zero.",8,[[["self"]],["bool"]]],[11,"is_max","","Test if a fixed uint is the max value.",8,[[["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",8,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",8,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",8,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",8,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",8,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",8,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",8,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",8,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",8,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",8,[[["self"]],["option",["usize"]]]],[11,"complete_mul","","Calculates the multiplication of `self` and `other`.",8,N],[11,"complete_div","","Calculates both the quotient and the remainder when `self` is divided by `other`.",8,N],[11,"gcd","","Calculates the Greatest Common Divisor (GCD).",8,[[["self"],["self"]],["self"]]],[11,"from_little_endian","","Convert from little-endian slice.",8,N],[11,"from_big_endian","","Convert from big-endian slice.",8,N],[11,"into_little_endian","","Convert into little-endian slice.",8,N],[11,"into_big_endian","","Convert into big-endian slice.",8,N],[11,"from_bin_str","","Convert from a binary string.",8,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_oct_str","","Convert from a octal string.",8,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_hex_str","","Convert from a hexadecimal string.",8,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_dec_str","","Convert from a decimal string.",8,[[["str"]],["result",["fixeduinterror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",8,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",8,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",8,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",8,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",8,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",8,[[["self"]],["u32"]]],[11,"checked_add","","Checked integer addition. Computes `self + rhs`, returning `None` if overflow occurred.",8,[[["self"],["self"]],["option"]]],[11,"checked_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",8,[[["self"],["self"]],["option"]]],[11,"checked_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",8,[[["self"],["self"]],["option"]]],[11,"checked_div","","Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`.",8,[[["self"],["self"]],["option"]]],[11,"checked_rem","","Checked integer remainder. Computes `self % rhs`, returning `None` if `rhs == 0`.",8,[[["self"],["self"]],["option"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",8,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",8,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",8,[[["self"]],["option"]]],[11,"saturating_add","","Saturating integer addition. Computes `self + rhs`, saturating at the numeric bounds instead of overflowing.",8,[[["self"],["self"]],["self"]]],[11,"saturating_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",8,[[["self"],["self"]],["self"]]],[11,"saturating_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",8,[[["self"],["self"]],["self"]]],[11,"overflowing_add","","Calculates `self + rhs`.",8,N],[11,"overflowing_sub","","Calculates `self - rhs`.",8,N],[11,"overflowing_mul","","Calculates the multiplication of `self` and `rhs`.",8,N],[11,"overflowing_div","","Calculates the divisor when `self` is divided by `rhs`.",8,N],[11,"overflowing_rem","","Calculates the remainder when `self` is divided by `rhs`.",8,N],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",8,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",8,N],[11,"overflowing_neg","","Negates `self` in an overflowing fashion.",8,N],[11,"random","","Create a random fixed uint with a input random core.",8,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",8,[[],["self"]]],[11,"clone","","",8,[[["self"]],["self"]]],[11,"default","","",8,[[],["self"]]],[11,"eq","","",8,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",8,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",8,[[["self"],["self"]],["ordering"]]],[11,"add","","",8,N],[11,"add_assign","","",8,[[["self"],["rhs"]]]],[11,"add","","",8,N],[11,"add_assign","","",8,[[["self"],["u2048"]]]],[11,"sub","","",8,N],[11,"sub_assign","","",8,[[["self"],["rhs"]]]],[11,"sub","","",8,N],[11,"sub_assign","","",8,[[["self"],["u2048"]]]],[11,"mul","","",8,N],[11,"mul_assign","","",8,[[["self"],["rhs"]]]],[11,"mul","","",8,N],[11,"mul_assign","","",8,[[["self"],["u2048"]]]],[11,"div","","",8,N],[11,"div_assign","","",8,[[["self"],["rhs"]]]],[11,"div","","",8,N],[11,"div_assign","","",8,[[["self"],["u2048"]]]],[11,"rem","","",8,N],[11,"rem_assign","","",8,[[["self"],["rhs"]]]],[11,"rem","","",8,N],[11,"rem_assign","","",8,[[["self"],["u2048"]]]],[11,"bitand","","",8,N],[11,"bitand_assign","","",8,[[["self"],["rhs"]]]],[11,"bitand","","",8,N],[11,"bitand_assign","","",8,[[["self"],["u2048"]]]],[11,"bitor","","",8,N],[11,"bitor_assign","","",8,[[["self"],["rhs"]]]],[11,"bitor","","",8,N],[11,"bitor_assign","","",8,[[["self"],["u2048"]]]],[11,"bitxor","","",8,N],[11,"bitxor_assign","","",8,[[["self"],["rhs"]]]],[11,"bitxor","","",8,N],[11,"bitxor_assign","","",8,[[["self"],["u2048"]]]],[11,"not","","",8,N],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["u8"]]]],[11,"shl_assign","","",8,[[["self"],["u8"]]]],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["u16"]]]],[11,"shl_assign","","",8,[[["self"],["u16"]]]],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["u32"]]]],[11,"shl_assign","","",8,[[["self"],["u32"]]]],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["u64"]]]],[11,"shl_assign","","",8,[[["self"],["u64"]]]],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["u128"]]]],[11,"shl_assign","","",8,[[["self"],["u128"]]]],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["usize"]]]],[11,"shl_assign","","",8,[[["self"],["usize"]]]],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["i8"]]]],[11,"shl_assign","","",8,[[["self"],["i8"]]]],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["i16"]]]],[11,"shl_assign","","",8,[[["self"],["i16"]]]],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["i32"]]]],[11,"shl_assign","","",8,[[["self"],["i32"]]]],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["i64"]]]],[11,"shl_assign","","",8,[[["self"],["i64"]]]],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["i128"]]]],[11,"shl_assign","","",8,[[["self"],["i128"]]]],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["isize"]]]],[11,"shl_assign","","",8,[[["self"],["isize"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["u8"]]]],[11,"shr_assign","","",8,[[["self"],["u8"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["u16"]]]],[11,"shr_assign","","",8,[[["self"],["u16"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["u32"]]]],[11,"shr_assign","","",8,[[["self"],["u32"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["u64"]]]],[11,"shr_assign","","",8,[[["self"],["u64"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["u128"]]]],[11,"shr_assign","","",8,[[["self"],["u128"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["usize"]]]],[11,"shr_assign","","",8,[[["self"],["usize"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["i8"]]]],[11,"shr_assign","","",8,[[["self"],["i8"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["i16"]]]],[11,"shr_assign","","",8,[[["self"],["i16"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["i32"]]]],[11,"shr_assign","","",8,[[["self"],["i32"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["i64"]]]],[11,"shr_assign","","",8,[[["self"],["i64"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["i128"]]]],[11,"shr_assign","","",8,[[["self"],["i128"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["isize"]]]],[11,"shr_assign","","",8,[[["self"],["isize"]]]],[11,"from","","",8,[[["bool"]],["self"]]],[11,"from","","",8,[[["u8"]],["self"]]],[11,"from","","",8,[[["u8"]],["self"]]],[11,"from","","",8,[[["u16"]],["self"]]],[11,"from","","",8,[[["u16"]],["self"]]],[11,"from","","",8,[[["u32"]],["self"]]],[11,"from","","",8,[[["u32"]],["self"]]],[11,"from","","",8,[[["u64"]],["self"]]],[11,"from","","",8,[[["u64"]],["self"]]],[11,"from","","",8,[[["u128"]],["self"]]],[11,"from","","",8,[[["u128"]],["self"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"hash","","",8,[[["self"],["h"]]]],[11,"sum","","",8,[[["i"]],["self"]]],[11,"sum","","",8,[[["i"]],["self"]]],[11,"product","","",8,[[["i"]],["self"]]],[11,"product","","",8,[[["i"]],["self"]]],[11,"as_byte_slice_mut","","",8,N],[11,"to_le","","",8,[[["self"]]]],[11,"heap_size_of_children","","",8,[[["self"]],["usize"]]],[11,"serialize","","",8,[[["self"],["s"]],["result"]]],[11,"deserialize","","",8,[[["d"]],["result"]]],[11,"convert_into","","",9,N],[11,"convert_into","","",0,N],[11,"convert_into","","",9,N],[11,"convert_into","","",1,N],[11,"convert_into","","",9,N],[11,"convert_into","","",2,N],[11,"convert_into","","",9,N],[11,"convert_into","","",3,N],[11,"convert_into","","",9,N],[11,"convert_into","","",4,N],[11,"convert_into","","",9,N],[11,"convert_into","","",5,N],[11,"convert_into","","",9,N],[11,"convert_into","","",6,N],[11,"convert_into","","",9,N],[11,"convert_into","","",7,N],[11,"convert_into","","",9,N],[11,"convert_into","","",8,N],[11,"zero","","Create a new fixed uint and value is zero.",9,[[],["self"]]],[11,"one","","Create a new fixed uint and value is zero.",9,[[],["self"]]],[11,"is_zero","","Test if a fixed uint is zero.",9,[[["self"]],["bool"]]],[11,"is_max","","Test if a fixed uint is the max value.",9,[[["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",9,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",9,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",9,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",9,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",9,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",9,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",9,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",9,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",9,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",9,[[["self"]],["option",["usize"]]]],[11,"complete_mul","","Calculates the multiplication of `self` and `other`.",9,N],[11,"complete_div","","Calculates both the quotient and the remainder when `self` is divided by `other`.",9,N],[11,"gcd","","Calculates the Greatest Common Divisor (GCD).",9,[[["self"],["self"]],["self"]]],[11,"from_little_endian","","Convert from little-endian slice.",9,N],[11,"from_big_endian","","Convert from big-endian slice.",9,N],[11,"into_little_endian","","Convert into little-endian slice.",9,N],[11,"into_big_endian","","Convert into big-endian slice.",9,N],[11,"from_bin_str","","Convert from a binary string.",9,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_oct_str","","Convert from a octal string.",9,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_hex_str","","Convert from a hexadecimal string.",9,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_dec_str","","Convert from a decimal string.",9,[[["str"]],["result",["fixeduinterror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",9,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",9,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",9,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",9,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",9,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",9,[[["self"]],["u32"]]],[11,"checked_add","","Checked integer addition. Computes `self + rhs`, returning `None` if overflow occurred.",9,[[["self"],["self"]],["option"]]],[11,"checked_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",9,[[["self"],["self"]],["option"]]],[11,"checked_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",9,[[["self"],["self"]],["option"]]],[11,"checked_div","","Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`.",9,[[["self"],["self"]],["option"]]],[11,"checked_rem","","Checked integer remainder. Computes `self % rhs`, returning `None` if `rhs == 0`.",9,[[["self"],["self"]],["option"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",9,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",9,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",9,[[["self"]],["option"]]],[11,"saturating_add","","Saturating integer addition. Computes `self + rhs`, saturating at the numeric bounds instead of overflowing.",9,[[["self"],["self"]],["self"]]],[11,"saturating_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",9,[[["self"],["self"]],["self"]]],[11,"saturating_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",9,[[["self"],["self"]],["self"]]],[11,"overflowing_add","","Calculates `self + rhs`.",9,N],[11,"overflowing_sub","","Calculates `self - rhs`.",9,N],[11,"overflowing_mul","","Calculates the multiplication of `self` and `rhs`.",9,N],[11,"overflowing_div","","Calculates the divisor when `self` is divided by `rhs`.",9,N],[11,"overflowing_rem","","Calculates the remainder when `self` is divided by `rhs`.",9,N],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",9,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",9,N],[11,"overflowing_neg","","Negates `self` in an overflowing fashion.",9,N],[11,"random","","Create a random fixed uint with a input random core.",9,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",9,[[],["self"]]],[11,"clone","","",9,[[["self"]],["self"]]],[11,"default","","",9,[[],["self"]]],[11,"eq","","",9,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",9,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",9,[[["self"],["self"]],["ordering"]]],[11,"add","","",9,N],[11,"add_assign","","",9,[[["self"],["rhs"]]]],[11,"add","","",9,N],[11,"add_assign","","",9,[[["self"],["u4096"]]]],[11,"sub","","",9,N],[11,"sub_assign","","",9,[[["self"],["rhs"]]]],[11,"sub","","",9,N],[11,"sub_assign","","",9,[[["self"],["u4096"]]]],[11,"mul","","",9,N],[11,"mul_assign","","",9,[[["self"],["rhs"]]]],[11,"mul","","",9,N],[11,"mul_assign","","",9,[[["self"],["u4096"]]]],[11,"div","","",9,N],[11,"div_assign","","",9,[[["self"],["rhs"]]]],[11,"div","","",9,N],[11,"div_assign","","",9,[[["self"],["u4096"]]]],[11,"rem","","",9,N],[11,"rem_assign","","",9,[[["self"],["rhs"]]]],[11,"rem","","",9,N],[11,"rem_assign","","",9,[[["self"],["u4096"]]]],[11,"bitand","","",9,N],[11,"bitand_assign","","",9,[[["self"],["rhs"]]]],[11,"bitand","","",9,N],[11,"bitand_assign","","",9,[[["self"],["u4096"]]]],[11,"bitor","","",9,N],[11,"bitor_assign","","",9,[[["self"],["rhs"]]]],[11,"bitor","","",9,N],[11,"bitor_assign","","",9,[[["self"],["u4096"]]]],[11,"bitxor","","",9,N],[11,"bitxor_assign","","",9,[[["self"],["rhs"]]]],[11,"bitxor","","",9,N],[11,"bitxor_assign","","",9,[[["self"],["u4096"]]]],[11,"not","","",9,N],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["u8"]]]],[11,"shl_assign","","",9,[[["self"],["u8"]]]],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["u16"]]]],[11,"shl_assign","","",9,[[["self"],["u16"]]]],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["u32"]]]],[11,"shl_assign","","",9,[[["self"],["u32"]]]],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["u64"]]]],[11,"shl_assign","","",9,[[["self"],["u64"]]]],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["u128"]]]],[11,"shl_assign","","",9,[[["self"],["u128"]]]],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["usize"]]]],[11,"shl_assign","","",9,[[["self"],["usize"]]]],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["i8"]]]],[11,"shl_assign","","",9,[[["self"],["i8"]]]],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["i16"]]]],[11,"shl_assign","","",9,[[["self"],["i16"]]]],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["i32"]]]],[11,"shl_assign","","",9,[[["self"],["i32"]]]],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["i64"]]]],[11,"shl_assign","","",9,[[["self"],["i64"]]]],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["i128"]]]],[11,"shl_assign","","",9,[[["self"],["i128"]]]],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["isize"]]]],[11,"shl_assign","","",9,[[["self"],["isize"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["u8"]]]],[11,"shr_assign","","",9,[[["self"],["u8"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["u16"]]]],[11,"shr_assign","","",9,[[["self"],["u16"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["u32"]]]],[11,"shr_assign","","",9,[[["self"],["u32"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["u64"]]]],[11,"shr_assign","","",9,[[["self"],["u64"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["u128"]]]],[11,"shr_assign","","",9,[[["self"],["u128"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["usize"]]]],[11,"shr_assign","","",9,[[["self"],["usize"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["i8"]]]],[11,"shr_assign","","",9,[[["self"],["i8"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["i16"]]]],[11,"shr_assign","","",9,[[["self"],["i16"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["i32"]]]],[11,"shr_assign","","",9,[[["self"],["i32"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["i64"]]]],[11,"shr_assign","","",9,[[["self"],["i64"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["i128"]]]],[11,"shr_assign","","",9,[[["self"],["i128"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["isize"]]]],[11,"shr_assign","","",9,[[["self"],["isize"]]]],[11,"from","","",9,[[["bool"]],["self"]]],[11,"from","","",9,[[["u8"]],["self"]]],[11,"from","","",9,[[["u8"]],["self"]]],[11,"from","","",9,[[["u16"]],["self"]]],[11,"from","","",9,[[["u16"]],["self"]]],[11,"from","","",9,[[["u32"]],["self"]]],[11,"from","","",9,[[["u32"]],["self"]]],[11,"from","","",9,[[["u64"]],["self"]]],[11,"from","","",9,[[["u64"]],["self"]]],[11,"from","","",9,[[["u128"]],["self"]]],[11,"from","","",9,[[["u128"]],["self"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"hash","","",9,[[["self"],["h"]]]],[11,"sum","","",9,[[["i"]],["self"]]],[11,"sum","","",9,[[["i"]],["self"]]],[11,"product","","",9,[[["i"]],["self"]]],[11,"product","","",9,[[["i"]],["self"]]],[11,"as_byte_slice_mut","","",9,N],[11,"to_le","","",9,[[["self"]]]],[11,"heap_size_of_children","","",9,[[["self"]],["usize"]]],[11,"serialize","","",9,[[["self"],["s"]],["result"]]],[11,"deserialize","","",9,[[["d"]],["result"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"from","","",0,[[["t"]],["t"]]],[11,"to_string","","",0,[[["self"]],["string"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,N],[11,"from","","",1,[[["t"]],["t"]]],[11,"to_string","","",1,[[["self"]],["string"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,N],[11,"from","","",2,[[["t"]],["t"]]],[11,"to_string","","",2,[[["self"]],["string"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"to_owned","","",3,[[["self"]],["t"]]],[11,"clone_into","","",3,N],[11,"from","","",3,[[["t"]],["t"]]],[11,"to_string","","",3,[[["self"]],["string"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"to_owned","","",4,[[["self"]],["t"]]],[11,"clone_into","","",4,N],[11,"from","","",4,[[["t"]],["t"]]],[11,"to_string","","",4,[[["self"]],["string"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"to_owned","","",5,[[["self"]],["t"]]],[11,"clone_into","","",5,N],[11,"from","","",5,[[["t"]],["t"]]],[11,"to_string","","",5,[[["self"]],["string"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"to_owned","","",6,[[["self"]],["t"]]],[11,"clone_into","","",6,N],[11,"from","","",6,[[["t"]],["t"]]],[11,"to_string","","",6,[[["self"]],["string"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"to_owned","","",7,[[["self"]],["t"]]],[11,"clone_into","","",7,N],[11,"from","","",7,[[["t"]],["t"]]],[11,"to_string","","",7,[[["self"]],["string"]]],[11,"into","","",7,[[["self"]],["u"]]],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"get_type_id","","",7,[[["self"]],["typeid"]]],[11,"to_owned","","",8,[[["self"]],["t"]]],[11,"clone_into","","",8,N],[11,"from","","",8,[[["t"]],["t"]]],[11,"to_string","","",8,[[["self"]],["string"]]],[11,"into","","",8,[[["self"]],["u"]]],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"try_into","","",8,[[["self"]],["result"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"get_type_id","","",8,[[["self"]],["typeid"]]],[11,"to_owned","","",9,[[["self"]],["t"]]],[11,"clone_into","","",9,N],[11,"from","","",9,[[["t"]],["t"]]],[11,"to_string","","",9,[[["self"]],["string"]]],[11,"into","","",9,[[["self"]],["u"]]],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"try_into","","",9,[[["self"]],["result"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"get_type_id","","",9,[[["self"]],["typeid"]]],[11,"from","","",10,[[["t"]],["t"]]],[11,"to_string","","",10,[[["self"]],["string"]]],[11,"into","","",10,[[["self"]],["u"]]],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"try_into","","",10,[[["self"]],["result"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"get_type_id","","",10,[[["self"]],["typeid"]]],[11,"as_fail","","",10,[[["self"]],["fail"]]],[11,"from","","",11,[[["t"]],["t"]]],[11,"to_string","","",11,[[["self"]],["string"]]],[11,"into","","",11,[[["self"]],["u"]]],[11,"try_from","","",11,[[["u"]],["result"]]],[11,"borrow","","",11,[[["self"]],["t"]]],[11,"try_into","","",11,[[["self"]],["result"]]],[11,"borrow_mut","","",11,[[["self"]],["t"]]],[11,"get_type_id","","",11,[[["self"]],["typeid"]]],[11,"as_fail","","",11,[[["self"]],["fail"]]],[11,"from","","",12,[[["t"]],["t"]]],[11,"to_string","","",12,[[["self"]],["string"]]],[11,"into","","",12,[[["self"]],["u"]]],[11,"try_from","","",12,[[["u"]],["result"]]],[11,"borrow","","",12,[[["self"]],["t"]]],[11,"try_into","","",12,[[["self"]],["result"]]],[11,"borrow_mut","","",12,[[["self"]],["t"]]],[11,"get_type_id","","",12,[[["self"]],["typeid"]]],[11,"as_fail","","",12,[[["self"]],["fail"]]],[11,"from","","",13,[[["t"]],["t"]]],[11,"to_string","","",13,[[["self"]],["string"]]],[11,"into","","",13,[[["self"]],["u"]]],[11,"try_from","","",13,[[["u"]],["result"]]],[11,"borrow","","",13,[[["self"]],["t"]]],[11,"try_into","","",13,[[["self"]],["result"]]],[11,"borrow_mut","","",13,[[["self"]],["t"]]],[11,"get_type_id","","",13,[[["self"]],["typeid"]]],[11,"as_fail","","",13,[[["self"]],["fail"]]]],"paths":[[3,"U128"],[3,"U160"],[3,"U224"],[3,"U256"],[3,"U384"],[3,"U512"],[3,"U520"],[3,"U1024"],[3,"U2048"],[3,"U4096"],[4,"FromSliceError"],[4,"IntoSliceError"],[4,"FromStrError"],[4,"FixedUintError"],[8,"UintConvert"]]};
searchIndex["numext_fixed_uint_tests"]={"doc":"","items":[[0,"props","numext_fixed_uint_tests","Support proptest.",N,N],[3,"U256LeBytes","numext_fixed_uint_tests::props","",N,N],[12,"inner","","",0,N],[3,"U256LeBytesValueTree","","",N,N],[3,"U256LeBytesParameters","","",N,N],[3,"U256LeBytesStrategy","","",N,N],[3,"U256Pair","","",N,N],[12,"lhs","","",1,N],[12,"rhs","","",1,N],[12,"opr","","",1,N],[3,"U256PairValueTree","","",N,N],[3,"U256PairStrategy","","",N,N],[4,"U256PairParameters","","",N,N],[13,"Random","","",2,N],[13,"CanAdd","","",2,N],[13,"CanSub","","",2,N],[13,"CanMul","","",2,N],[13,"CanDiv","","",2,N],[13,"CanRem","","",2,N],[11,"clone","","",2,[[["self"]],["u256pairparameters"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"default","","",2,[[],["self"]]],[11,"clone","","",0,[[["self"]],["u256lebytes"]]],[11,"eq","","",0,[[["self"],["u256lebytes"]],["bool"]]],[11,"ne","","",0,[[["self"],["u256lebytes"]],["bool"]]],[11,"partial_cmp","","",0,[[["self"],["u256lebytes"]],["option",["ordering"]]]],[11,"lt","","",0,[[["self"],["u256lebytes"]],["bool"]]],[11,"le","","",0,[[["self"],["u256lebytes"]],["bool"]]],[11,"gt","","",0,[[["self"],["u256lebytes"]],["bool"]]],[11,"ge","","",0,[[["self"],["u256lebytes"]],["bool"]]],[11,"cmp","","",0,[[["self"],["u256lebytes"]],["ordering"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"from","","",0,[[["u256"]],["self"]]],[11,"from","","",0,[[["u256"]],["self"]]],[11,"from","","",0,[[["u256"]],["self"]]],[11,"from","","",0,[[["u256"]],["self"]]],[11,"any","","",0,[[["testrng"]],["self"]]],[11,"nonzero","","",0,[[["testrng"]],["self"]]],[11,"bigger","","",0,[[["self"],["testrng"]],["self"]]],[11,"nonzero_pair","","",0,N],[11,"nonzero_pair_asc","","",0,N],[11,"nonzero_pair_desc","","",0,N],[11,"can_add_without_overflow","","",0,N],[11,"can_mul_without_overflow","","",0,N],[11,"new","","",3,[[["testrunner"]],["self"]]],[11,"current","","",3,N],[11,"simplify","","",3,[[["self"]],["bool"]]],[11,"complicate","","",3,[[["self"]],["bool"]]],[11,"clone","","",4,[[["self"]],["u256lebytesparameters"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"default","","",4,[[],["u256lebytesparameters"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"new","","",5,[[["u256lebytesparameters"]],["self"]]],[11,"new_tree","","",5,[[["self"],["testrunner"]],["newtree"]]],[11,"arbitrary_with","","",0,N],[11,"clone","","",1,[[["self"]],["u256pair"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"new","","",1,[[["u256pairparameters"],["testrng"]],["self"]]],[11,"new","","",6,[[["u256pairparameters"],["testrunner"]],["self"]]],[11,"current","","",6,N],[11,"simplify","","",6,[[["self"]],["bool"]]],[11,"complicate","","",6,[[["self"]],["bool"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"new","","",7,[[["u256pairparameters"]],["self"]]],[11,"new_tree","","",7,[[["self"],["testrunner"]],["newtree"]]],[11,"arbitrary_with","","",1,N],[0,"tools","numext_fixed_uint_tests","Testing tools.",N,N],[5,"gen_nonzero","numext_fixed_uint_tests::tools","",N,[[],["t"]]],[5,"pair","","",N,[[["u256pairparameters"]],["u256pair"]]],[5,"lebytes","","",N,[[],["u256lebytes"]]],[11,"to_owned","numext_fixed_uint_tests::props","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"from","","",0,[[["t"]],["t"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"to_owned","","",4,[[["self"]],["t"]]],[11,"clone_into","","",4,N],[11,"from","","",4,[[["t"]],["t"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"from","","",5,[[["t"]],["t"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,N],[11,"from","","",1,[[["t"]],["t"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"from","","",6,[[["t"]],["t"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"from","","",7,[[["t"]],["t"]]],[11,"into","","",7,[[["self"]],["u"]]],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"get_type_id","","",7,[[["self"]],["typeid"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,N],[11,"from","","",2,[[["t"]],["t"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]]],"paths":[[3,"U256LeBytes"],[3,"U256Pair"],[4,"U256PairParameters"],[3,"U256LeBytesValueTree"],[3,"U256LeBytesParameters"],[3,"U256LeBytesStrategy"],[3,"U256PairValueTree"],[3,"U256PairStrategy"]]};
initSearch(searchIndex);
