var N = null;var searchIndex = {};
searchIndex["numext_fixed_uint"]={"doc":"","items":[[3,"U128","numext_fixed_uint","Little-endian fixed integer type.",N,N],[12,"0","","",0,N],[3,"U160","","Little-endian fixed integer type.",N,N],[12,"0","","",1,N],[3,"U224","","Little-endian fixed integer type.",N,N],[12,"0","","",2,N],[3,"U256","","Little-endian fixed integer type.",N,N],[12,"0","","",3,N],[3,"U384","","Little-endian fixed integer type.",N,N],[12,"0","","",4,N],[3,"U512","","Little-endian fixed integer type.",N,N],[12,"0","","",5,N],[3,"U520","","Little-endian fixed integer type.",N,N],[12,"0","","",6,N],[3,"U1024","","Little-endian fixed integer type.",N,N],[12,"0","","",7,N],[3,"U2048","","Little-endian fixed integer type.",N,N],[12,"0","","",8,N],[3,"U4096","","Little-endian fixed integer type.",N,N],[12,"0","","",9,N],[3,"H128","","Little-endian fixed integer type.",N,N],[12,"0","","",10,N],[3,"H160","","Little-endian fixed integer type.",N,N],[12,"0","","",11,N],[3,"H224","","Little-endian fixed integer type.",N,N],[12,"0","","",12,N],[3,"H256","","Little-endian fixed integer type.",N,N],[12,"0","","",13,N],[3,"H384","","Little-endian fixed integer type.",N,N],[12,"0","","",14,N],[3,"H512","","Little-endian fixed integer type.",N,N],[12,"0","","",15,N],[3,"H520","","Little-endian fixed integer type.",N,N],[12,"0","","",16,N],[3,"H1024","","Little-endian fixed integer type.",N,N],[12,"0","","",17,N],[3,"H2048","","Little-endian fixed integer type.",N,N],[12,"0","","",18,N],[3,"H4096","","Little-endian fixed integer type.",N,N],[12,"0","","",19,N],[4,"FromSliceError","","Error for parse from slice.",N,N],[13,"InvalidLength","","",20,N],[4,"IntoSliceError","","Error for parse from slice.",N,N],[13,"InvalidLength","","",21,N],[4,"FromStrError","","Error for parse from string.",N,N],[13,"InvalidCharacter","","",22,N],[12,"chr","numext_fixed_uint::FromStrError","",22,N],[12,"idx","","",22,N],[13,"InvalidLength","numext_fixed_uint","",22,N],[13,"Overflow","","",22,N],[4,"FixedUintError","","",N,N],[13,"FromSlice","","",23,N],[13,"IntoSlice","","",23,N],[13,"FromStr","","",23,N],[0,"prelude","","",N,N],[8,"UintConvert","numext_fixed_uint::prelude","",N,N],[10,"convert_into","","Convert a fixed uint into another, return the new fixed uint and if it be truncated.",24,N],[11,"fmt","numext_fixed_uint","",20,[[["self"],["formatter"]],["result"]]],[11,"from","","",23,[[["fromsliceerror"]],["fixeduinterror"]]],[11,"fmt","","",21,[[["self"],["formatter"]],["result"]]],[11,"from","","",23,[[["intosliceerror"]],["fixeduinterror"]]],[11,"fmt","","",22,[[["self"],["formatter"]],["result"]]],[11,"from","","",23,[[["fromstrerror"]],["fixeduinterror"]]],[11,"fmt","","",23,[[["self"],["formatter"]],["result"]]],[11,"zero","","Create a new fixed uint and value is zero.",0,[[],["self"]]],[11,"one","","Create a new fixed uint and value is zero.",0,[[],["self"]]],[11,"is_zero","","Test if a fixed uint is zero.",0,[[["self"]],["bool"]]],[11,"is_max","","Test if a fixed uint is the max value.",0,[[["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",0,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",0,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",0,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",0,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",0,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",0,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",0,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",0,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",0,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",0,[[["self"]],["option",["usize"]]]],[11,"complete_mul","","Calculates the multiplication of `self` and `other`.",0,N],[11,"complete_div","","Calculates both the quotient and the remainder when `self` is divided by `other`.",0,N],[11,"from_little_endian","","Convert from little-endian slice.",0,N],[11,"from_big_endian","","Convert from big-endian slice.",0,N],[11,"into_little_endian","","Convert into little-endian slice.",0,N],[11,"into_big_endian","","Convert into big-endian slice.",0,N],[11,"from_bin_str","","Convert from a binary string.",0,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_oct_str","","Convert from a octal string.",0,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_hex_str","","Convert from a hexadecimal string.",0,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_dec_str","","Convert from a decimal string.",0,[[["str"]],["result",["fixeduinterror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",0,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",0,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",0,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",0,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",0,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",0,[[["self"]],["u32"]]],[11,"checked_add","","Checked integer addition. Computes `self + rhs`, returning `None` if overflow occurred.",0,[[["self"],["self"]],["option"]]],[11,"checked_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",0,[[["self"],["self"]],["option"]]],[11,"checked_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",0,[[["self"],["self"]],["option"]]],[11,"checked_div","","Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`.",0,[[["self"],["self"]],["option"]]],[11,"checked_rem","","Checked integer remainder. Computes `self % rhs`, returning `None` if `rhs == 0`.",0,[[["self"],["self"]],["option"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",0,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",0,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",0,[[["self"]],["option"]]],[11,"saturating_add","","Saturating integer addition. Computes `self + rhs`, saturating at the numeric bounds instead of overflowing.",0,[[["self"],["self"]],["self"]]],[11,"saturating_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",0,[[["self"],["self"]],["self"]]],[11,"saturating_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",0,[[["self"],["self"]],["self"]]],[11,"overflowing_add","","Calculates `self + rhs`.",0,N],[11,"overflowing_sub","","Calculates `self - rhs`.",0,N],[11,"overflowing_mul","","Calculates the multiplication of `self` and `rhs`.",0,N],[11,"overflowing_div","","Calculates the divisor when `self` is divided by `rhs`.",0,N],[11,"overflowing_rem","","Calculates the remainder when `self` is divided by `rhs`.",0,N],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",0,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",0,N],[11,"overflowing_neg","","Negates `self` in an overflowing fashion.",0,N],[11,"random","","Create a random fixed uint with a input random core.",0,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",0,[[],["self"]]],[11,"clone","","",0,[[["self"]],["self"]]],[11,"default","","",0,[[],["self"]]],[11,"eq","","",0,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",0,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",0,[[["self"],["self"]],["ordering"]]],[11,"add","","",0,N],[11,"add_assign","","",0,[[["self"],["rhs"]]]],[11,"add","","",0,N],[11,"add_assign","","",0,[[["self"],["u128"]]]],[11,"sub","","",0,N],[11,"sub_assign","","",0,[[["self"],["rhs"]]]],[11,"sub","","",0,N],[11,"sub_assign","","",0,[[["self"],["u128"]]]],[11,"mul","","",0,N],[11,"mul_assign","","",0,[[["self"],["rhs"]]]],[11,"mul","","",0,N],[11,"mul_assign","","",0,[[["self"],["u128"]]]],[11,"div","","",0,N],[11,"div_assign","","",0,[[["self"],["rhs"]]]],[11,"div","","",0,N],[11,"div_assign","","",0,[[["self"],["u128"]]]],[11,"rem","","",0,N],[11,"rem_assign","","",0,[[["self"],["rhs"]]]],[11,"rem","","",0,N],[11,"rem_assign","","",0,[[["self"],["u128"]]]],[11,"bitand","","",0,N],[11,"bitand_assign","","",0,[[["self"],["rhs"]]]],[11,"bitand","","",0,N],[11,"bitand_assign","","",0,[[["self"],["u128"]]]],[11,"bitor","","",0,N],[11,"bitor_assign","","",0,[[["self"],["rhs"]]]],[11,"bitor","","",0,N],[11,"bitor_assign","","",0,[[["self"],["u128"]]]],[11,"bitxor","","",0,N],[11,"bitxor_assign","","",0,[[["self"],["rhs"]]]],[11,"bitxor","","",0,N],[11,"bitxor_assign","","",0,[[["self"],["u128"]]]],[11,"not","","",0,N],[11,"shl","","",0,N],[11,"shl","","",0,N],[11,"shl_assign","","",0,[[["self"],["u8"]]]],[11,"shl_assign","","",0,[[["self"],["u8"]]]],[11,"shl","","",0,N],[11,"shl","","",0,N],[11,"shl_assign","","",0,[[["self"],["u16"]]]],[11,"shl_assign","","",0,[[["self"],["u16"]]]],[11,"shl","","",0,N],[11,"shl","","",0,N],[11,"shl_assign","","",0,[[["self"],["u32"]]]],[11,"shl_assign","","",0,[[["self"],["u32"]]]],[11,"shl","","",0,N],[11,"shl","","",0,N],[11,"shl_assign","","",0,[[["self"],["u64"]]]],[11,"shl_assign","","",0,[[["self"],["u64"]]]],[11,"shl","","",0,N],[11,"shl","","",0,N],[11,"shl_assign","","",0,[[["self"],["u128"]]]],[11,"shl_assign","","",0,[[["self"],["u128"]]]],[11,"shl","","",0,N],[11,"shl","","",0,N],[11,"shl_assign","","",0,[[["self"],["usize"]]]],[11,"shl_assign","","",0,[[["self"],["usize"]]]],[11,"shl","","",0,N],[11,"shl","","",0,N],[11,"shl_assign","","",0,[[["self"],["i8"]]]],[11,"shl_assign","","",0,[[["self"],["i8"]]]],[11,"shl","","",0,N],[11,"shl","","",0,N],[11,"shl_assign","","",0,[[["self"],["i16"]]]],[11,"shl_assign","","",0,[[["self"],["i16"]]]],[11,"shl","","",0,N],[11,"shl","","",0,N],[11,"shl_assign","","",0,[[["self"],["i32"]]]],[11,"shl_assign","","",0,[[["self"],["i32"]]]],[11,"shl","","",0,N],[11,"shl","","",0,N],[11,"shl_assign","","",0,[[["self"],["i64"]]]],[11,"shl_assign","","",0,[[["self"],["i64"]]]],[11,"shl","","",0,N],[11,"shl","","",0,N],[11,"shl_assign","","",0,[[["self"],["i128"]]]],[11,"shl_assign","","",0,[[["self"],["i128"]]]],[11,"shl","","",0,N],[11,"shl","","",0,N],[11,"shl_assign","","",0,[[["self"],["isize"]]]],[11,"shl_assign","","",0,[[["self"],["isize"]]]],[11,"shr","","",0,N],[11,"shr","","",0,N],[11,"shr_assign","","",0,[[["self"],["u8"]]]],[11,"shr_assign","","",0,[[["self"],["u8"]]]],[11,"shr","","",0,N],[11,"shr","","",0,N],[11,"shr_assign","","",0,[[["self"],["u16"]]]],[11,"shr_assign","","",0,[[["self"],["u16"]]]],[11,"shr","","",0,N],[11,"shr","","",0,N],[11,"shr_assign","","",0,[[["self"],["u32"]]]],[11,"shr_assign","","",0,[[["self"],["u32"]]]],[11,"shr","","",0,N],[11,"shr","","",0,N],[11,"shr_assign","","",0,[[["self"],["u64"]]]],[11,"shr_assign","","",0,[[["self"],["u64"]]]],[11,"shr","","",0,N],[11,"shr","","",0,N],[11,"shr_assign","","",0,[[["self"],["u128"]]]],[11,"shr_assign","","",0,[[["self"],["u128"]]]],[11,"shr","","",0,N],[11,"shr","","",0,N],[11,"shr_assign","","",0,[[["self"],["usize"]]]],[11,"shr_assign","","",0,[[["self"],["usize"]]]],[11,"shr","","",0,N],[11,"shr","","",0,N],[11,"shr_assign","","",0,[[["self"],["i8"]]]],[11,"shr_assign","","",0,[[["self"],["i8"]]]],[11,"shr","","",0,N],[11,"shr","","",0,N],[11,"shr_assign","","",0,[[["self"],["i16"]]]],[11,"shr_assign","","",0,[[["self"],["i16"]]]],[11,"shr","","",0,N],[11,"shr","","",0,N],[11,"shr_assign","","",0,[[["self"],["i32"]]]],[11,"shr_assign","","",0,[[["self"],["i32"]]]],[11,"shr","","",0,N],[11,"shr","","",0,N],[11,"shr_assign","","",0,[[["self"],["i64"]]]],[11,"shr_assign","","",0,[[["self"],["i64"]]]],[11,"shr","","",0,N],[11,"shr","","",0,N],[11,"shr_assign","","",0,[[["self"],["i128"]]]],[11,"shr_assign","","",0,[[["self"],["i128"]]]],[11,"shr","","",0,N],[11,"shr","","",0,N],[11,"shr_assign","","",0,[[["self"],["isize"]]]],[11,"shr_assign","","",0,[[["self"],["isize"]]]],[11,"from","","",0,[[["bool"]],["self"]]],[11,"from","","",0,[[["u8"]],["self"]]],[11,"from","","",0,[[["u8"]],["self"]]],[11,"from","","",0,[[["u16"]],["self"]]],[11,"from","","",0,[[["u16"]],["self"]]],[11,"from","","",0,[[["u32"]],["self"]]],[11,"from","","",0,[[["u32"]],["self"]]],[11,"from","","",0,[[["u64"]],["self"]]],[11,"from","","",0,[[["u64"]],["self"]]],[11,"from","","",0,[[["u128"]],["self"]]],[11,"from","","",0,[[["u128"]],["self"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"hash","","",0,[[["self"],["h"]]]],[11,"sum","","",0,[[["i"]],["self"]]],[11,"sum","","",0,[[["i"]],["self"]]],[11,"product","","",0,[[["i"]],["self"]]],[11,"product","","",0,[[["i"]],["self"]]],[11,"as_byte_slice_mut","","",0,N],[11,"to_le","","",0,[[["self"]]]],[11,"convert_into","","",1,N],[11,"convert_into","","",0,N],[11,"zero","","Create a new fixed uint and value is zero.",1,[[],["self"]]],[11,"one","","Create a new fixed uint and value is zero.",1,[[],["self"]]],[11,"is_zero","","Test if a fixed uint is zero.",1,[[["self"]],["bool"]]],[11,"is_max","","Test if a fixed uint is the max value.",1,[[["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",1,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",1,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",1,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",1,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",1,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",1,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",1,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",1,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",1,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",1,[[["self"]],["option",["usize"]]]],[11,"complete_mul","","Calculates the multiplication of `self` and `other`.",1,N],[11,"complete_div","","Calculates both the quotient and the remainder when `self` is divided by `other`.",1,N],[11,"from_little_endian","","Convert from little-endian slice.",1,N],[11,"from_big_endian","","Convert from big-endian slice.",1,N],[11,"into_little_endian","","Convert into little-endian slice.",1,N],[11,"into_big_endian","","Convert into big-endian slice.",1,N],[11,"from_bin_str","","Convert from a binary string.",1,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_oct_str","","Convert from a octal string.",1,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_hex_str","","Convert from a hexadecimal string.",1,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_dec_str","","Convert from a decimal string.",1,[[["str"]],["result",["fixeduinterror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",1,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",1,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",1,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",1,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",1,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",1,[[["self"]],["u32"]]],[11,"checked_add","","Checked integer addition. Computes `self + rhs`, returning `None` if overflow occurred.",1,[[["self"],["self"]],["option"]]],[11,"checked_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",1,[[["self"],["self"]],["option"]]],[11,"checked_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",1,[[["self"],["self"]],["option"]]],[11,"checked_div","","Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`.",1,[[["self"],["self"]],["option"]]],[11,"checked_rem","","Checked integer remainder. Computes `self % rhs`, returning `None` if `rhs == 0`.",1,[[["self"],["self"]],["option"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",1,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",1,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",1,[[["self"]],["option"]]],[11,"saturating_add","","Saturating integer addition. Computes `self + rhs`, saturating at the numeric bounds instead of overflowing.",1,[[["self"],["self"]],["self"]]],[11,"saturating_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",1,[[["self"],["self"]],["self"]]],[11,"saturating_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",1,[[["self"],["self"]],["self"]]],[11,"overflowing_add","","Calculates `self + rhs`.",1,N],[11,"overflowing_sub","","Calculates `self - rhs`.",1,N],[11,"overflowing_mul","","Calculates the multiplication of `self` and `rhs`.",1,N],[11,"overflowing_div","","Calculates the divisor when `self` is divided by `rhs`.",1,N],[11,"overflowing_rem","","Calculates the remainder when `self` is divided by `rhs`.",1,N],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",1,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",1,N],[11,"overflowing_neg","","Negates `self` in an overflowing fashion.",1,N],[11,"random","","Create a random fixed uint with a input random core.",1,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",1,[[],["self"]]],[11,"clone","","",1,[[["self"]],["self"]]],[11,"default","","",1,[[],["self"]]],[11,"eq","","",1,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",1,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",1,[[["self"],["self"]],["ordering"]]],[11,"add","","",1,N],[11,"add_assign","","",1,[[["self"],["rhs"]]]],[11,"add","","",1,N],[11,"add_assign","","",1,[[["self"],["u160"]]]],[11,"sub","","",1,N],[11,"sub_assign","","",1,[[["self"],["rhs"]]]],[11,"sub","","",1,N],[11,"sub_assign","","",1,[[["self"],["u160"]]]],[11,"mul","","",1,N],[11,"mul_assign","","",1,[[["self"],["rhs"]]]],[11,"mul","","",1,N],[11,"mul_assign","","",1,[[["self"],["u160"]]]],[11,"div","","",1,N],[11,"div_assign","","",1,[[["self"],["rhs"]]]],[11,"div","","",1,N],[11,"div_assign","","",1,[[["self"],["u160"]]]],[11,"rem","","",1,N],[11,"rem_assign","","",1,[[["self"],["rhs"]]]],[11,"rem","","",1,N],[11,"rem_assign","","",1,[[["self"],["u160"]]]],[11,"bitand","","",1,N],[11,"bitand_assign","","",1,[[["self"],["rhs"]]]],[11,"bitand","","",1,N],[11,"bitand_assign","","",1,[[["self"],["u160"]]]],[11,"bitor","","",1,N],[11,"bitor_assign","","",1,[[["self"],["rhs"]]]],[11,"bitor","","",1,N],[11,"bitor_assign","","",1,[[["self"],["u160"]]]],[11,"bitxor","","",1,N],[11,"bitxor_assign","","",1,[[["self"],["rhs"]]]],[11,"bitxor","","",1,N],[11,"bitxor_assign","","",1,[[["self"],["u160"]]]],[11,"not","","",1,N],[11,"shl","","",1,N],[11,"shl","","",1,N],[11,"shl_assign","","",1,[[["self"],["u8"]]]],[11,"shl_assign","","",1,[[["self"],["u8"]]]],[11,"shl","","",1,N],[11,"shl","","",1,N],[11,"shl_assign","","",1,[[["self"],["u16"]]]],[11,"shl_assign","","",1,[[["self"],["u16"]]]],[11,"shl","","",1,N],[11,"shl","","",1,N],[11,"shl_assign","","",1,[[["self"],["u32"]]]],[11,"shl_assign","","",1,[[["self"],["u32"]]]],[11,"shl","","",1,N],[11,"shl","","",1,N],[11,"shl_assign","","",1,[[["self"],["u64"]]]],[11,"shl_assign","","",1,[[["self"],["u64"]]]],[11,"shl","","",1,N],[11,"shl","","",1,N],[11,"shl_assign","","",1,[[["self"],["u128"]]]],[11,"shl_assign","","",1,[[["self"],["u128"]]]],[11,"shl","","",1,N],[11,"shl","","",1,N],[11,"shl_assign","","",1,[[["self"],["usize"]]]],[11,"shl_assign","","",1,[[["self"],["usize"]]]],[11,"shl","","",1,N],[11,"shl","","",1,N],[11,"shl_assign","","",1,[[["self"],["i8"]]]],[11,"shl_assign","","",1,[[["self"],["i8"]]]],[11,"shl","","",1,N],[11,"shl","","",1,N],[11,"shl_assign","","",1,[[["self"],["i16"]]]],[11,"shl_assign","","",1,[[["self"],["i16"]]]],[11,"shl","","",1,N],[11,"shl","","",1,N],[11,"shl_assign","","",1,[[["self"],["i32"]]]],[11,"shl_assign","","",1,[[["self"],["i32"]]]],[11,"shl","","",1,N],[11,"shl","","",1,N],[11,"shl_assign","","",1,[[["self"],["i64"]]]],[11,"shl_assign","","",1,[[["self"],["i64"]]]],[11,"shl","","",1,N],[11,"shl","","",1,N],[11,"shl_assign","","",1,[[["self"],["i128"]]]],[11,"shl_assign","","",1,[[["self"],["i128"]]]],[11,"shl","","",1,N],[11,"shl","","",1,N],[11,"shl_assign","","",1,[[["self"],["isize"]]]],[11,"shl_assign","","",1,[[["self"],["isize"]]]],[11,"shr","","",1,N],[11,"shr","","",1,N],[11,"shr_assign","","",1,[[["self"],["u8"]]]],[11,"shr_assign","","",1,[[["self"],["u8"]]]],[11,"shr","","",1,N],[11,"shr","","",1,N],[11,"shr_assign","","",1,[[["self"],["u16"]]]],[11,"shr_assign","","",1,[[["self"],["u16"]]]],[11,"shr","","",1,N],[11,"shr","","",1,N],[11,"shr_assign","","",1,[[["self"],["u32"]]]],[11,"shr_assign","","",1,[[["self"],["u32"]]]],[11,"shr","","",1,N],[11,"shr","","",1,N],[11,"shr_assign","","",1,[[["self"],["u64"]]]],[11,"shr_assign","","",1,[[["self"],["u64"]]]],[11,"shr","","",1,N],[11,"shr","","",1,N],[11,"shr_assign","","",1,[[["self"],["u128"]]]],[11,"shr_assign","","",1,[[["self"],["u128"]]]],[11,"shr","","",1,N],[11,"shr","","",1,N],[11,"shr_assign","","",1,[[["self"],["usize"]]]],[11,"shr_assign","","",1,[[["self"],["usize"]]]],[11,"shr","","",1,N],[11,"shr","","",1,N],[11,"shr_assign","","",1,[[["self"],["i8"]]]],[11,"shr_assign","","",1,[[["self"],["i8"]]]],[11,"shr","","",1,N],[11,"shr","","",1,N],[11,"shr_assign","","",1,[[["self"],["i16"]]]],[11,"shr_assign","","",1,[[["self"],["i16"]]]],[11,"shr","","",1,N],[11,"shr","","",1,N],[11,"shr_assign","","",1,[[["self"],["i32"]]]],[11,"shr_assign","","",1,[[["self"],["i32"]]]],[11,"shr","","",1,N],[11,"shr","","",1,N],[11,"shr_assign","","",1,[[["self"],["i64"]]]],[11,"shr_assign","","",1,[[["self"],["i64"]]]],[11,"shr","","",1,N],[11,"shr","","",1,N],[11,"shr_assign","","",1,[[["self"],["i128"]]]],[11,"shr_assign","","",1,[[["self"],["i128"]]]],[11,"shr","","",1,N],[11,"shr","","",1,N],[11,"shr_assign","","",1,[[["self"],["isize"]]]],[11,"shr_assign","","",1,[[["self"],["isize"]]]],[11,"from","","",1,[[["bool"]],["self"]]],[11,"from","","",1,[[["u8"]],["self"]]],[11,"from","","",1,[[["u8"]],["self"]]],[11,"from","","",1,[[["u16"]],["self"]]],[11,"from","","",1,[[["u16"]],["self"]]],[11,"from","","",1,[[["u32"]],["self"]]],[11,"from","","",1,[[["u32"]],["self"]]],[11,"from","","",1,[[["u64"]],["self"]]],[11,"from","","",1,[[["u64"]],["self"]]],[11,"from","","",1,[[["u128"]],["self"]]],[11,"from","","",1,[[["u128"]],["self"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"hash","","",1,[[["self"],["h"]]]],[11,"sum","","",1,[[["i"]],["self"]]],[11,"sum","","",1,[[["i"]],["self"]]],[11,"product","","",1,[[["i"]],["self"]]],[11,"product","","",1,[[["i"]],["self"]]],[11,"as_byte_slice_mut","","",1,N],[11,"to_le","","",1,[[["self"]]]],[11,"convert_into","","",2,N],[11,"convert_into","","",0,N],[11,"convert_into","","",2,N],[11,"convert_into","","",1,N],[11,"zero","","Create a new fixed uint and value is zero.",2,[[],["self"]]],[11,"one","","Create a new fixed uint and value is zero.",2,[[],["self"]]],[11,"is_zero","","Test if a fixed uint is zero.",2,[[["self"]],["bool"]]],[11,"is_max","","Test if a fixed uint is the max value.",2,[[["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",2,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",2,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",2,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",2,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",2,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",2,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",2,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",2,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",2,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",2,[[["self"]],["option",["usize"]]]],[11,"complete_mul","","Calculates the multiplication of `self` and `other`.",2,N],[11,"complete_div","","Calculates both the quotient and the remainder when `self` is divided by `other`.",2,N],[11,"from_little_endian","","Convert from little-endian slice.",2,N],[11,"from_big_endian","","Convert from big-endian slice.",2,N],[11,"into_little_endian","","Convert into little-endian slice.",2,N],[11,"into_big_endian","","Convert into big-endian slice.",2,N],[11,"from_bin_str","","Convert from a binary string.",2,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_oct_str","","Convert from a octal string.",2,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_hex_str","","Convert from a hexadecimal string.",2,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_dec_str","","Convert from a decimal string.",2,[[["str"]],["result",["fixeduinterror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",2,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",2,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",2,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",2,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",2,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",2,[[["self"]],["u32"]]],[11,"checked_add","","Checked integer addition. Computes `self + rhs`, returning `None` if overflow occurred.",2,[[["self"],["self"]],["option"]]],[11,"checked_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",2,[[["self"],["self"]],["option"]]],[11,"checked_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",2,[[["self"],["self"]],["option"]]],[11,"checked_div","","Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`.",2,[[["self"],["self"]],["option"]]],[11,"checked_rem","","Checked integer remainder. Computes `self % rhs`, returning `None` if `rhs == 0`.",2,[[["self"],["self"]],["option"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",2,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",2,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",2,[[["self"]],["option"]]],[11,"saturating_add","","Saturating integer addition. Computes `self + rhs`, saturating at the numeric bounds instead of overflowing.",2,[[["self"],["self"]],["self"]]],[11,"saturating_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",2,[[["self"],["self"]],["self"]]],[11,"saturating_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",2,[[["self"],["self"]],["self"]]],[11,"overflowing_add","","Calculates `self + rhs`.",2,N],[11,"overflowing_sub","","Calculates `self - rhs`.",2,N],[11,"overflowing_mul","","Calculates the multiplication of `self` and `rhs`.",2,N],[11,"overflowing_div","","Calculates the divisor when `self` is divided by `rhs`.",2,N],[11,"overflowing_rem","","Calculates the remainder when `self` is divided by `rhs`.",2,N],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",2,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",2,N],[11,"overflowing_neg","","Negates `self` in an overflowing fashion.",2,N],[11,"random","","Create a random fixed uint with a input random core.",2,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",2,[[],["self"]]],[11,"clone","","",2,[[["self"]],["self"]]],[11,"default","","",2,[[],["self"]]],[11,"eq","","",2,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",2,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",2,[[["self"],["self"]],["ordering"]]],[11,"add","","",2,N],[11,"add_assign","","",2,[[["self"],["rhs"]]]],[11,"add","","",2,N],[11,"add_assign","","",2,[[["self"],["u224"]]]],[11,"sub","","",2,N],[11,"sub_assign","","",2,[[["self"],["rhs"]]]],[11,"sub","","",2,N],[11,"sub_assign","","",2,[[["self"],["u224"]]]],[11,"mul","","",2,N],[11,"mul_assign","","",2,[[["self"],["rhs"]]]],[11,"mul","","",2,N],[11,"mul_assign","","",2,[[["self"],["u224"]]]],[11,"div","","",2,N],[11,"div_assign","","",2,[[["self"],["rhs"]]]],[11,"div","","",2,N],[11,"div_assign","","",2,[[["self"],["u224"]]]],[11,"rem","","",2,N],[11,"rem_assign","","",2,[[["self"],["rhs"]]]],[11,"rem","","",2,N],[11,"rem_assign","","",2,[[["self"],["u224"]]]],[11,"bitand","","",2,N],[11,"bitand_assign","","",2,[[["self"],["rhs"]]]],[11,"bitand","","",2,N],[11,"bitand_assign","","",2,[[["self"],["u224"]]]],[11,"bitor","","",2,N],[11,"bitor_assign","","",2,[[["self"],["rhs"]]]],[11,"bitor","","",2,N],[11,"bitor_assign","","",2,[[["self"],["u224"]]]],[11,"bitxor","","",2,N],[11,"bitxor_assign","","",2,[[["self"],["rhs"]]]],[11,"bitxor","","",2,N],[11,"bitxor_assign","","",2,[[["self"],["u224"]]]],[11,"not","","",2,N],[11,"shl","","",2,N],[11,"shl","","",2,N],[11,"shl_assign","","",2,[[["self"],["u8"]]]],[11,"shl_assign","","",2,[[["self"],["u8"]]]],[11,"shl","","",2,N],[11,"shl","","",2,N],[11,"shl_assign","","",2,[[["self"],["u16"]]]],[11,"shl_assign","","",2,[[["self"],["u16"]]]],[11,"shl","","",2,N],[11,"shl","","",2,N],[11,"shl_assign","","",2,[[["self"],["u32"]]]],[11,"shl_assign","","",2,[[["self"],["u32"]]]],[11,"shl","","",2,N],[11,"shl","","",2,N],[11,"shl_assign","","",2,[[["self"],["u64"]]]],[11,"shl_assign","","",2,[[["self"],["u64"]]]],[11,"shl","","",2,N],[11,"shl","","",2,N],[11,"shl_assign","","",2,[[["self"],["u128"]]]],[11,"shl_assign","","",2,[[["self"],["u128"]]]],[11,"shl","","",2,N],[11,"shl","","",2,N],[11,"shl_assign","","",2,[[["self"],["usize"]]]],[11,"shl_assign","","",2,[[["self"],["usize"]]]],[11,"shl","","",2,N],[11,"shl","","",2,N],[11,"shl_assign","","",2,[[["self"],["i8"]]]],[11,"shl_assign","","",2,[[["self"],["i8"]]]],[11,"shl","","",2,N],[11,"shl","","",2,N],[11,"shl_assign","","",2,[[["self"],["i16"]]]],[11,"shl_assign","","",2,[[["self"],["i16"]]]],[11,"shl","","",2,N],[11,"shl","","",2,N],[11,"shl_assign","","",2,[[["self"],["i32"]]]],[11,"shl_assign","","",2,[[["self"],["i32"]]]],[11,"shl","","",2,N],[11,"shl","","",2,N],[11,"shl_assign","","",2,[[["self"],["i64"]]]],[11,"shl_assign","","",2,[[["self"],["i64"]]]],[11,"shl","","",2,N],[11,"shl","","",2,N],[11,"shl_assign","","",2,[[["self"],["i128"]]]],[11,"shl_assign","","",2,[[["self"],["i128"]]]],[11,"shl","","",2,N],[11,"shl","","",2,N],[11,"shl_assign","","",2,[[["self"],["isize"]]]],[11,"shl_assign","","",2,[[["self"],["isize"]]]],[11,"shr","","",2,N],[11,"shr","","",2,N],[11,"shr_assign","","",2,[[["self"],["u8"]]]],[11,"shr_assign","","",2,[[["self"],["u8"]]]],[11,"shr","","",2,N],[11,"shr","","",2,N],[11,"shr_assign","","",2,[[["self"],["u16"]]]],[11,"shr_assign","","",2,[[["self"],["u16"]]]],[11,"shr","","",2,N],[11,"shr","","",2,N],[11,"shr_assign","","",2,[[["self"],["u32"]]]],[11,"shr_assign","","",2,[[["self"],["u32"]]]],[11,"shr","","",2,N],[11,"shr","","",2,N],[11,"shr_assign","","",2,[[["self"],["u64"]]]],[11,"shr_assign","","",2,[[["self"],["u64"]]]],[11,"shr","","",2,N],[11,"shr","","",2,N],[11,"shr_assign","","",2,[[["self"],["u128"]]]],[11,"shr_assign","","",2,[[["self"],["u128"]]]],[11,"shr","","",2,N],[11,"shr","","",2,N],[11,"shr_assign","","",2,[[["self"],["usize"]]]],[11,"shr_assign","","",2,[[["self"],["usize"]]]],[11,"shr","","",2,N],[11,"shr","","",2,N],[11,"shr_assign","","",2,[[["self"],["i8"]]]],[11,"shr_assign","","",2,[[["self"],["i8"]]]],[11,"shr","","",2,N],[11,"shr","","",2,N],[11,"shr_assign","","",2,[[["self"],["i16"]]]],[11,"shr_assign","","",2,[[["self"],["i16"]]]],[11,"shr","","",2,N],[11,"shr","","",2,N],[11,"shr_assign","","",2,[[["self"],["i32"]]]],[11,"shr_assign","","",2,[[["self"],["i32"]]]],[11,"shr","","",2,N],[11,"shr","","",2,N],[11,"shr_assign","","",2,[[["self"],["i64"]]]],[11,"shr_assign","","",2,[[["self"],["i64"]]]],[11,"shr","","",2,N],[11,"shr","","",2,N],[11,"shr_assign","","",2,[[["self"],["i128"]]]],[11,"shr_assign","","",2,[[["self"],["i128"]]]],[11,"shr","","",2,N],[11,"shr","","",2,N],[11,"shr_assign","","",2,[[["self"],["isize"]]]],[11,"shr_assign","","",2,[[["self"],["isize"]]]],[11,"from","","",2,[[["bool"]],["self"]]],[11,"from","","",2,[[["u8"]],["self"]]],[11,"from","","",2,[[["u8"]],["self"]]],[11,"from","","",2,[[["u16"]],["self"]]],[11,"from","","",2,[[["u16"]],["self"]]],[11,"from","","",2,[[["u32"]],["self"]]],[11,"from","","",2,[[["u32"]],["self"]]],[11,"from","","",2,[[["u64"]],["self"]]],[11,"from","","",2,[[["u64"]],["self"]]],[11,"from","","",2,[[["u128"]],["self"]]],[11,"from","","",2,[[["u128"]],["self"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"hash","","",2,[[["self"],["h"]]]],[11,"sum","","",2,[[["i"]],["self"]]],[11,"sum","","",2,[[["i"]],["self"]]],[11,"product","","",2,[[["i"]],["self"]]],[11,"product","","",2,[[["i"]],["self"]]],[11,"as_byte_slice_mut","","",2,N],[11,"to_le","","",2,[[["self"]]]],[11,"convert_into","","",3,N],[11,"convert_into","","",0,N],[11,"convert_into","","",3,N],[11,"convert_into","","",1,N],[11,"convert_into","","",3,N],[11,"convert_into","","",2,N],[11,"zero","","Create a new fixed uint and value is zero.",3,[[],["self"]]],[11,"one","","Create a new fixed uint and value is zero.",3,[[],["self"]]],[11,"is_zero","","Test if a fixed uint is zero.",3,[[["self"]],["bool"]]],[11,"is_max","","Test if a fixed uint is the max value.",3,[[["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",3,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",3,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",3,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",3,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",3,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",3,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",3,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",3,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",3,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",3,[[["self"]],["option",["usize"]]]],[11,"complete_mul","","Calculates the multiplication of `self` and `other`.",3,N],[11,"complete_div","","Calculates both the quotient and the remainder when `self` is divided by `other`.",3,N],[11,"from_little_endian","","Convert from little-endian slice.",3,N],[11,"from_big_endian","","Convert from big-endian slice.",3,N],[11,"into_little_endian","","Convert into little-endian slice.",3,N],[11,"into_big_endian","","Convert into big-endian slice.",3,N],[11,"from_bin_str","","Convert from a binary string.",3,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_oct_str","","Convert from a octal string.",3,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_hex_str","","Convert from a hexadecimal string.",3,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_dec_str","","Convert from a decimal string.",3,[[["str"]],["result",["fixeduinterror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",3,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",3,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",3,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",3,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",3,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",3,[[["self"]],["u32"]]],[11,"checked_add","","Checked integer addition. Computes `self + rhs`, returning `None` if overflow occurred.",3,[[["self"],["self"]],["option"]]],[11,"checked_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",3,[[["self"],["self"]],["option"]]],[11,"checked_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",3,[[["self"],["self"]],["option"]]],[11,"checked_div","","Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`.",3,[[["self"],["self"]],["option"]]],[11,"checked_rem","","Checked integer remainder. Computes `self % rhs`, returning `None` if `rhs == 0`.",3,[[["self"],["self"]],["option"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",3,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",3,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",3,[[["self"]],["option"]]],[11,"saturating_add","","Saturating integer addition. Computes `self + rhs`, saturating at the numeric bounds instead of overflowing.",3,[[["self"],["self"]],["self"]]],[11,"saturating_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",3,[[["self"],["self"]],["self"]]],[11,"saturating_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",3,[[["self"],["self"]],["self"]]],[11,"overflowing_add","","Calculates `self + rhs`.",3,N],[11,"overflowing_sub","","Calculates `self - rhs`.",3,N],[11,"overflowing_mul","","Calculates the multiplication of `self` and `rhs`.",3,N],[11,"overflowing_div","","Calculates the divisor when `self` is divided by `rhs`.",3,N],[11,"overflowing_rem","","Calculates the remainder when `self` is divided by `rhs`.",3,N],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",3,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",3,N],[11,"overflowing_neg","","Negates `self` in an overflowing fashion.",3,N],[11,"random","","Create a random fixed uint with a input random core.",3,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",3,[[],["self"]]],[11,"clone","","",3,[[["self"]],["self"]]],[11,"default","","",3,[[],["self"]]],[11,"eq","","",3,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",3,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",3,[[["self"],["self"]],["ordering"]]],[11,"add","","",3,N],[11,"add_assign","","",3,[[["self"],["rhs"]]]],[11,"add","","",3,N],[11,"add_assign","","",3,[[["self"],["u256"]]]],[11,"sub","","",3,N],[11,"sub_assign","","",3,[[["self"],["rhs"]]]],[11,"sub","","",3,N],[11,"sub_assign","","",3,[[["self"],["u256"]]]],[11,"mul","","",3,N],[11,"mul_assign","","",3,[[["self"],["rhs"]]]],[11,"mul","","",3,N],[11,"mul_assign","","",3,[[["self"],["u256"]]]],[11,"div","","",3,N],[11,"div_assign","","",3,[[["self"],["rhs"]]]],[11,"div","","",3,N],[11,"div_assign","","",3,[[["self"],["u256"]]]],[11,"rem","","",3,N],[11,"rem_assign","","",3,[[["self"],["rhs"]]]],[11,"rem","","",3,N],[11,"rem_assign","","",3,[[["self"],["u256"]]]],[11,"bitand","","",3,N],[11,"bitand_assign","","",3,[[["self"],["rhs"]]]],[11,"bitand","","",3,N],[11,"bitand_assign","","",3,[[["self"],["u256"]]]],[11,"bitor","","",3,N],[11,"bitor_assign","","",3,[[["self"],["rhs"]]]],[11,"bitor","","",3,N],[11,"bitor_assign","","",3,[[["self"],["u256"]]]],[11,"bitxor","","",3,N],[11,"bitxor_assign","","",3,[[["self"],["rhs"]]]],[11,"bitxor","","",3,N],[11,"bitxor_assign","","",3,[[["self"],["u256"]]]],[11,"not","","",3,N],[11,"shl","","",3,N],[11,"shl","","",3,N],[11,"shl_assign","","",3,[[["self"],["u8"]]]],[11,"shl_assign","","",3,[[["self"],["u8"]]]],[11,"shl","","",3,N],[11,"shl","","",3,N],[11,"shl_assign","","",3,[[["self"],["u16"]]]],[11,"shl_assign","","",3,[[["self"],["u16"]]]],[11,"shl","","",3,N],[11,"shl","","",3,N],[11,"shl_assign","","",3,[[["self"],["u32"]]]],[11,"shl_assign","","",3,[[["self"],["u32"]]]],[11,"shl","","",3,N],[11,"shl","","",3,N],[11,"shl_assign","","",3,[[["self"],["u64"]]]],[11,"shl_assign","","",3,[[["self"],["u64"]]]],[11,"shl","","",3,N],[11,"shl","","",3,N],[11,"shl_assign","","",3,[[["self"],["u128"]]]],[11,"shl_assign","","",3,[[["self"],["u128"]]]],[11,"shl","","",3,N],[11,"shl","","",3,N],[11,"shl_assign","","",3,[[["self"],["usize"]]]],[11,"shl_assign","","",3,[[["self"],["usize"]]]],[11,"shl","","",3,N],[11,"shl","","",3,N],[11,"shl_assign","","",3,[[["self"],["i8"]]]],[11,"shl_assign","","",3,[[["self"],["i8"]]]],[11,"shl","","",3,N],[11,"shl","","",3,N],[11,"shl_assign","","",3,[[["self"],["i16"]]]],[11,"shl_assign","","",3,[[["self"],["i16"]]]],[11,"shl","","",3,N],[11,"shl","","",3,N],[11,"shl_assign","","",3,[[["self"],["i32"]]]],[11,"shl_assign","","",3,[[["self"],["i32"]]]],[11,"shl","","",3,N],[11,"shl","","",3,N],[11,"shl_assign","","",3,[[["self"],["i64"]]]],[11,"shl_assign","","",3,[[["self"],["i64"]]]],[11,"shl","","",3,N],[11,"shl","","",3,N],[11,"shl_assign","","",3,[[["self"],["i128"]]]],[11,"shl_assign","","",3,[[["self"],["i128"]]]],[11,"shl","","",3,N],[11,"shl","","",3,N],[11,"shl_assign","","",3,[[["self"],["isize"]]]],[11,"shl_assign","","",3,[[["self"],["isize"]]]],[11,"shr","","",3,N],[11,"shr","","",3,N],[11,"shr_assign","","",3,[[["self"],["u8"]]]],[11,"shr_assign","","",3,[[["self"],["u8"]]]],[11,"shr","","",3,N],[11,"shr","","",3,N],[11,"shr_assign","","",3,[[["self"],["u16"]]]],[11,"shr_assign","","",3,[[["self"],["u16"]]]],[11,"shr","","",3,N],[11,"shr","","",3,N],[11,"shr_assign","","",3,[[["self"],["u32"]]]],[11,"shr_assign","","",3,[[["self"],["u32"]]]],[11,"shr","","",3,N],[11,"shr","","",3,N],[11,"shr_assign","","",3,[[["self"],["u64"]]]],[11,"shr_assign","","",3,[[["self"],["u64"]]]],[11,"shr","","",3,N],[11,"shr","","",3,N],[11,"shr_assign","","",3,[[["self"],["u128"]]]],[11,"shr_assign","","",3,[[["self"],["u128"]]]],[11,"shr","","",3,N],[11,"shr","","",3,N],[11,"shr_assign","","",3,[[["self"],["usize"]]]],[11,"shr_assign","","",3,[[["self"],["usize"]]]],[11,"shr","","",3,N],[11,"shr","","",3,N],[11,"shr_assign","","",3,[[["self"],["i8"]]]],[11,"shr_assign","","",3,[[["self"],["i8"]]]],[11,"shr","","",3,N],[11,"shr","","",3,N],[11,"shr_assign","","",3,[[["self"],["i16"]]]],[11,"shr_assign","","",3,[[["self"],["i16"]]]],[11,"shr","","",3,N],[11,"shr","","",3,N],[11,"shr_assign","","",3,[[["self"],["i32"]]]],[11,"shr_assign","","",3,[[["self"],["i32"]]]],[11,"shr","","",3,N],[11,"shr","","",3,N],[11,"shr_assign","","",3,[[["self"],["i64"]]]],[11,"shr_assign","","",3,[[["self"],["i64"]]]],[11,"shr","","",3,N],[11,"shr","","",3,N],[11,"shr_assign","","",3,[[["self"],["i128"]]]],[11,"shr_assign","","",3,[[["self"],["i128"]]]],[11,"shr","","",3,N],[11,"shr","","",3,N],[11,"shr_assign","","",3,[[["self"],["isize"]]]],[11,"shr_assign","","",3,[[["self"],["isize"]]]],[11,"from","","",3,[[["bool"]],["self"]]],[11,"from","","",3,[[["u8"]],["self"]]],[11,"from","","",3,[[["u8"]],["self"]]],[11,"from","","",3,[[["u16"]],["self"]]],[11,"from","","",3,[[["u16"]],["self"]]],[11,"from","","",3,[[["u32"]],["self"]]],[11,"from","","",3,[[["u32"]],["self"]]],[11,"from","","",3,[[["u64"]],["self"]]],[11,"from","","",3,[[["u64"]],["self"]]],[11,"from","","",3,[[["u128"]],["self"]]],[11,"from","","",3,[[["u128"]],["self"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"hash","","",3,[[["self"],["h"]]]],[11,"sum","","",3,[[["i"]],["self"]]],[11,"sum","","",3,[[["i"]],["self"]]],[11,"product","","",3,[[["i"]],["self"]]],[11,"product","","",3,[[["i"]],["self"]]],[11,"as_byte_slice_mut","","",3,N],[11,"to_le","","",3,[[["self"]]]],[11,"convert_into","","",4,N],[11,"convert_into","","",0,N],[11,"convert_into","","",4,N],[11,"convert_into","","",1,N],[11,"convert_into","","",4,N],[11,"convert_into","","",2,N],[11,"convert_into","","",4,N],[11,"convert_into","","",3,N],[11,"zero","","Create a new fixed uint and value is zero.",4,[[],["self"]]],[11,"one","","Create a new fixed uint and value is zero.",4,[[],["self"]]],[11,"is_zero","","Test if a fixed uint is zero.",4,[[["self"]],["bool"]]],[11,"is_max","","Test if a fixed uint is the max value.",4,[[["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",4,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",4,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",4,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",4,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",4,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",4,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",4,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",4,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",4,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",4,[[["self"]],["option",["usize"]]]],[11,"complete_mul","","Calculates the multiplication of `self` and `other`.",4,N],[11,"complete_div","","Calculates both the quotient and the remainder when `self` is divided by `other`.",4,N],[11,"from_little_endian","","Convert from little-endian slice.",4,N],[11,"from_big_endian","","Convert from big-endian slice.",4,N],[11,"into_little_endian","","Convert into little-endian slice.",4,N],[11,"into_big_endian","","Convert into big-endian slice.",4,N],[11,"from_bin_str","","Convert from a binary string.",4,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_oct_str","","Convert from a octal string.",4,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_hex_str","","Convert from a hexadecimal string.",4,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_dec_str","","Convert from a decimal string.",4,[[["str"]],["result",["fixeduinterror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",4,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",4,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",4,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",4,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",4,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",4,[[["self"]],["u32"]]],[11,"checked_add","","Checked integer addition. Computes `self + rhs`, returning `None` if overflow occurred.",4,[[["self"],["self"]],["option"]]],[11,"checked_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",4,[[["self"],["self"]],["option"]]],[11,"checked_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",4,[[["self"],["self"]],["option"]]],[11,"checked_div","","Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`.",4,[[["self"],["self"]],["option"]]],[11,"checked_rem","","Checked integer remainder. Computes `self % rhs`, returning `None` if `rhs == 0`.",4,[[["self"],["self"]],["option"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",4,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",4,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",4,[[["self"]],["option"]]],[11,"saturating_add","","Saturating integer addition. Computes `self + rhs`, saturating at the numeric bounds instead of overflowing.",4,[[["self"],["self"]],["self"]]],[11,"saturating_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",4,[[["self"],["self"]],["self"]]],[11,"saturating_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",4,[[["self"],["self"]],["self"]]],[11,"overflowing_add","","Calculates `self + rhs`.",4,N],[11,"overflowing_sub","","Calculates `self - rhs`.",4,N],[11,"overflowing_mul","","Calculates the multiplication of `self` and `rhs`.",4,N],[11,"overflowing_div","","Calculates the divisor when `self` is divided by `rhs`.",4,N],[11,"overflowing_rem","","Calculates the remainder when `self` is divided by `rhs`.",4,N],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",4,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",4,N],[11,"overflowing_neg","","Negates `self` in an overflowing fashion.",4,N],[11,"random","","Create a random fixed uint with a input random core.",4,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",4,[[],["self"]]],[11,"clone","","",4,[[["self"]],["self"]]],[11,"default","","",4,[[],["self"]]],[11,"eq","","",4,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",4,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",4,[[["self"],["self"]],["ordering"]]],[11,"add","","",4,N],[11,"add_assign","","",4,[[["self"],["rhs"]]]],[11,"add","","",4,N],[11,"add_assign","","",4,[[["self"],["u384"]]]],[11,"sub","","",4,N],[11,"sub_assign","","",4,[[["self"],["rhs"]]]],[11,"sub","","",4,N],[11,"sub_assign","","",4,[[["self"],["u384"]]]],[11,"mul","","",4,N],[11,"mul_assign","","",4,[[["self"],["rhs"]]]],[11,"mul","","",4,N],[11,"mul_assign","","",4,[[["self"],["u384"]]]],[11,"div","","",4,N],[11,"div_assign","","",4,[[["self"],["rhs"]]]],[11,"div","","",4,N],[11,"div_assign","","",4,[[["self"],["u384"]]]],[11,"rem","","",4,N],[11,"rem_assign","","",4,[[["self"],["rhs"]]]],[11,"rem","","",4,N],[11,"rem_assign","","",4,[[["self"],["u384"]]]],[11,"bitand","","",4,N],[11,"bitand_assign","","",4,[[["self"],["rhs"]]]],[11,"bitand","","",4,N],[11,"bitand_assign","","",4,[[["self"],["u384"]]]],[11,"bitor","","",4,N],[11,"bitor_assign","","",4,[[["self"],["rhs"]]]],[11,"bitor","","",4,N],[11,"bitor_assign","","",4,[[["self"],["u384"]]]],[11,"bitxor","","",4,N],[11,"bitxor_assign","","",4,[[["self"],["rhs"]]]],[11,"bitxor","","",4,N],[11,"bitxor_assign","","",4,[[["self"],["u384"]]]],[11,"not","","",4,N],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["u8"]]]],[11,"shl_assign","","",4,[[["self"],["u8"]]]],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["u16"]]]],[11,"shl_assign","","",4,[[["self"],["u16"]]]],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["u32"]]]],[11,"shl_assign","","",4,[[["self"],["u32"]]]],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["u64"]]]],[11,"shl_assign","","",4,[[["self"],["u64"]]]],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["u128"]]]],[11,"shl_assign","","",4,[[["self"],["u128"]]]],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["usize"]]]],[11,"shl_assign","","",4,[[["self"],["usize"]]]],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["i8"]]]],[11,"shl_assign","","",4,[[["self"],["i8"]]]],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["i16"]]]],[11,"shl_assign","","",4,[[["self"],["i16"]]]],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["i32"]]]],[11,"shl_assign","","",4,[[["self"],["i32"]]]],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["i64"]]]],[11,"shl_assign","","",4,[[["self"],["i64"]]]],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["i128"]]]],[11,"shl_assign","","",4,[[["self"],["i128"]]]],[11,"shl","","",4,N],[11,"shl","","",4,N],[11,"shl_assign","","",4,[[["self"],["isize"]]]],[11,"shl_assign","","",4,[[["self"],["isize"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["u8"]]]],[11,"shr_assign","","",4,[[["self"],["u8"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["u16"]]]],[11,"shr_assign","","",4,[[["self"],["u16"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["u32"]]]],[11,"shr_assign","","",4,[[["self"],["u32"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["u64"]]]],[11,"shr_assign","","",4,[[["self"],["u64"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["u128"]]]],[11,"shr_assign","","",4,[[["self"],["u128"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["usize"]]]],[11,"shr_assign","","",4,[[["self"],["usize"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["i8"]]]],[11,"shr_assign","","",4,[[["self"],["i8"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["i16"]]]],[11,"shr_assign","","",4,[[["self"],["i16"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["i32"]]]],[11,"shr_assign","","",4,[[["self"],["i32"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["i64"]]]],[11,"shr_assign","","",4,[[["self"],["i64"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["i128"]]]],[11,"shr_assign","","",4,[[["self"],["i128"]]]],[11,"shr","","",4,N],[11,"shr","","",4,N],[11,"shr_assign","","",4,[[["self"],["isize"]]]],[11,"shr_assign","","",4,[[["self"],["isize"]]]],[11,"from","","",4,[[["bool"]],["self"]]],[11,"from","","",4,[[["u8"]],["self"]]],[11,"from","","",4,[[["u8"]],["self"]]],[11,"from","","",4,[[["u16"]],["self"]]],[11,"from","","",4,[[["u16"]],["self"]]],[11,"from","","",4,[[["u32"]],["self"]]],[11,"from","","",4,[[["u32"]],["self"]]],[11,"from","","",4,[[["u64"]],["self"]]],[11,"from","","",4,[[["u64"]],["self"]]],[11,"from","","",4,[[["u128"]],["self"]]],[11,"from","","",4,[[["u128"]],["self"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"hash","","",4,[[["self"],["h"]]]],[11,"sum","","",4,[[["i"]],["self"]]],[11,"sum","","",4,[[["i"]],["self"]]],[11,"product","","",4,[[["i"]],["self"]]],[11,"product","","",4,[[["i"]],["self"]]],[11,"as_byte_slice_mut","","",4,N],[11,"to_le","","",4,[[["self"]]]],[11,"convert_into","","",5,N],[11,"convert_into","","",0,N],[11,"convert_into","","",5,N],[11,"convert_into","","",1,N],[11,"convert_into","","",5,N],[11,"convert_into","","",2,N],[11,"convert_into","","",5,N],[11,"convert_into","","",3,N],[11,"convert_into","","",5,N],[11,"convert_into","","",4,N],[11,"zero","","Create a new fixed uint and value is zero.",5,[[],["self"]]],[11,"one","","Create a new fixed uint and value is zero.",5,[[],["self"]]],[11,"is_zero","","Test if a fixed uint is zero.",5,[[["self"]],["bool"]]],[11,"is_max","","Test if a fixed uint is the max value.",5,[[["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",5,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",5,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",5,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",5,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",5,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",5,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",5,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",5,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",5,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",5,[[["self"]],["option",["usize"]]]],[11,"complete_mul","","Calculates the multiplication of `self` and `other`.",5,N],[11,"complete_div","","Calculates both the quotient and the remainder when `self` is divided by `other`.",5,N],[11,"from_little_endian","","Convert from little-endian slice.",5,N],[11,"from_big_endian","","Convert from big-endian slice.",5,N],[11,"into_little_endian","","Convert into little-endian slice.",5,N],[11,"into_big_endian","","Convert into big-endian slice.",5,N],[11,"from_bin_str","","Convert from a binary string.",5,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_oct_str","","Convert from a octal string.",5,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_hex_str","","Convert from a hexadecimal string.",5,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_dec_str","","Convert from a decimal string.",5,[[["str"]],["result",["fixeduinterror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",5,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",5,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",5,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",5,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",5,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",5,[[["self"]],["u32"]]],[11,"checked_add","","Checked integer addition. Computes `self + rhs`, returning `None` if overflow occurred.",5,[[["self"],["self"]],["option"]]],[11,"checked_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",5,[[["self"],["self"]],["option"]]],[11,"checked_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",5,[[["self"],["self"]],["option"]]],[11,"checked_div","","Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`.",5,[[["self"],["self"]],["option"]]],[11,"checked_rem","","Checked integer remainder. Computes `self % rhs`, returning `None` if `rhs == 0`.",5,[[["self"],["self"]],["option"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",5,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",5,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",5,[[["self"]],["option"]]],[11,"saturating_add","","Saturating integer addition. Computes `self + rhs`, saturating at the numeric bounds instead of overflowing.",5,[[["self"],["self"]],["self"]]],[11,"saturating_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",5,[[["self"],["self"]],["self"]]],[11,"saturating_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",5,[[["self"],["self"]],["self"]]],[11,"overflowing_add","","Calculates `self + rhs`.",5,N],[11,"overflowing_sub","","Calculates `self - rhs`.",5,N],[11,"overflowing_mul","","Calculates the multiplication of `self` and `rhs`.",5,N],[11,"overflowing_div","","Calculates the divisor when `self` is divided by `rhs`.",5,N],[11,"overflowing_rem","","Calculates the remainder when `self` is divided by `rhs`.",5,N],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",5,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",5,N],[11,"overflowing_neg","","Negates `self` in an overflowing fashion.",5,N],[11,"random","","Create a random fixed uint with a input random core.",5,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",5,[[],["self"]]],[11,"clone","","",5,[[["self"]],["self"]]],[11,"default","","",5,[[],["self"]]],[11,"eq","","",5,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",5,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",5,[[["self"],["self"]],["ordering"]]],[11,"add","","",5,N],[11,"add_assign","","",5,[[["self"],["rhs"]]]],[11,"add","","",5,N],[11,"add_assign","","",5,[[["self"],["u512"]]]],[11,"sub","","",5,N],[11,"sub_assign","","",5,[[["self"],["rhs"]]]],[11,"sub","","",5,N],[11,"sub_assign","","",5,[[["self"],["u512"]]]],[11,"mul","","",5,N],[11,"mul_assign","","",5,[[["self"],["rhs"]]]],[11,"mul","","",5,N],[11,"mul_assign","","",5,[[["self"],["u512"]]]],[11,"div","","",5,N],[11,"div_assign","","",5,[[["self"],["rhs"]]]],[11,"div","","",5,N],[11,"div_assign","","",5,[[["self"],["u512"]]]],[11,"rem","","",5,N],[11,"rem_assign","","",5,[[["self"],["rhs"]]]],[11,"rem","","",5,N],[11,"rem_assign","","",5,[[["self"],["u512"]]]],[11,"bitand","","",5,N],[11,"bitand_assign","","",5,[[["self"],["rhs"]]]],[11,"bitand","","",5,N],[11,"bitand_assign","","",5,[[["self"],["u512"]]]],[11,"bitor","","",5,N],[11,"bitor_assign","","",5,[[["self"],["rhs"]]]],[11,"bitor","","",5,N],[11,"bitor_assign","","",5,[[["self"],["u512"]]]],[11,"bitxor","","",5,N],[11,"bitxor_assign","","",5,[[["self"],["rhs"]]]],[11,"bitxor","","",5,N],[11,"bitxor_assign","","",5,[[["self"],["u512"]]]],[11,"not","","",5,N],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["u8"]]]],[11,"shl_assign","","",5,[[["self"],["u8"]]]],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["u16"]]]],[11,"shl_assign","","",5,[[["self"],["u16"]]]],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["u32"]]]],[11,"shl_assign","","",5,[[["self"],["u32"]]]],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["u64"]]]],[11,"shl_assign","","",5,[[["self"],["u64"]]]],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["u128"]]]],[11,"shl_assign","","",5,[[["self"],["u128"]]]],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["usize"]]]],[11,"shl_assign","","",5,[[["self"],["usize"]]]],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["i8"]]]],[11,"shl_assign","","",5,[[["self"],["i8"]]]],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["i16"]]]],[11,"shl_assign","","",5,[[["self"],["i16"]]]],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["i32"]]]],[11,"shl_assign","","",5,[[["self"],["i32"]]]],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["i64"]]]],[11,"shl_assign","","",5,[[["self"],["i64"]]]],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["i128"]]]],[11,"shl_assign","","",5,[[["self"],["i128"]]]],[11,"shl","","",5,N],[11,"shl","","",5,N],[11,"shl_assign","","",5,[[["self"],["isize"]]]],[11,"shl_assign","","",5,[[["self"],["isize"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["u8"]]]],[11,"shr_assign","","",5,[[["self"],["u8"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["u16"]]]],[11,"shr_assign","","",5,[[["self"],["u16"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["u32"]]]],[11,"shr_assign","","",5,[[["self"],["u32"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["u64"]]]],[11,"shr_assign","","",5,[[["self"],["u64"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["u128"]]]],[11,"shr_assign","","",5,[[["self"],["u128"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["usize"]]]],[11,"shr_assign","","",5,[[["self"],["usize"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["i8"]]]],[11,"shr_assign","","",5,[[["self"],["i8"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["i16"]]]],[11,"shr_assign","","",5,[[["self"],["i16"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["i32"]]]],[11,"shr_assign","","",5,[[["self"],["i32"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["i64"]]]],[11,"shr_assign","","",5,[[["self"],["i64"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["i128"]]]],[11,"shr_assign","","",5,[[["self"],["i128"]]]],[11,"shr","","",5,N],[11,"shr","","",5,N],[11,"shr_assign","","",5,[[["self"],["isize"]]]],[11,"shr_assign","","",5,[[["self"],["isize"]]]],[11,"from","","",5,[[["bool"]],["self"]]],[11,"from","","",5,[[["u8"]],["self"]]],[11,"from","","",5,[[["u8"]],["self"]]],[11,"from","","",5,[[["u16"]],["self"]]],[11,"from","","",5,[[["u16"]],["self"]]],[11,"from","","",5,[[["u32"]],["self"]]],[11,"from","","",5,[[["u32"]],["self"]]],[11,"from","","",5,[[["u64"]],["self"]]],[11,"from","","",5,[[["u64"]],["self"]]],[11,"from","","",5,[[["u128"]],["self"]]],[11,"from","","",5,[[["u128"]],["self"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"hash","","",5,[[["self"],["h"]]]],[11,"sum","","",5,[[["i"]],["self"]]],[11,"sum","","",5,[[["i"]],["self"]]],[11,"product","","",5,[[["i"]],["self"]]],[11,"product","","",5,[[["i"]],["self"]]],[11,"as_byte_slice_mut","","",5,N],[11,"to_le","","",5,[[["self"]]]],[11,"convert_into","","",6,N],[11,"convert_into","","",0,N],[11,"convert_into","","",6,N],[11,"convert_into","","",1,N],[11,"convert_into","","",6,N],[11,"convert_into","","",2,N],[11,"convert_into","","",6,N],[11,"convert_into","","",3,N],[11,"convert_into","","",6,N],[11,"convert_into","","",4,N],[11,"convert_into","","",6,N],[11,"convert_into","","",5,N],[11,"zero","","Create a new fixed uint and value is zero.",6,[[],["self"]]],[11,"one","","Create a new fixed uint and value is zero.",6,[[],["self"]]],[11,"is_zero","","Test if a fixed uint is zero.",6,[[["self"]],["bool"]]],[11,"is_max","","Test if a fixed uint is the max value.",6,[[["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",6,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",6,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",6,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",6,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",6,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",6,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",6,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",6,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",6,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",6,[[["self"]],["option",["usize"]]]],[11,"complete_mul","","Calculates the multiplication of `self` and `other`.",6,N],[11,"complete_div","","Calculates both the quotient and the remainder when `self` is divided by `other`.",6,N],[11,"from_little_endian","","Convert from little-endian slice.",6,N],[11,"from_big_endian","","Convert from big-endian slice.",6,N],[11,"into_little_endian","","Convert into little-endian slice.",6,N],[11,"into_big_endian","","Convert into big-endian slice.",6,N],[11,"from_bin_str","","Convert from a binary string.",6,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_oct_str","","Convert from a octal string.",6,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_hex_str","","Convert from a hexadecimal string.",6,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_dec_str","","Convert from a decimal string.",6,[[["str"]],["result",["fixeduinterror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",6,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",6,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",6,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",6,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",6,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",6,[[["self"]],["u32"]]],[11,"checked_add","","Checked integer addition. Computes `self + rhs`, returning `None` if overflow occurred.",6,[[["self"],["self"]],["option"]]],[11,"checked_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",6,[[["self"],["self"]],["option"]]],[11,"checked_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",6,[[["self"],["self"]],["option"]]],[11,"checked_div","","Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`.",6,[[["self"],["self"]],["option"]]],[11,"checked_rem","","Checked integer remainder. Computes `self % rhs`, returning `None` if `rhs == 0`.",6,[[["self"],["self"]],["option"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",6,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",6,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",6,[[["self"]],["option"]]],[11,"saturating_add","","Saturating integer addition. Computes `self + rhs`, saturating at the numeric bounds instead of overflowing.",6,[[["self"],["self"]],["self"]]],[11,"saturating_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",6,[[["self"],["self"]],["self"]]],[11,"saturating_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",6,[[["self"],["self"]],["self"]]],[11,"overflowing_add","","Calculates `self + rhs`.",6,N],[11,"overflowing_sub","","Calculates `self - rhs`.",6,N],[11,"overflowing_mul","","Calculates the multiplication of `self` and `rhs`.",6,N],[11,"overflowing_div","","Calculates the divisor when `self` is divided by `rhs`.",6,N],[11,"overflowing_rem","","Calculates the remainder when `self` is divided by `rhs`.",6,N],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",6,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",6,N],[11,"overflowing_neg","","Negates `self` in an overflowing fashion.",6,N],[11,"random","","Create a random fixed uint with a input random core.",6,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",6,[[],["self"]]],[11,"clone","","",6,[[["self"]],["self"]]],[11,"default","","",6,[[],["self"]]],[11,"eq","","",6,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",6,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",6,[[["self"],["self"]],["ordering"]]],[11,"add","","",6,N],[11,"add_assign","","",6,[[["self"],["rhs"]]]],[11,"add","","",6,N],[11,"add_assign","","",6,[[["self"],["u520"]]]],[11,"sub","","",6,N],[11,"sub_assign","","",6,[[["self"],["rhs"]]]],[11,"sub","","",6,N],[11,"sub_assign","","",6,[[["self"],["u520"]]]],[11,"mul","","",6,N],[11,"mul_assign","","",6,[[["self"],["rhs"]]]],[11,"mul","","",6,N],[11,"mul_assign","","",6,[[["self"],["u520"]]]],[11,"div","","",6,N],[11,"div_assign","","",6,[[["self"],["rhs"]]]],[11,"div","","",6,N],[11,"div_assign","","",6,[[["self"],["u520"]]]],[11,"rem","","",6,N],[11,"rem_assign","","",6,[[["self"],["rhs"]]]],[11,"rem","","",6,N],[11,"rem_assign","","",6,[[["self"],["u520"]]]],[11,"bitand","","",6,N],[11,"bitand_assign","","",6,[[["self"],["rhs"]]]],[11,"bitand","","",6,N],[11,"bitand_assign","","",6,[[["self"],["u520"]]]],[11,"bitor","","",6,N],[11,"bitor_assign","","",6,[[["self"],["rhs"]]]],[11,"bitor","","",6,N],[11,"bitor_assign","","",6,[[["self"],["u520"]]]],[11,"bitxor","","",6,N],[11,"bitxor_assign","","",6,[[["self"],["rhs"]]]],[11,"bitxor","","",6,N],[11,"bitxor_assign","","",6,[[["self"],["u520"]]]],[11,"not","","",6,N],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["u8"]]]],[11,"shl_assign","","",6,[[["self"],["u8"]]]],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["u16"]]]],[11,"shl_assign","","",6,[[["self"],["u16"]]]],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["u32"]]]],[11,"shl_assign","","",6,[[["self"],["u32"]]]],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["u64"]]]],[11,"shl_assign","","",6,[[["self"],["u64"]]]],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["u128"]]]],[11,"shl_assign","","",6,[[["self"],["u128"]]]],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["usize"]]]],[11,"shl_assign","","",6,[[["self"],["usize"]]]],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["i8"]]]],[11,"shl_assign","","",6,[[["self"],["i8"]]]],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["i16"]]]],[11,"shl_assign","","",6,[[["self"],["i16"]]]],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["i32"]]]],[11,"shl_assign","","",6,[[["self"],["i32"]]]],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["i64"]]]],[11,"shl_assign","","",6,[[["self"],["i64"]]]],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["i128"]]]],[11,"shl_assign","","",6,[[["self"],["i128"]]]],[11,"shl","","",6,N],[11,"shl","","",6,N],[11,"shl_assign","","",6,[[["self"],["isize"]]]],[11,"shl_assign","","",6,[[["self"],["isize"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["u8"]]]],[11,"shr_assign","","",6,[[["self"],["u8"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["u16"]]]],[11,"shr_assign","","",6,[[["self"],["u16"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["u32"]]]],[11,"shr_assign","","",6,[[["self"],["u32"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["u64"]]]],[11,"shr_assign","","",6,[[["self"],["u64"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["u128"]]]],[11,"shr_assign","","",6,[[["self"],["u128"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["usize"]]]],[11,"shr_assign","","",6,[[["self"],["usize"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["i8"]]]],[11,"shr_assign","","",6,[[["self"],["i8"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["i16"]]]],[11,"shr_assign","","",6,[[["self"],["i16"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["i32"]]]],[11,"shr_assign","","",6,[[["self"],["i32"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["i64"]]]],[11,"shr_assign","","",6,[[["self"],["i64"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["i128"]]]],[11,"shr_assign","","",6,[[["self"],["i128"]]]],[11,"shr","","",6,N],[11,"shr","","",6,N],[11,"shr_assign","","",6,[[["self"],["isize"]]]],[11,"shr_assign","","",6,[[["self"],["isize"]]]],[11,"from","","",6,[[["bool"]],["self"]]],[11,"from","","",6,[[["u8"]],["self"]]],[11,"from","","",6,[[["u8"]],["self"]]],[11,"from","","",6,[[["u16"]],["self"]]],[11,"from","","",6,[[["u16"]],["self"]]],[11,"from","","",6,[[["u32"]],["self"]]],[11,"from","","",6,[[["u32"]],["self"]]],[11,"from","","",6,[[["u64"]],["self"]]],[11,"from","","",6,[[["u64"]],["self"]]],[11,"from","","",6,[[["u128"]],["self"]]],[11,"from","","",6,[[["u128"]],["self"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"hash","","",6,[[["self"],["h"]]]],[11,"sum","","",6,[[["i"]],["self"]]],[11,"sum","","",6,[[["i"]],["self"]]],[11,"product","","",6,[[["i"]],["self"]]],[11,"product","","",6,[[["i"]],["self"]]],[11,"as_byte_slice_mut","","",6,N],[11,"to_le","","",6,[[["self"]]]],[11,"convert_into","","",7,N],[11,"convert_into","","",0,N],[11,"convert_into","","",7,N],[11,"convert_into","","",1,N],[11,"convert_into","","",7,N],[11,"convert_into","","",2,N],[11,"convert_into","","",7,N],[11,"convert_into","","",3,N],[11,"convert_into","","",7,N],[11,"convert_into","","",4,N],[11,"convert_into","","",7,N],[11,"convert_into","","",5,N],[11,"convert_into","","",7,N],[11,"convert_into","","",6,N],[11,"zero","","Create a new fixed uint and value is zero.",7,[[],["self"]]],[11,"one","","Create a new fixed uint and value is zero.",7,[[],["self"]]],[11,"is_zero","","Test if a fixed uint is zero.",7,[[["self"]],["bool"]]],[11,"is_max","","Test if a fixed uint is the max value.",7,[[["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",7,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",7,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",7,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",7,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",7,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",7,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",7,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",7,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",7,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",7,[[["self"]],["option",["usize"]]]],[11,"complete_mul","","Calculates the multiplication of `self` and `other`.",7,N],[11,"complete_div","","Calculates both the quotient and the remainder when `self` is divided by `other`.",7,N],[11,"from_little_endian","","Convert from little-endian slice.",7,N],[11,"from_big_endian","","Convert from big-endian slice.",7,N],[11,"into_little_endian","","Convert into little-endian slice.",7,N],[11,"into_big_endian","","Convert into big-endian slice.",7,N],[11,"from_bin_str","","Convert from a binary string.",7,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_oct_str","","Convert from a octal string.",7,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_hex_str","","Convert from a hexadecimal string.",7,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_dec_str","","Convert from a decimal string.",7,[[["str"]],["result",["fixeduinterror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",7,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",7,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",7,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",7,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",7,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",7,[[["self"]],["u32"]]],[11,"checked_add","","Checked integer addition. Computes `self + rhs`, returning `None` if overflow occurred.",7,[[["self"],["self"]],["option"]]],[11,"checked_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",7,[[["self"],["self"]],["option"]]],[11,"checked_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",7,[[["self"],["self"]],["option"]]],[11,"checked_div","","Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`.",7,[[["self"],["self"]],["option"]]],[11,"checked_rem","","Checked integer remainder. Computes `self % rhs`, returning `None` if `rhs == 0`.",7,[[["self"],["self"]],["option"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",7,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",7,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",7,[[["self"]],["option"]]],[11,"saturating_add","","Saturating integer addition. Computes `self + rhs`, saturating at the numeric bounds instead of overflowing.",7,[[["self"],["self"]],["self"]]],[11,"saturating_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",7,[[["self"],["self"]],["self"]]],[11,"saturating_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",7,[[["self"],["self"]],["self"]]],[11,"overflowing_add","","Calculates `self + rhs`.",7,N],[11,"overflowing_sub","","Calculates `self - rhs`.",7,N],[11,"overflowing_mul","","Calculates the multiplication of `self` and `rhs`.",7,N],[11,"overflowing_div","","Calculates the divisor when `self` is divided by `rhs`.",7,N],[11,"overflowing_rem","","Calculates the remainder when `self` is divided by `rhs`.",7,N],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",7,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",7,N],[11,"overflowing_neg","","Negates `self` in an overflowing fashion.",7,N],[11,"random","","Create a random fixed uint with a input random core.",7,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",7,[[],["self"]]],[11,"clone","","",7,[[["self"]],["self"]]],[11,"default","","",7,[[],["self"]]],[11,"eq","","",7,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",7,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",7,[[["self"],["self"]],["ordering"]]],[11,"add","","",7,N],[11,"add_assign","","",7,[[["self"],["rhs"]]]],[11,"add","","",7,N],[11,"add_assign","","",7,[[["self"],["u1024"]]]],[11,"sub","","",7,N],[11,"sub_assign","","",7,[[["self"],["rhs"]]]],[11,"sub","","",7,N],[11,"sub_assign","","",7,[[["self"],["u1024"]]]],[11,"mul","","",7,N],[11,"mul_assign","","",7,[[["self"],["rhs"]]]],[11,"mul","","",7,N],[11,"mul_assign","","",7,[[["self"],["u1024"]]]],[11,"div","","",7,N],[11,"div_assign","","",7,[[["self"],["rhs"]]]],[11,"div","","",7,N],[11,"div_assign","","",7,[[["self"],["u1024"]]]],[11,"rem","","",7,N],[11,"rem_assign","","",7,[[["self"],["rhs"]]]],[11,"rem","","",7,N],[11,"rem_assign","","",7,[[["self"],["u1024"]]]],[11,"bitand","","",7,N],[11,"bitand_assign","","",7,[[["self"],["rhs"]]]],[11,"bitand","","",7,N],[11,"bitand_assign","","",7,[[["self"],["u1024"]]]],[11,"bitor","","",7,N],[11,"bitor_assign","","",7,[[["self"],["rhs"]]]],[11,"bitor","","",7,N],[11,"bitor_assign","","",7,[[["self"],["u1024"]]]],[11,"bitxor","","",7,N],[11,"bitxor_assign","","",7,[[["self"],["rhs"]]]],[11,"bitxor","","",7,N],[11,"bitxor_assign","","",7,[[["self"],["u1024"]]]],[11,"not","","",7,N],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["u8"]]]],[11,"shl_assign","","",7,[[["self"],["u8"]]]],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["u16"]]]],[11,"shl_assign","","",7,[[["self"],["u16"]]]],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["u32"]]]],[11,"shl_assign","","",7,[[["self"],["u32"]]]],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["u64"]]]],[11,"shl_assign","","",7,[[["self"],["u64"]]]],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["u128"]]]],[11,"shl_assign","","",7,[[["self"],["u128"]]]],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["usize"]]]],[11,"shl_assign","","",7,[[["self"],["usize"]]]],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["i8"]]]],[11,"shl_assign","","",7,[[["self"],["i8"]]]],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["i16"]]]],[11,"shl_assign","","",7,[[["self"],["i16"]]]],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["i32"]]]],[11,"shl_assign","","",7,[[["self"],["i32"]]]],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["i64"]]]],[11,"shl_assign","","",7,[[["self"],["i64"]]]],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["i128"]]]],[11,"shl_assign","","",7,[[["self"],["i128"]]]],[11,"shl","","",7,N],[11,"shl","","",7,N],[11,"shl_assign","","",7,[[["self"],["isize"]]]],[11,"shl_assign","","",7,[[["self"],["isize"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["u8"]]]],[11,"shr_assign","","",7,[[["self"],["u8"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["u16"]]]],[11,"shr_assign","","",7,[[["self"],["u16"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["u32"]]]],[11,"shr_assign","","",7,[[["self"],["u32"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["u64"]]]],[11,"shr_assign","","",7,[[["self"],["u64"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["u128"]]]],[11,"shr_assign","","",7,[[["self"],["u128"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["usize"]]]],[11,"shr_assign","","",7,[[["self"],["usize"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["i8"]]]],[11,"shr_assign","","",7,[[["self"],["i8"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["i16"]]]],[11,"shr_assign","","",7,[[["self"],["i16"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["i32"]]]],[11,"shr_assign","","",7,[[["self"],["i32"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["i64"]]]],[11,"shr_assign","","",7,[[["self"],["i64"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["i128"]]]],[11,"shr_assign","","",7,[[["self"],["i128"]]]],[11,"shr","","",7,N],[11,"shr","","",7,N],[11,"shr_assign","","",7,[[["self"],["isize"]]]],[11,"shr_assign","","",7,[[["self"],["isize"]]]],[11,"from","","",7,[[["bool"]],["self"]]],[11,"from","","",7,[[["u8"]],["self"]]],[11,"from","","",7,[[["u8"]],["self"]]],[11,"from","","",7,[[["u16"]],["self"]]],[11,"from","","",7,[[["u16"]],["self"]]],[11,"from","","",7,[[["u32"]],["self"]]],[11,"from","","",7,[[["u32"]],["self"]]],[11,"from","","",7,[[["u64"]],["self"]]],[11,"from","","",7,[[["u64"]],["self"]]],[11,"from","","",7,[[["u128"]],["self"]]],[11,"from","","",7,[[["u128"]],["self"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"hash","","",7,[[["self"],["h"]]]],[11,"sum","","",7,[[["i"]],["self"]]],[11,"sum","","",7,[[["i"]],["self"]]],[11,"product","","",7,[[["i"]],["self"]]],[11,"product","","",7,[[["i"]],["self"]]],[11,"as_byte_slice_mut","","",7,N],[11,"to_le","","",7,[[["self"]]]],[11,"convert_into","","",8,N],[11,"convert_into","","",0,N],[11,"convert_into","","",8,N],[11,"convert_into","","",1,N],[11,"convert_into","","",8,N],[11,"convert_into","","",2,N],[11,"convert_into","","",8,N],[11,"convert_into","","",3,N],[11,"convert_into","","",8,N],[11,"convert_into","","",4,N],[11,"convert_into","","",8,N],[11,"convert_into","","",5,N],[11,"convert_into","","",8,N],[11,"convert_into","","",6,N],[11,"convert_into","","",8,N],[11,"convert_into","","",7,N],[11,"zero","","Create a new fixed uint and value is zero.",8,[[],["self"]]],[11,"one","","Create a new fixed uint and value is zero.",8,[[],["self"]]],[11,"is_zero","","Test if a fixed uint is zero.",8,[[["self"]],["bool"]]],[11,"is_max","","Test if a fixed uint is the max value.",8,[[["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",8,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",8,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",8,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",8,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",8,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",8,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",8,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",8,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",8,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",8,[[["self"]],["option",["usize"]]]],[11,"complete_mul","","Calculates the multiplication of `self` and `other`.",8,N],[11,"complete_div","","Calculates both the quotient and the remainder when `self` is divided by `other`.",8,N],[11,"from_little_endian","","Convert from little-endian slice.",8,N],[11,"from_big_endian","","Convert from big-endian slice.",8,N],[11,"into_little_endian","","Convert into little-endian slice.",8,N],[11,"into_big_endian","","Convert into big-endian slice.",8,N],[11,"from_bin_str","","Convert from a binary string.",8,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_oct_str","","Convert from a octal string.",8,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_hex_str","","Convert from a hexadecimal string.",8,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_dec_str","","Convert from a decimal string.",8,[[["str"]],["result",["fixeduinterror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",8,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",8,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",8,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",8,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",8,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",8,[[["self"]],["u32"]]],[11,"checked_add","","Checked integer addition. Computes `self + rhs`, returning `None` if overflow occurred.",8,[[["self"],["self"]],["option"]]],[11,"checked_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",8,[[["self"],["self"]],["option"]]],[11,"checked_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",8,[[["self"],["self"]],["option"]]],[11,"checked_div","","Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`.",8,[[["self"],["self"]],["option"]]],[11,"checked_rem","","Checked integer remainder. Computes `self % rhs`, returning `None` if `rhs == 0`.",8,[[["self"],["self"]],["option"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",8,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",8,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",8,[[["self"]],["option"]]],[11,"saturating_add","","Saturating integer addition. Computes `self + rhs`, saturating at the numeric bounds instead of overflowing.",8,[[["self"],["self"]],["self"]]],[11,"saturating_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",8,[[["self"],["self"]],["self"]]],[11,"saturating_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",8,[[["self"],["self"]],["self"]]],[11,"overflowing_add","","Calculates `self + rhs`.",8,N],[11,"overflowing_sub","","Calculates `self - rhs`.",8,N],[11,"overflowing_mul","","Calculates the multiplication of `self` and `rhs`.",8,N],[11,"overflowing_div","","Calculates the divisor when `self` is divided by `rhs`.",8,N],[11,"overflowing_rem","","Calculates the remainder when `self` is divided by `rhs`.",8,N],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",8,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",8,N],[11,"overflowing_neg","","Negates `self` in an overflowing fashion.",8,N],[11,"random","","Create a random fixed uint with a input random core.",8,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",8,[[],["self"]]],[11,"clone","","",8,[[["self"]],["self"]]],[11,"default","","",8,[[],["self"]]],[11,"eq","","",8,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",8,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",8,[[["self"],["self"]],["ordering"]]],[11,"add","","",8,N],[11,"add_assign","","",8,[[["self"],["rhs"]]]],[11,"add","","",8,N],[11,"add_assign","","",8,[[["self"],["u2048"]]]],[11,"sub","","",8,N],[11,"sub_assign","","",8,[[["self"],["rhs"]]]],[11,"sub","","",8,N],[11,"sub_assign","","",8,[[["self"],["u2048"]]]],[11,"mul","","",8,N],[11,"mul_assign","","",8,[[["self"],["rhs"]]]],[11,"mul","","",8,N],[11,"mul_assign","","",8,[[["self"],["u2048"]]]],[11,"div","","",8,N],[11,"div_assign","","",8,[[["self"],["rhs"]]]],[11,"div","","",8,N],[11,"div_assign","","",8,[[["self"],["u2048"]]]],[11,"rem","","",8,N],[11,"rem_assign","","",8,[[["self"],["rhs"]]]],[11,"rem","","",8,N],[11,"rem_assign","","",8,[[["self"],["u2048"]]]],[11,"bitand","","",8,N],[11,"bitand_assign","","",8,[[["self"],["rhs"]]]],[11,"bitand","","",8,N],[11,"bitand_assign","","",8,[[["self"],["u2048"]]]],[11,"bitor","","",8,N],[11,"bitor_assign","","",8,[[["self"],["rhs"]]]],[11,"bitor","","",8,N],[11,"bitor_assign","","",8,[[["self"],["u2048"]]]],[11,"bitxor","","",8,N],[11,"bitxor_assign","","",8,[[["self"],["rhs"]]]],[11,"bitxor","","",8,N],[11,"bitxor_assign","","",8,[[["self"],["u2048"]]]],[11,"not","","",8,N],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["u8"]]]],[11,"shl_assign","","",8,[[["self"],["u8"]]]],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["u16"]]]],[11,"shl_assign","","",8,[[["self"],["u16"]]]],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["u32"]]]],[11,"shl_assign","","",8,[[["self"],["u32"]]]],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["u64"]]]],[11,"shl_assign","","",8,[[["self"],["u64"]]]],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["u128"]]]],[11,"shl_assign","","",8,[[["self"],["u128"]]]],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["usize"]]]],[11,"shl_assign","","",8,[[["self"],["usize"]]]],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["i8"]]]],[11,"shl_assign","","",8,[[["self"],["i8"]]]],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["i16"]]]],[11,"shl_assign","","",8,[[["self"],["i16"]]]],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["i32"]]]],[11,"shl_assign","","",8,[[["self"],["i32"]]]],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["i64"]]]],[11,"shl_assign","","",8,[[["self"],["i64"]]]],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["i128"]]]],[11,"shl_assign","","",8,[[["self"],["i128"]]]],[11,"shl","","",8,N],[11,"shl","","",8,N],[11,"shl_assign","","",8,[[["self"],["isize"]]]],[11,"shl_assign","","",8,[[["self"],["isize"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["u8"]]]],[11,"shr_assign","","",8,[[["self"],["u8"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["u16"]]]],[11,"shr_assign","","",8,[[["self"],["u16"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["u32"]]]],[11,"shr_assign","","",8,[[["self"],["u32"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["u64"]]]],[11,"shr_assign","","",8,[[["self"],["u64"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["u128"]]]],[11,"shr_assign","","",8,[[["self"],["u128"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["usize"]]]],[11,"shr_assign","","",8,[[["self"],["usize"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["i8"]]]],[11,"shr_assign","","",8,[[["self"],["i8"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["i16"]]]],[11,"shr_assign","","",8,[[["self"],["i16"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["i32"]]]],[11,"shr_assign","","",8,[[["self"],["i32"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["i64"]]]],[11,"shr_assign","","",8,[[["self"],["i64"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["i128"]]]],[11,"shr_assign","","",8,[[["self"],["i128"]]]],[11,"shr","","",8,N],[11,"shr","","",8,N],[11,"shr_assign","","",8,[[["self"],["isize"]]]],[11,"shr_assign","","",8,[[["self"],["isize"]]]],[11,"from","","",8,[[["bool"]],["self"]]],[11,"from","","",8,[[["u8"]],["self"]]],[11,"from","","",8,[[["u8"]],["self"]]],[11,"from","","",8,[[["u16"]],["self"]]],[11,"from","","",8,[[["u16"]],["self"]]],[11,"from","","",8,[[["u32"]],["self"]]],[11,"from","","",8,[[["u32"]],["self"]]],[11,"from","","",8,[[["u64"]],["self"]]],[11,"from","","",8,[[["u64"]],["self"]]],[11,"from","","",8,[[["u128"]],["self"]]],[11,"from","","",8,[[["u128"]],["self"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"hash","","",8,[[["self"],["h"]]]],[11,"sum","","",8,[[["i"]],["self"]]],[11,"sum","","",8,[[["i"]],["self"]]],[11,"product","","",8,[[["i"]],["self"]]],[11,"product","","",8,[[["i"]],["self"]]],[11,"as_byte_slice_mut","","",8,N],[11,"to_le","","",8,[[["self"]]]],[11,"convert_into","","",9,N],[11,"convert_into","","",0,N],[11,"convert_into","","",9,N],[11,"convert_into","","",1,N],[11,"convert_into","","",9,N],[11,"convert_into","","",2,N],[11,"convert_into","","",9,N],[11,"convert_into","","",3,N],[11,"convert_into","","",9,N],[11,"convert_into","","",4,N],[11,"convert_into","","",9,N],[11,"convert_into","","",5,N],[11,"convert_into","","",9,N],[11,"convert_into","","",6,N],[11,"convert_into","","",9,N],[11,"convert_into","","",7,N],[11,"convert_into","","",9,N],[11,"convert_into","","",8,N],[11,"zero","","Create a new fixed uint and value is zero.",9,[[],["self"]]],[11,"one","","Create a new fixed uint and value is zero.",9,[[],["self"]]],[11,"is_zero","","Test if a fixed uint is zero.",9,[[["self"]],["bool"]]],[11,"is_max","","Test if a fixed uint is the max value.",9,[[["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",9,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",9,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",9,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",9,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",9,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",9,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",9,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",9,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",9,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",9,[[["self"]],["option",["usize"]]]],[11,"complete_mul","","Calculates the multiplication of `self` and `other`.",9,N],[11,"complete_div","","Calculates both the quotient and the remainder when `self` is divided by `other`.",9,N],[11,"from_little_endian","","Convert from little-endian slice.",9,N],[11,"from_big_endian","","Convert from big-endian slice.",9,N],[11,"into_little_endian","","Convert into little-endian slice.",9,N],[11,"into_big_endian","","Convert into big-endian slice.",9,N],[11,"from_bin_str","","Convert from a binary string.",9,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_oct_str","","Convert from a octal string.",9,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_hex_str","","Convert from a hexadecimal string.",9,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_dec_str","","Convert from a decimal string.",9,[[["str"]],["result",["fixeduinterror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",9,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",9,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",9,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",9,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",9,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",9,[[["self"]],["u32"]]],[11,"checked_add","","Checked integer addition. Computes `self + rhs`, returning `None` if overflow occurred.",9,[[["self"],["self"]],["option"]]],[11,"checked_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",9,[[["self"],["self"]],["option"]]],[11,"checked_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",9,[[["self"],["self"]],["option"]]],[11,"checked_div","","Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`.",9,[[["self"],["self"]],["option"]]],[11,"checked_rem","","Checked integer remainder. Computes `self % rhs`, returning `None` if `rhs == 0`.",9,[[["self"],["self"]],["option"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",9,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",9,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",9,[[["self"]],["option"]]],[11,"saturating_add","","Saturating integer addition. Computes `self + rhs`, saturating at the numeric bounds instead of overflowing.",9,[[["self"],["self"]],["self"]]],[11,"saturating_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",9,[[["self"],["self"]],["self"]]],[11,"saturating_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",9,[[["self"],["self"]],["self"]]],[11,"overflowing_add","","Calculates `self + rhs`.",9,N],[11,"overflowing_sub","","Calculates `self - rhs`.",9,N],[11,"overflowing_mul","","Calculates the multiplication of `self` and `rhs`.",9,N],[11,"overflowing_div","","Calculates the divisor when `self` is divided by `rhs`.",9,N],[11,"overflowing_rem","","Calculates the remainder when `self` is divided by `rhs`.",9,N],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",9,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",9,N],[11,"overflowing_neg","","Negates `self` in an overflowing fashion.",9,N],[11,"random","","Create a random fixed uint with a input random core.",9,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",9,[[],["self"]]],[11,"clone","","",9,[[["self"]],["self"]]],[11,"default","","",9,[[],["self"]]],[11,"eq","","",9,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",9,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",9,[[["self"],["self"]],["ordering"]]],[11,"add","","",9,N],[11,"add_assign","","",9,[[["self"],["rhs"]]]],[11,"add","","",9,N],[11,"add_assign","","",9,[[["self"],["u4096"]]]],[11,"sub","","",9,N],[11,"sub_assign","","",9,[[["self"],["rhs"]]]],[11,"sub","","",9,N],[11,"sub_assign","","",9,[[["self"],["u4096"]]]],[11,"mul","","",9,N],[11,"mul_assign","","",9,[[["self"],["rhs"]]]],[11,"mul","","",9,N],[11,"mul_assign","","",9,[[["self"],["u4096"]]]],[11,"div","","",9,N],[11,"div_assign","","",9,[[["self"],["rhs"]]]],[11,"div","","",9,N],[11,"div_assign","","",9,[[["self"],["u4096"]]]],[11,"rem","","",9,N],[11,"rem_assign","","",9,[[["self"],["rhs"]]]],[11,"rem","","",9,N],[11,"rem_assign","","",9,[[["self"],["u4096"]]]],[11,"bitand","","",9,N],[11,"bitand_assign","","",9,[[["self"],["rhs"]]]],[11,"bitand","","",9,N],[11,"bitand_assign","","",9,[[["self"],["u4096"]]]],[11,"bitor","","",9,N],[11,"bitor_assign","","",9,[[["self"],["rhs"]]]],[11,"bitor","","",9,N],[11,"bitor_assign","","",9,[[["self"],["u4096"]]]],[11,"bitxor","","",9,N],[11,"bitxor_assign","","",9,[[["self"],["rhs"]]]],[11,"bitxor","","",9,N],[11,"bitxor_assign","","",9,[[["self"],["u4096"]]]],[11,"not","","",9,N],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["u8"]]]],[11,"shl_assign","","",9,[[["self"],["u8"]]]],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["u16"]]]],[11,"shl_assign","","",9,[[["self"],["u16"]]]],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["u32"]]]],[11,"shl_assign","","",9,[[["self"],["u32"]]]],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["u64"]]]],[11,"shl_assign","","",9,[[["self"],["u64"]]]],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["u128"]]]],[11,"shl_assign","","",9,[[["self"],["u128"]]]],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["usize"]]]],[11,"shl_assign","","",9,[[["self"],["usize"]]]],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["i8"]]]],[11,"shl_assign","","",9,[[["self"],["i8"]]]],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["i16"]]]],[11,"shl_assign","","",9,[[["self"],["i16"]]]],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["i32"]]]],[11,"shl_assign","","",9,[[["self"],["i32"]]]],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["i64"]]]],[11,"shl_assign","","",9,[[["self"],["i64"]]]],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["i128"]]]],[11,"shl_assign","","",9,[[["self"],["i128"]]]],[11,"shl","","",9,N],[11,"shl","","",9,N],[11,"shl_assign","","",9,[[["self"],["isize"]]]],[11,"shl_assign","","",9,[[["self"],["isize"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["u8"]]]],[11,"shr_assign","","",9,[[["self"],["u8"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["u16"]]]],[11,"shr_assign","","",9,[[["self"],["u16"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["u32"]]]],[11,"shr_assign","","",9,[[["self"],["u32"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["u64"]]]],[11,"shr_assign","","",9,[[["self"],["u64"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["u128"]]]],[11,"shr_assign","","",9,[[["self"],["u128"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["usize"]]]],[11,"shr_assign","","",9,[[["self"],["usize"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["i8"]]]],[11,"shr_assign","","",9,[[["self"],["i8"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["i16"]]]],[11,"shr_assign","","",9,[[["self"],["i16"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["i32"]]]],[11,"shr_assign","","",9,[[["self"],["i32"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["i64"]]]],[11,"shr_assign","","",9,[[["self"],["i64"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["i128"]]]],[11,"shr_assign","","",9,[[["self"],["i128"]]]],[11,"shr","","",9,N],[11,"shr","","",9,N],[11,"shr_assign","","",9,[[["self"],["isize"]]]],[11,"shr_assign","","",9,[[["self"],["isize"]]]],[11,"from","","",9,[[["bool"]],["self"]]],[11,"from","","",9,[[["u8"]],["self"]]],[11,"from","","",9,[[["u8"]],["self"]]],[11,"from","","",9,[[["u16"]],["self"]]],[11,"from","","",9,[[["u16"]],["self"]]],[11,"from","","",9,[[["u32"]],["self"]]],[11,"from","","",9,[[["u32"]],["self"]]],[11,"from","","",9,[[["u64"]],["self"]]],[11,"from","","",9,[[["u64"]],["self"]]],[11,"from","","",9,[[["u128"]],["self"]]],[11,"from","","",9,[[["u128"]],["self"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"hash","","",9,[[["self"],["h"]]]],[11,"sum","","",9,[[["i"]],["self"]]],[11,"sum","","",9,[[["i"]],["self"]]],[11,"product","","",9,[[["i"]],["self"]]],[11,"product","","",9,[[["i"]],["self"]]],[11,"as_byte_slice_mut","","",9,N],[11,"to_le","","",9,[[["self"]]]],[11,"convert_into","","",10,N],[11,"convert_into","","",0,N],[11,"convert_into","","",10,N],[11,"convert_into","","",1,N],[11,"convert_into","","",10,N],[11,"convert_into","","",2,N],[11,"convert_into","","",10,N],[11,"convert_into","","",3,N],[11,"convert_into","","",10,N],[11,"convert_into","","",4,N],[11,"convert_into","","",10,N],[11,"convert_into","","",5,N],[11,"convert_into","","",10,N],[11,"convert_into","","",6,N],[11,"convert_into","","",10,N],[11,"convert_into","","",7,N],[11,"convert_into","","",10,N],[11,"convert_into","","",8,N],[11,"convert_into","","",10,N],[11,"convert_into","","",9,N],[11,"zero","","Create a new fixed uint and value is zero.",10,[[],["self"]]],[11,"one","","Create a new fixed uint and value is zero.",10,[[],["self"]]],[11,"is_zero","","Test if a fixed uint is zero.",10,[[["self"]],["bool"]]],[11,"is_max","","Test if a fixed uint is the max value.",10,[[["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",10,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",10,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",10,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",10,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",10,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",10,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",10,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",10,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",10,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",10,[[["self"]],["option",["usize"]]]],[11,"complete_mul","","Calculates the multiplication of `self` and `other`.",10,N],[11,"complete_div","","Calculates both the quotient and the remainder when `self` is divided by `other`.",10,N],[11,"from_little_endian","","Convert from little-endian slice.",10,N],[11,"from_big_endian","","Convert from big-endian slice.",10,N],[11,"into_little_endian","","Convert into little-endian slice.",10,N],[11,"into_big_endian","","Convert into big-endian slice.",10,N],[11,"from_bin_str","","Convert from a binary string.",10,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_oct_str","","Convert from a octal string.",10,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_hex_str","","Convert from a hexadecimal string.",10,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_dec_str","","Convert from a decimal string.",10,[[["str"]],["result",["fixeduinterror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",10,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",10,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",10,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",10,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",10,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",10,[[["self"]],["u32"]]],[11,"checked_add","","Checked integer addition. Computes `self + rhs`, returning `None` if overflow occurred.",10,[[["self"],["self"]],["option"]]],[11,"checked_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",10,[[["self"],["self"]],["option"]]],[11,"checked_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",10,[[["self"],["self"]],["option"]]],[11,"checked_div","","Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`.",10,[[["self"],["self"]],["option"]]],[11,"checked_rem","","Checked integer remainder. Computes `self % rhs`, returning `None` if `rhs == 0`.",10,[[["self"],["self"]],["option"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",10,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",10,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",10,[[["self"]],["option"]]],[11,"saturating_add","","Saturating integer addition. Computes `self + rhs`, saturating at the numeric bounds instead of overflowing.",10,[[["self"],["self"]],["self"]]],[11,"saturating_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",10,[[["self"],["self"]],["self"]]],[11,"saturating_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",10,[[["self"],["self"]],["self"]]],[11,"overflowing_add","","Calculates `self + rhs`.",10,N],[11,"overflowing_sub","","Calculates `self - rhs`.",10,N],[11,"overflowing_mul","","Calculates the multiplication of `self` and `rhs`.",10,N],[11,"overflowing_div","","Calculates the divisor when `self` is divided by `rhs`.",10,N],[11,"overflowing_rem","","Calculates the remainder when `self` is divided by `rhs`.",10,N],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",10,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",10,N],[11,"overflowing_neg","","Negates `self` in an overflowing fashion.",10,N],[11,"random","","Create a random fixed uint with a input random core.",10,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",10,[[],["self"]]],[11,"clone","","",10,[[["self"]],["self"]]],[11,"default","","",10,[[],["self"]]],[11,"eq","","",10,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",10,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",10,[[["self"],["self"]],["ordering"]]],[11,"add","","",10,N],[11,"add_assign","","",10,[[["self"],["rhs"]]]],[11,"add","","",10,N],[11,"add_assign","","",10,[[["self"],["h128"]]]],[11,"sub","","",10,N],[11,"sub_assign","","",10,[[["self"],["rhs"]]]],[11,"sub","","",10,N],[11,"sub_assign","","",10,[[["self"],["h128"]]]],[11,"mul","","",10,N],[11,"mul_assign","","",10,[[["self"],["rhs"]]]],[11,"mul","","",10,N],[11,"mul_assign","","",10,[[["self"],["h128"]]]],[11,"div","","",10,N],[11,"div_assign","","",10,[[["self"],["rhs"]]]],[11,"div","","",10,N],[11,"div_assign","","",10,[[["self"],["h128"]]]],[11,"rem","","",10,N],[11,"rem_assign","","",10,[[["self"],["rhs"]]]],[11,"rem","","",10,N],[11,"rem_assign","","",10,[[["self"],["h128"]]]],[11,"bitand","","",10,N],[11,"bitand_assign","","",10,[[["self"],["rhs"]]]],[11,"bitand","","",10,N],[11,"bitand_assign","","",10,[[["self"],["h128"]]]],[11,"bitor","","",10,N],[11,"bitor_assign","","",10,[[["self"],["rhs"]]]],[11,"bitor","","",10,N],[11,"bitor_assign","","",10,[[["self"],["h128"]]]],[11,"bitxor","","",10,N],[11,"bitxor_assign","","",10,[[["self"],["rhs"]]]],[11,"bitxor","","",10,N],[11,"bitxor_assign","","",10,[[["self"],["h128"]]]],[11,"not","","",10,N],[11,"shl","","",10,N],[11,"shl","","",10,N],[11,"shl_assign","","",10,[[["self"],["u8"]]]],[11,"shl_assign","","",10,[[["self"],["u8"]]]],[11,"shl","","",10,N],[11,"shl","","",10,N],[11,"shl_assign","","",10,[[["self"],["u16"]]]],[11,"shl_assign","","",10,[[["self"],["u16"]]]],[11,"shl","","",10,N],[11,"shl","","",10,N],[11,"shl_assign","","",10,[[["self"],["u32"]]]],[11,"shl_assign","","",10,[[["self"],["u32"]]]],[11,"shl","","",10,N],[11,"shl","","",10,N],[11,"shl_assign","","",10,[[["self"],["u64"]]]],[11,"shl_assign","","",10,[[["self"],["u64"]]]],[11,"shl","","",10,N],[11,"shl","","",10,N],[11,"shl_assign","","",10,[[["self"],["u128"]]]],[11,"shl_assign","","",10,[[["self"],["u128"]]]],[11,"shl","","",10,N],[11,"shl","","",10,N],[11,"shl_assign","","",10,[[["self"],["usize"]]]],[11,"shl_assign","","",10,[[["self"],["usize"]]]],[11,"shl","","",10,N],[11,"shl","","",10,N],[11,"shl_assign","","",10,[[["self"],["i8"]]]],[11,"shl_assign","","",10,[[["self"],["i8"]]]],[11,"shl","","",10,N],[11,"shl","","",10,N],[11,"shl_assign","","",10,[[["self"],["i16"]]]],[11,"shl_assign","","",10,[[["self"],["i16"]]]],[11,"shl","","",10,N],[11,"shl","","",10,N],[11,"shl_assign","","",10,[[["self"],["i32"]]]],[11,"shl_assign","","",10,[[["self"],["i32"]]]],[11,"shl","","",10,N],[11,"shl","","",10,N],[11,"shl_assign","","",10,[[["self"],["i64"]]]],[11,"shl_assign","","",10,[[["self"],["i64"]]]],[11,"shl","","",10,N],[11,"shl","","",10,N],[11,"shl_assign","","",10,[[["self"],["i128"]]]],[11,"shl_assign","","",10,[[["self"],["i128"]]]],[11,"shl","","",10,N],[11,"shl","","",10,N],[11,"shl_assign","","",10,[[["self"],["isize"]]]],[11,"shl_assign","","",10,[[["self"],["isize"]]]],[11,"shr","","",10,N],[11,"shr","","",10,N],[11,"shr_assign","","",10,[[["self"],["u8"]]]],[11,"shr_assign","","",10,[[["self"],["u8"]]]],[11,"shr","","",10,N],[11,"shr","","",10,N],[11,"shr_assign","","",10,[[["self"],["u16"]]]],[11,"shr_assign","","",10,[[["self"],["u16"]]]],[11,"shr","","",10,N],[11,"shr","","",10,N],[11,"shr_assign","","",10,[[["self"],["u32"]]]],[11,"shr_assign","","",10,[[["self"],["u32"]]]],[11,"shr","","",10,N],[11,"shr","","",10,N],[11,"shr_assign","","",10,[[["self"],["u64"]]]],[11,"shr_assign","","",10,[[["self"],["u64"]]]],[11,"shr","","",10,N],[11,"shr","","",10,N],[11,"shr_assign","","",10,[[["self"],["u128"]]]],[11,"shr_assign","","",10,[[["self"],["u128"]]]],[11,"shr","","",10,N],[11,"shr","","",10,N],[11,"shr_assign","","",10,[[["self"],["usize"]]]],[11,"shr_assign","","",10,[[["self"],["usize"]]]],[11,"shr","","",10,N],[11,"shr","","",10,N],[11,"shr_assign","","",10,[[["self"],["i8"]]]],[11,"shr_assign","","",10,[[["self"],["i8"]]]],[11,"shr","","",10,N],[11,"shr","","",10,N],[11,"shr_assign","","",10,[[["self"],["i16"]]]],[11,"shr_assign","","",10,[[["self"],["i16"]]]],[11,"shr","","",10,N],[11,"shr","","",10,N],[11,"shr_assign","","",10,[[["self"],["i32"]]]],[11,"shr_assign","","",10,[[["self"],["i32"]]]],[11,"shr","","",10,N],[11,"shr","","",10,N],[11,"shr_assign","","",10,[[["self"],["i64"]]]],[11,"shr_assign","","",10,[[["self"],["i64"]]]],[11,"shr","","",10,N],[11,"shr","","",10,N],[11,"shr_assign","","",10,[[["self"],["i128"]]]],[11,"shr_assign","","",10,[[["self"],["i128"]]]],[11,"shr","","",10,N],[11,"shr","","",10,N],[11,"shr_assign","","",10,[[["self"],["isize"]]]],[11,"shr_assign","","",10,[[["self"],["isize"]]]],[11,"from","","",10,[[["bool"]],["self"]]],[11,"from","","",10,[[["u8"]],["self"]]],[11,"from","","",10,[[["u8"]],["self"]]],[11,"from","","",10,[[["u16"]],["self"]]],[11,"from","","",10,[[["u16"]],["self"]]],[11,"from","","",10,[[["u32"]],["self"]]],[11,"from","","",10,[[["u32"]],["self"]]],[11,"from","","",10,[[["u64"]],["self"]]],[11,"from","","",10,[[["u64"]],["self"]]],[11,"from","","",10,[[["u128"]],["self"]]],[11,"from","","",10,[[["u128"]],["self"]]],[11,"fmt","","",10,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",10,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",10,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",10,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",10,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",10,[[["self"],["formatter"]],["result"]]],[11,"hash","","",10,[[["self"],["h"]]]],[11,"sum","","",10,[[["i"]],["self"]]],[11,"sum","","",10,[[["i"]],["self"]]],[11,"product","","",10,[[["i"]],["self"]]],[11,"product","","",10,[[["i"]],["self"]]],[11,"as_byte_slice_mut","","",10,N],[11,"to_le","","",10,[[["self"]]]],[11,"convert_into","","",11,N],[11,"convert_into","","",0,N],[11,"convert_into","","",11,N],[11,"convert_into","","",1,N],[11,"convert_into","","",11,N],[11,"convert_into","","",2,N],[11,"convert_into","","",11,N],[11,"convert_into","","",3,N],[11,"convert_into","","",11,N],[11,"convert_into","","",4,N],[11,"convert_into","","",11,N],[11,"convert_into","","",5,N],[11,"convert_into","","",11,N],[11,"convert_into","","",6,N],[11,"convert_into","","",11,N],[11,"convert_into","","",7,N],[11,"convert_into","","",11,N],[11,"convert_into","","",8,N],[11,"convert_into","","",11,N],[11,"convert_into","","",9,N],[11,"convert_into","","",11,N],[11,"convert_into","","",10,N],[11,"zero","","Create a new fixed uint and value is zero.",11,[[],["self"]]],[11,"one","","Create a new fixed uint and value is zero.",11,[[],["self"]]],[11,"is_zero","","Test if a fixed uint is zero.",11,[[["self"]],["bool"]]],[11,"is_max","","Test if a fixed uint is the max value.",11,[[["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",11,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",11,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",11,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",11,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",11,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",11,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",11,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",11,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",11,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",11,[[["self"]],["option",["usize"]]]],[11,"complete_mul","","Calculates the multiplication of `self` and `other`.",11,N],[11,"complete_div","","Calculates both the quotient and the remainder when `self` is divided by `other`.",11,N],[11,"from_little_endian","","Convert from little-endian slice.",11,N],[11,"from_big_endian","","Convert from big-endian slice.",11,N],[11,"into_little_endian","","Convert into little-endian slice.",11,N],[11,"into_big_endian","","Convert into big-endian slice.",11,N],[11,"from_bin_str","","Convert from a binary string.",11,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_oct_str","","Convert from a octal string.",11,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_hex_str","","Convert from a hexadecimal string.",11,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_dec_str","","Convert from a decimal string.",11,[[["str"]],["result",["fixeduinterror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",11,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",11,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",11,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",11,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",11,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",11,[[["self"]],["u32"]]],[11,"checked_add","","Checked integer addition. Computes `self + rhs`, returning `None` if overflow occurred.",11,[[["self"],["self"]],["option"]]],[11,"checked_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",11,[[["self"],["self"]],["option"]]],[11,"checked_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",11,[[["self"],["self"]],["option"]]],[11,"checked_div","","Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`.",11,[[["self"],["self"]],["option"]]],[11,"checked_rem","","Checked integer remainder. Computes `self % rhs`, returning `None` if `rhs == 0`.",11,[[["self"],["self"]],["option"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",11,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",11,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",11,[[["self"]],["option"]]],[11,"saturating_add","","Saturating integer addition. Computes `self + rhs`, saturating at the numeric bounds instead of overflowing.",11,[[["self"],["self"]],["self"]]],[11,"saturating_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",11,[[["self"],["self"]],["self"]]],[11,"saturating_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",11,[[["self"],["self"]],["self"]]],[11,"overflowing_add","","Calculates `self + rhs`.",11,N],[11,"overflowing_sub","","Calculates `self - rhs`.",11,N],[11,"overflowing_mul","","Calculates the multiplication of `self` and `rhs`.",11,N],[11,"overflowing_div","","Calculates the divisor when `self` is divided by `rhs`.",11,N],[11,"overflowing_rem","","Calculates the remainder when `self` is divided by `rhs`.",11,N],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",11,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",11,N],[11,"overflowing_neg","","Negates `self` in an overflowing fashion.",11,N],[11,"random","","Create a random fixed uint with a input random core.",11,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",11,[[],["self"]]],[11,"clone","","",11,[[["self"]],["self"]]],[11,"default","","",11,[[],["self"]]],[11,"eq","","",11,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",11,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",11,[[["self"],["self"]],["ordering"]]],[11,"add","","",11,N],[11,"add_assign","","",11,[[["self"],["rhs"]]]],[11,"add","","",11,N],[11,"add_assign","","",11,[[["self"],["h160"]]]],[11,"sub","","",11,N],[11,"sub_assign","","",11,[[["self"],["rhs"]]]],[11,"sub","","",11,N],[11,"sub_assign","","",11,[[["self"],["h160"]]]],[11,"mul","","",11,N],[11,"mul_assign","","",11,[[["self"],["rhs"]]]],[11,"mul","","",11,N],[11,"mul_assign","","",11,[[["self"],["h160"]]]],[11,"div","","",11,N],[11,"div_assign","","",11,[[["self"],["rhs"]]]],[11,"div","","",11,N],[11,"div_assign","","",11,[[["self"],["h160"]]]],[11,"rem","","",11,N],[11,"rem_assign","","",11,[[["self"],["rhs"]]]],[11,"rem","","",11,N],[11,"rem_assign","","",11,[[["self"],["h160"]]]],[11,"bitand","","",11,N],[11,"bitand_assign","","",11,[[["self"],["rhs"]]]],[11,"bitand","","",11,N],[11,"bitand_assign","","",11,[[["self"],["h160"]]]],[11,"bitor","","",11,N],[11,"bitor_assign","","",11,[[["self"],["rhs"]]]],[11,"bitor","","",11,N],[11,"bitor_assign","","",11,[[["self"],["h160"]]]],[11,"bitxor","","",11,N],[11,"bitxor_assign","","",11,[[["self"],["rhs"]]]],[11,"bitxor","","",11,N],[11,"bitxor_assign","","",11,[[["self"],["h160"]]]],[11,"not","","",11,N],[11,"shl","","",11,N],[11,"shl","","",11,N],[11,"shl_assign","","",11,[[["self"],["u8"]]]],[11,"shl_assign","","",11,[[["self"],["u8"]]]],[11,"shl","","",11,N],[11,"shl","","",11,N],[11,"shl_assign","","",11,[[["self"],["u16"]]]],[11,"shl_assign","","",11,[[["self"],["u16"]]]],[11,"shl","","",11,N],[11,"shl","","",11,N],[11,"shl_assign","","",11,[[["self"],["u32"]]]],[11,"shl_assign","","",11,[[["self"],["u32"]]]],[11,"shl","","",11,N],[11,"shl","","",11,N],[11,"shl_assign","","",11,[[["self"],["u64"]]]],[11,"shl_assign","","",11,[[["self"],["u64"]]]],[11,"shl","","",11,N],[11,"shl","","",11,N],[11,"shl_assign","","",11,[[["self"],["u128"]]]],[11,"shl_assign","","",11,[[["self"],["u128"]]]],[11,"shl","","",11,N],[11,"shl","","",11,N],[11,"shl_assign","","",11,[[["self"],["usize"]]]],[11,"shl_assign","","",11,[[["self"],["usize"]]]],[11,"shl","","",11,N],[11,"shl","","",11,N],[11,"shl_assign","","",11,[[["self"],["i8"]]]],[11,"shl_assign","","",11,[[["self"],["i8"]]]],[11,"shl","","",11,N],[11,"shl","","",11,N],[11,"shl_assign","","",11,[[["self"],["i16"]]]],[11,"shl_assign","","",11,[[["self"],["i16"]]]],[11,"shl","","",11,N],[11,"shl","","",11,N],[11,"shl_assign","","",11,[[["self"],["i32"]]]],[11,"shl_assign","","",11,[[["self"],["i32"]]]],[11,"shl","","",11,N],[11,"shl","","",11,N],[11,"shl_assign","","",11,[[["self"],["i64"]]]],[11,"shl_assign","","",11,[[["self"],["i64"]]]],[11,"shl","","",11,N],[11,"shl","","",11,N],[11,"shl_assign","","",11,[[["self"],["i128"]]]],[11,"shl_assign","","",11,[[["self"],["i128"]]]],[11,"shl","","",11,N],[11,"shl","","",11,N],[11,"shl_assign","","",11,[[["self"],["isize"]]]],[11,"shl_assign","","",11,[[["self"],["isize"]]]],[11,"shr","","",11,N],[11,"shr","","",11,N],[11,"shr_assign","","",11,[[["self"],["u8"]]]],[11,"shr_assign","","",11,[[["self"],["u8"]]]],[11,"shr","","",11,N],[11,"shr","","",11,N],[11,"shr_assign","","",11,[[["self"],["u16"]]]],[11,"shr_assign","","",11,[[["self"],["u16"]]]],[11,"shr","","",11,N],[11,"shr","","",11,N],[11,"shr_assign","","",11,[[["self"],["u32"]]]],[11,"shr_assign","","",11,[[["self"],["u32"]]]],[11,"shr","","",11,N],[11,"shr","","",11,N],[11,"shr_assign","","",11,[[["self"],["u64"]]]],[11,"shr_assign","","",11,[[["self"],["u64"]]]],[11,"shr","","",11,N],[11,"shr","","",11,N],[11,"shr_assign","","",11,[[["self"],["u128"]]]],[11,"shr_assign","","",11,[[["self"],["u128"]]]],[11,"shr","","",11,N],[11,"shr","","",11,N],[11,"shr_assign","","",11,[[["self"],["usize"]]]],[11,"shr_assign","","",11,[[["self"],["usize"]]]],[11,"shr","","",11,N],[11,"shr","","",11,N],[11,"shr_assign","","",11,[[["self"],["i8"]]]],[11,"shr_assign","","",11,[[["self"],["i8"]]]],[11,"shr","","",11,N],[11,"shr","","",11,N],[11,"shr_assign","","",11,[[["self"],["i16"]]]],[11,"shr_assign","","",11,[[["self"],["i16"]]]],[11,"shr","","",11,N],[11,"shr","","",11,N],[11,"shr_assign","","",11,[[["self"],["i32"]]]],[11,"shr_assign","","",11,[[["self"],["i32"]]]],[11,"shr","","",11,N],[11,"shr","","",11,N],[11,"shr_assign","","",11,[[["self"],["i64"]]]],[11,"shr_assign","","",11,[[["self"],["i64"]]]],[11,"shr","","",11,N],[11,"shr","","",11,N],[11,"shr_assign","","",11,[[["self"],["i128"]]]],[11,"shr_assign","","",11,[[["self"],["i128"]]]],[11,"shr","","",11,N],[11,"shr","","",11,N],[11,"shr_assign","","",11,[[["self"],["isize"]]]],[11,"shr_assign","","",11,[[["self"],["isize"]]]],[11,"from","","",11,[[["bool"]],["self"]]],[11,"from","","",11,[[["u8"]],["self"]]],[11,"from","","",11,[[["u8"]],["self"]]],[11,"from","","",11,[[["u16"]],["self"]]],[11,"from","","",11,[[["u16"]],["self"]]],[11,"from","","",11,[[["u32"]],["self"]]],[11,"from","","",11,[[["u32"]],["self"]]],[11,"from","","",11,[[["u64"]],["self"]]],[11,"from","","",11,[[["u64"]],["self"]]],[11,"from","","",11,[[["u128"]],["self"]]],[11,"from","","",11,[[["u128"]],["self"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"hash","","",11,[[["self"],["h"]]]],[11,"sum","","",11,[[["i"]],["self"]]],[11,"sum","","",11,[[["i"]],["self"]]],[11,"product","","",11,[[["i"]],["self"]]],[11,"product","","",11,[[["i"]],["self"]]],[11,"as_byte_slice_mut","","",11,N],[11,"to_le","","",11,[[["self"]]]],[11,"convert_into","","",12,N],[11,"convert_into","","",0,N],[11,"convert_into","","",12,N],[11,"convert_into","","",1,N],[11,"convert_into","","",12,N],[11,"convert_into","","",2,N],[11,"convert_into","","",12,N],[11,"convert_into","","",3,N],[11,"convert_into","","",12,N],[11,"convert_into","","",4,N],[11,"convert_into","","",12,N],[11,"convert_into","","",5,N],[11,"convert_into","","",12,N],[11,"convert_into","","",6,N],[11,"convert_into","","",12,N],[11,"convert_into","","",7,N],[11,"convert_into","","",12,N],[11,"convert_into","","",8,N],[11,"convert_into","","",12,N],[11,"convert_into","","",9,N],[11,"convert_into","","",12,N],[11,"convert_into","","",10,N],[11,"convert_into","","",12,N],[11,"convert_into","","",11,N],[11,"zero","","Create a new fixed uint and value is zero.",12,[[],["self"]]],[11,"one","","Create a new fixed uint and value is zero.",12,[[],["self"]]],[11,"is_zero","","Test if a fixed uint is zero.",12,[[["self"]],["bool"]]],[11,"is_max","","Test if a fixed uint is the max value.",12,[[["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",12,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",12,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",12,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",12,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",12,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",12,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",12,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",12,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",12,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",12,[[["self"]],["option",["usize"]]]],[11,"complete_mul","","Calculates the multiplication of `self` and `other`.",12,N],[11,"complete_div","","Calculates both the quotient and the remainder when `self` is divided by `other`.",12,N],[11,"from_little_endian","","Convert from little-endian slice.",12,N],[11,"from_big_endian","","Convert from big-endian slice.",12,N],[11,"into_little_endian","","Convert into little-endian slice.",12,N],[11,"into_big_endian","","Convert into big-endian slice.",12,N],[11,"from_bin_str","","Convert from a binary string.",12,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_oct_str","","Convert from a octal string.",12,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_hex_str","","Convert from a hexadecimal string.",12,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_dec_str","","Convert from a decimal string.",12,[[["str"]],["result",["fixeduinterror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",12,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",12,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",12,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",12,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",12,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",12,[[["self"]],["u32"]]],[11,"checked_add","","Checked integer addition. Computes `self + rhs`, returning `None` if overflow occurred.",12,[[["self"],["self"]],["option"]]],[11,"checked_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",12,[[["self"],["self"]],["option"]]],[11,"checked_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",12,[[["self"],["self"]],["option"]]],[11,"checked_div","","Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`.",12,[[["self"],["self"]],["option"]]],[11,"checked_rem","","Checked integer remainder. Computes `self % rhs`, returning `None` if `rhs == 0`.",12,[[["self"],["self"]],["option"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",12,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",12,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",12,[[["self"]],["option"]]],[11,"saturating_add","","Saturating integer addition. Computes `self + rhs`, saturating at the numeric bounds instead of overflowing.",12,[[["self"],["self"]],["self"]]],[11,"saturating_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",12,[[["self"],["self"]],["self"]]],[11,"saturating_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",12,[[["self"],["self"]],["self"]]],[11,"overflowing_add","","Calculates `self + rhs`.",12,N],[11,"overflowing_sub","","Calculates `self - rhs`.",12,N],[11,"overflowing_mul","","Calculates the multiplication of `self` and `rhs`.",12,N],[11,"overflowing_div","","Calculates the divisor when `self` is divided by `rhs`.",12,N],[11,"overflowing_rem","","Calculates the remainder when `self` is divided by `rhs`.",12,N],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",12,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",12,N],[11,"overflowing_neg","","Negates `self` in an overflowing fashion.",12,N],[11,"random","","Create a random fixed uint with a input random core.",12,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",12,[[],["self"]]],[11,"clone","","",12,[[["self"]],["self"]]],[11,"default","","",12,[[],["self"]]],[11,"eq","","",12,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",12,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",12,[[["self"],["self"]],["ordering"]]],[11,"add","","",12,N],[11,"add_assign","","",12,[[["self"],["rhs"]]]],[11,"add","","",12,N],[11,"add_assign","","",12,[[["self"],["h224"]]]],[11,"sub","","",12,N],[11,"sub_assign","","",12,[[["self"],["rhs"]]]],[11,"sub","","",12,N],[11,"sub_assign","","",12,[[["self"],["h224"]]]],[11,"mul","","",12,N],[11,"mul_assign","","",12,[[["self"],["rhs"]]]],[11,"mul","","",12,N],[11,"mul_assign","","",12,[[["self"],["h224"]]]],[11,"div","","",12,N],[11,"div_assign","","",12,[[["self"],["rhs"]]]],[11,"div","","",12,N],[11,"div_assign","","",12,[[["self"],["h224"]]]],[11,"rem","","",12,N],[11,"rem_assign","","",12,[[["self"],["rhs"]]]],[11,"rem","","",12,N],[11,"rem_assign","","",12,[[["self"],["h224"]]]],[11,"bitand","","",12,N],[11,"bitand_assign","","",12,[[["self"],["rhs"]]]],[11,"bitand","","",12,N],[11,"bitand_assign","","",12,[[["self"],["h224"]]]],[11,"bitor","","",12,N],[11,"bitor_assign","","",12,[[["self"],["rhs"]]]],[11,"bitor","","",12,N],[11,"bitor_assign","","",12,[[["self"],["h224"]]]],[11,"bitxor","","",12,N],[11,"bitxor_assign","","",12,[[["self"],["rhs"]]]],[11,"bitxor","","",12,N],[11,"bitxor_assign","","",12,[[["self"],["h224"]]]],[11,"not","","",12,N],[11,"shl","","",12,N],[11,"shl","","",12,N],[11,"shl_assign","","",12,[[["self"],["u8"]]]],[11,"shl_assign","","",12,[[["self"],["u8"]]]],[11,"shl","","",12,N],[11,"shl","","",12,N],[11,"shl_assign","","",12,[[["self"],["u16"]]]],[11,"shl_assign","","",12,[[["self"],["u16"]]]],[11,"shl","","",12,N],[11,"shl","","",12,N],[11,"shl_assign","","",12,[[["self"],["u32"]]]],[11,"shl_assign","","",12,[[["self"],["u32"]]]],[11,"shl","","",12,N],[11,"shl","","",12,N],[11,"shl_assign","","",12,[[["self"],["u64"]]]],[11,"shl_assign","","",12,[[["self"],["u64"]]]],[11,"shl","","",12,N],[11,"shl","","",12,N],[11,"shl_assign","","",12,[[["self"],["u128"]]]],[11,"shl_assign","","",12,[[["self"],["u128"]]]],[11,"shl","","",12,N],[11,"shl","","",12,N],[11,"shl_assign","","",12,[[["self"],["usize"]]]],[11,"shl_assign","","",12,[[["self"],["usize"]]]],[11,"shl","","",12,N],[11,"shl","","",12,N],[11,"shl_assign","","",12,[[["self"],["i8"]]]],[11,"shl_assign","","",12,[[["self"],["i8"]]]],[11,"shl","","",12,N],[11,"shl","","",12,N],[11,"shl_assign","","",12,[[["self"],["i16"]]]],[11,"shl_assign","","",12,[[["self"],["i16"]]]],[11,"shl","","",12,N],[11,"shl","","",12,N],[11,"shl_assign","","",12,[[["self"],["i32"]]]],[11,"shl_assign","","",12,[[["self"],["i32"]]]],[11,"shl","","",12,N],[11,"shl","","",12,N],[11,"shl_assign","","",12,[[["self"],["i64"]]]],[11,"shl_assign","","",12,[[["self"],["i64"]]]],[11,"shl","","",12,N],[11,"shl","","",12,N],[11,"shl_assign","","",12,[[["self"],["i128"]]]],[11,"shl_assign","","",12,[[["self"],["i128"]]]],[11,"shl","","",12,N],[11,"shl","","",12,N],[11,"shl_assign","","",12,[[["self"],["isize"]]]],[11,"shl_assign","","",12,[[["self"],["isize"]]]],[11,"shr","","",12,N],[11,"shr","","",12,N],[11,"shr_assign","","",12,[[["self"],["u8"]]]],[11,"shr_assign","","",12,[[["self"],["u8"]]]],[11,"shr","","",12,N],[11,"shr","","",12,N],[11,"shr_assign","","",12,[[["self"],["u16"]]]],[11,"shr_assign","","",12,[[["self"],["u16"]]]],[11,"shr","","",12,N],[11,"shr","","",12,N],[11,"shr_assign","","",12,[[["self"],["u32"]]]],[11,"shr_assign","","",12,[[["self"],["u32"]]]],[11,"shr","","",12,N],[11,"shr","","",12,N],[11,"shr_assign","","",12,[[["self"],["u64"]]]],[11,"shr_assign","","",12,[[["self"],["u64"]]]],[11,"shr","","",12,N],[11,"shr","","",12,N],[11,"shr_assign","","",12,[[["self"],["u128"]]]],[11,"shr_assign","","",12,[[["self"],["u128"]]]],[11,"shr","","",12,N],[11,"shr","","",12,N],[11,"shr_assign","","",12,[[["self"],["usize"]]]],[11,"shr_assign","","",12,[[["self"],["usize"]]]],[11,"shr","","",12,N],[11,"shr","","",12,N],[11,"shr_assign","","",12,[[["self"],["i8"]]]],[11,"shr_assign","","",12,[[["self"],["i8"]]]],[11,"shr","","",12,N],[11,"shr","","",12,N],[11,"shr_assign","","",12,[[["self"],["i16"]]]],[11,"shr_assign","","",12,[[["self"],["i16"]]]],[11,"shr","","",12,N],[11,"shr","","",12,N],[11,"shr_assign","","",12,[[["self"],["i32"]]]],[11,"shr_assign","","",12,[[["self"],["i32"]]]],[11,"shr","","",12,N],[11,"shr","","",12,N],[11,"shr_assign","","",12,[[["self"],["i64"]]]],[11,"shr_assign","","",12,[[["self"],["i64"]]]],[11,"shr","","",12,N],[11,"shr","","",12,N],[11,"shr_assign","","",12,[[["self"],["i128"]]]],[11,"shr_assign","","",12,[[["self"],["i128"]]]],[11,"shr","","",12,N],[11,"shr","","",12,N],[11,"shr_assign","","",12,[[["self"],["isize"]]]],[11,"shr_assign","","",12,[[["self"],["isize"]]]],[11,"from","","",12,[[["bool"]],["self"]]],[11,"from","","",12,[[["u8"]],["self"]]],[11,"from","","",12,[[["u8"]],["self"]]],[11,"from","","",12,[[["u16"]],["self"]]],[11,"from","","",12,[[["u16"]],["self"]]],[11,"from","","",12,[[["u32"]],["self"]]],[11,"from","","",12,[[["u32"]],["self"]]],[11,"from","","",12,[[["u64"]],["self"]]],[11,"from","","",12,[[["u64"]],["self"]]],[11,"from","","",12,[[["u128"]],["self"]]],[11,"from","","",12,[[["u128"]],["self"]]],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"hash","","",12,[[["self"],["h"]]]],[11,"sum","","",12,[[["i"]],["self"]]],[11,"sum","","",12,[[["i"]],["self"]]],[11,"product","","",12,[[["i"]],["self"]]],[11,"product","","",12,[[["i"]],["self"]]],[11,"as_byte_slice_mut","","",12,N],[11,"to_le","","",12,[[["self"]]]],[11,"convert_into","","",13,N],[11,"convert_into","","",0,N],[11,"convert_into","","",13,N],[11,"convert_into","","",1,N],[11,"convert_into","","",13,N],[11,"convert_into","","",2,N],[11,"convert_into","","",13,N],[11,"convert_into","","",3,N],[11,"convert_into","","",13,N],[11,"convert_into","","",4,N],[11,"convert_into","","",13,N],[11,"convert_into","","",5,N],[11,"convert_into","","",13,N],[11,"convert_into","","",6,N],[11,"convert_into","","",13,N],[11,"convert_into","","",7,N],[11,"convert_into","","",13,N],[11,"convert_into","","",8,N],[11,"convert_into","","",13,N],[11,"convert_into","","",9,N],[11,"convert_into","","",13,N],[11,"convert_into","","",10,N],[11,"convert_into","","",13,N],[11,"convert_into","","",11,N],[11,"convert_into","","",13,N],[11,"convert_into","","",12,N],[11,"zero","","Create a new fixed uint and value is zero.",13,[[],["self"]]],[11,"one","","Create a new fixed uint and value is zero.",13,[[],["self"]]],[11,"is_zero","","Test if a fixed uint is zero.",13,[[["self"]],["bool"]]],[11,"is_max","","Test if a fixed uint is the max value.",13,[[["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",13,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",13,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",13,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",13,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",13,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",13,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",13,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",13,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",13,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",13,[[["self"]],["option",["usize"]]]],[11,"complete_mul","","Calculates the multiplication of `self` and `other`.",13,N],[11,"complete_div","","Calculates both the quotient and the remainder when `self` is divided by `other`.",13,N],[11,"from_little_endian","","Convert from little-endian slice.",13,N],[11,"from_big_endian","","Convert from big-endian slice.",13,N],[11,"into_little_endian","","Convert into little-endian slice.",13,N],[11,"into_big_endian","","Convert into big-endian slice.",13,N],[11,"from_bin_str","","Convert from a binary string.",13,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_oct_str","","Convert from a octal string.",13,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_hex_str","","Convert from a hexadecimal string.",13,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_dec_str","","Convert from a decimal string.",13,[[["str"]],["result",["fixeduinterror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",13,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",13,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",13,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",13,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",13,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",13,[[["self"]],["u32"]]],[11,"checked_add","","Checked integer addition. Computes `self + rhs`, returning `None` if overflow occurred.",13,[[["self"],["self"]],["option"]]],[11,"checked_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",13,[[["self"],["self"]],["option"]]],[11,"checked_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",13,[[["self"],["self"]],["option"]]],[11,"checked_div","","Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`.",13,[[["self"],["self"]],["option"]]],[11,"checked_rem","","Checked integer remainder. Computes `self % rhs`, returning `None` if `rhs == 0`.",13,[[["self"],["self"]],["option"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",13,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",13,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",13,[[["self"]],["option"]]],[11,"saturating_add","","Saturating integer addition. Computes `self + rhs`, saturating at the numeric bounds instead of overflowing.",13,[[["self"],["self"]],["self"]]],[11,"saturating_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",13,[[["self"],["self"]],["self"]]],[11,"saturating_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",13,[[["self"],["self"]],["self"]]],[11,"overflowing_add","","Calculates `self + rhs`.",13,N],[11,"overflowing_sub","","Calculates `self - rhs`.",13,N],[11,"overflowing_mul","","Calculates the multiplication of `self` and `rhs`.",13,N],[11,"overflowing_div","","Calculates the divisor when `self` is divided by `rhs`.",13,N],[11,"overflowing_rem","","Calculates the remainder when `self` is divided by `rhs`.",13,N],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",13,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",13,N],[11,"overflowing_neg","","Negates `self` in an overflowing fashion.",13,N],[11,"random","","Create a random fixed uint with a input random core.",13,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",13,[[],["self"]]],[11,"clone","","",13,[[["self"]],["self"]]],[11,"default","","",13,[[],["self"]]],[11,"eq","","",13,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",13,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",13,[[["self"],["self"]],["ordering"]]],[11,"add","","",13,N],[11,"add_assign","","",13,[[["self"],["rhs"]]]],[11,"add","","",13,N],[11,"add_assign","","",13,[[["self"],["h256"]]]],[11,"sub","","",13,N],[11,"sub_assign","","",13,[[["self"],["rhs"]]]],[11,"sub","","",13,N],[11,"sub_assign","","",13,[[["self"],["h256"]]]],[11,"mul","","",13,N],[11,"mul_assign","","",13,[[["self"],["rhs"]]]],[11,"mul","","",13,N],[11,"mul_assign","","",13,[[["self"],["h256"]]]],[11,"div","","",13,N],[11,"div_assign","","",13,[[["self"],["rhs"]]]],[11,"div","","",13,N],[11,"div_assign","","",13,[[["self"],["h256"]]]],[11,"rem","","",13,N],[11,"rem_assign","","",13,[[["self"],["rhs"]]]],[11,"rem","","",13,N],[11,"rem_assign","","",13,[[["self"],["h256"]]]],[11,"bitand","","",13,N],[11,"bitand_assign","","",13,[[["self"],["rhs"]]]],[11,"bitand","","",13,N],[11,"bitand_assign","","",13,[[["self"],["h256"]]]],[11,"bitor","","",13,N],[11,"bitor_assign","","",13,[[["self"],["rhs"]]]],[11,"bitor","","",13,N],[11,"bitor_assign","","",13,[[["self"],["h256"]]]],[11,"bitxor","","",13,N],[11,"bitxor_assign","","",13,[[["self"],["rhs"]]]],[11,"bitxor","","",13,N],[11,"bitxor_assign","","",13,[[["self"],["h256"]]]],[11,"not","","",13,N],[11,"shl","","",13,N],[11,"shl","","",13,N],[11,"shl_assign","","",13,[[["self"],["u8"]]]],[11,"shl_assign","","",13,[[["self"],["u8"]]]],[11,"shl","","",13,N],[11,"shl","","",13,N],[11,"shl_assign","","",13,[[["self"],["u16"]]]],[11,"shl_assign","","",13,[[["self"],["u16"]]]],[11,"shl","","",13,N],[11,"shl","","",13,N],[11,"shl_assign","","",13,[[["self"],["u32"]]]],[11,"shl_assign","","",13,[[["self"],["u32"]]]],[11,"shl","","",13,N],[11,"shl","","",13,N],[11,"shl_assign","","",13,[[["self"],["u64"]]]],[11,"shl_assign","","",13,[[["self"],["u64"]]]],[11,"shl","","",13,N],[11,"shl","","",13,N],[11,"shl_assign","","",13,[[["self"],["u128"]]]],[11,"shl_assign","","",13,[[["self"],["u128"]]]],[11,"shl","","",13,N],[11,"shl","","",13,N],[11,"shl_assign","","",13,[[["self"],["usize"]]]],[11,"shl_assign","","",13,[[["self"],["usize"]]]],[11,"shl","","",13,N],[11,"shl","","",13,N],[11,"shl_assign","","",13,[[["self"],["i8"]]]],[11,"shl_assign","","",13,[[["self"],["i8"]]]],[11,"shl","","",13,N],[11,"shl","","",13,N],[11,"shl_assign","","",13,[[["self"],["i16"]]]],[11,"shl_assign","","",13,[[["self"],["i16"]]]],[11,"shl","","",13,N],[11,"shl","","",13,N],[11,"shl_assign","","",13,[[["self"],["i32"]]]],[11,"shl_assign","","",13,[[["self"],["i32"]]]],[11,"shl","","",13,N],[11,"shl","","",13,N],[11,"shl_assign","","",13,[[["self"],["i64"]]]],[11,"shl_assign","","",13,[[["self"],["i64"]]]],[11,"shl","","",13,N],[11,"shl","","",13,N],[11,"shl_assign","","",13,[[["self"],["i128"]]]],[11,"shl_assign","","",13,[[["self"],["i128"]]]],[11,"shl","","",13,N],[11,"shl","","",13,N],[11,"shl_assign","","",13,[[["self"],["isize"]]]],[11,"shl_assign","","",13,[[["self"],["isize"]]]],[11,"shr","","",13,N],[11,"shr","","",13,N],[11,"shr_assign","","",13,[[["self"],["u8"]]]],[11,"shr_assign","","",13,[[["self"],["u8"]]]],[11,"shr","","",13,N],[11,"shr","","",13,N],[11,"shr_assign","","",13,[[["self"],["u16"]]]],[11,"shr_assign","","",13,[[["self"],["u16"]]]],[11,"shr","","",13,N],[11,"shr","","",13,N],[11,"shr_assign","","",13,[[["self"],["u32"]]]],[11,"shr_assign","","",13,[[["self"],["u32"]]]],[11,"shr","","",13,N],[11,"shr","","",13,N],[11,"shr_assign","","",13,[[["self"],["u64"]]]],[11,"shr_assign","","",13,[[["self"],["u64"]]]],[11,"shr","","",13,N],[11,"shr","","",13,N],[11,"shr_assign","","",13,[[["self"],["u128"]]]],[11,"shr_assign","","",13,[[["self"],["u128"]]]],[11,"shr","","",13,N],[11,"shr","","",13,N],[11,"shr_assign","","",13,[[["self"],["usize"]]]],[11,"shr_assign","","",13,[[["self"],["usize"]]]],[11,"shr","","",13,N],[11,"shr","","",13,N],[11,"shr_assign","","",13,[[["self"],["i8"]]]],[11,"shr_assign","","",13,[[["self"],["i8"]]]],[11,"shr","","",13,N],[11,"shr","","",13,N],[11,"shr_assign","","",13,[[["self"],["i16"]]]],[11,"shr_assign","","",13,[[["self"],["i16"]]]],[11,"shr","","",13,N],[11,"shr","","",13,N],[11,"shr_assign","","",13,[[["self"],["i32"]]]],[11,"shr_assign","","",13,[[["self"],["i32"]]]],[11,"shr","","",13,N],[11,"shr","","",13,N],[11,"shr_assign","","",13,[[["self"],["i64"]]]],[11,"shr_assign","","",13,[[["self"],["i64"]]]],[11,"shr","","",13,N],[11,"shr","","",13,N],[11,"shr_assign","","",13,[[["self"],["i128"]]]],[11,"shr_assign","","",13,[[["self"],["i128"]]]],[11,"shr","","",13,N],[11,"shr","","",13,N],[11,"shr_assign","","",13,[[["self"],["isize"]]]],[11,"shr_assign","","",13,[[["self"],["isize"]]]],[11,"from","","",13,[[["bool"]],["self"]]],[11,"from","","",13,[[["u8"]],["self"]]],[11,"from","","",13,[[["u8"]],["self"]]],[11,"from","","",13,[[["u16"]],["self"]]],[11,"from","","",13,[[["u16"]],["self"]]],[11,"from","","",13,[[["u32"]],["self"]]],[11,"from","","",13,[[["u32"]],["self"]]],[11,"from","","",13,[[["u64"]],["self"]]],[11,"from","","",13,[[["u64"]],["self"]]],[11,"from","","",13,[[["u128"]],["self"]]],[11,"from","","",13,[[["u128"]],["self"]]],[11,"fmt","","",13,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",13,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",13,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",13,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",13,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",13,[[["self"],["formatter"]],["result"]]],[11,"hash","","",13,[[["self"],["h"]]]],[11,"sum","","",13,[[["i"]],["self"]]],[11,"sum","","",13,[[["i"]],["self"]]],[11,"product","","",13,[[["i"]],["self"]]],[11,"product","","",13,[[["i"]],["self"]]],[11,"as_byte_slice_mut","","",13,N],[11,"to_le","","",13,[[["self"]]]],[11,"convert_into","","",14,N],[11,"convert_into","","",0,N],[11,"convert_into","","",14,N],[11,"convert_into","","",1,N],[11,"convert_into","","",14,N],[11,"convert_into","","",2,N],[11,"convert_into","","",14,N],[11,"convert_into","","",3,N],[11,"convert_into","","",14,N],[11,"convert_into","","",4,N],[11,"convert_into","","",14,N],[11,"convert_into","","",5,N],[11,"convert_into","","",14,N],[11,"convert_into","","",6,N],[11,"convert_into","","",14,N],[11,"convert_into","","",7,N],[11,"convert_into","","",14,N],[11,"convert_into","","",8,N],[11,"convert_into","","",14,N],[11,"convert_into","","",9,N],[11,"convert_into","","",14,N],[11,"convert_into","","",10,N],[11,"convert_into","","",14,N],[11,"convert_into","","",11,N],[11,"convert_into","","",14,N],[11,"convert_into","","",12,N],[11,"convert_into","","",14,N],[11,"convert_into","","",13,N],[11,"zero","","Create a new fixed uint and value is zero.",14,[[],["self"]]],[11,"one","","Create a new fixed uint and value is zero.",14,[[],["self"]]],[11,"is_zero","","Test if a fixed uint is zero.",14,[[["self"]],["bool"]]],[11,"is_max","","Test if a fixed uint is the max value.",14,[[["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",14,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",14,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",14,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",14,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",14,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",14,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",14,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",14,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",14,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",14,[[["self"]],["option",["usize"]]]],[11,"complete_mul","","Calculates the multiplication of `self` and `other`.",14,N],[11,"complete_div","","Calculates both the quotient and the remainder when `self` is divided by `other`.",14,N],[11,"from_little_endian","","Convert from little-endian slice.",14,N],[11,"from_big_endian","","Convert from big-endian slice.",14,N],[11,"into_little_endian","","Convert into little-endian slice.",14,N],[11,"into_big_endian","","Convert into big-endian slice.",14,N],[11,"from_bin_str","","Convert from a binary string.",14,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_oct_str","","Convert from a octal string.",14,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_hex_str","","Convert from a hexadecimal string.",14,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_dec_str","","Convert from a decimal string.",14,[[["str"]],["result",["fixeduinterror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",14,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",14,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",14,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",14,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",14,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",14,[[["self"]],["u32"]]],[11,"checked_add","","Checked integer addition. Computes `self + rhs`, returning `None` if overflow occurred.",14,[[["self"],["self"]],["option"]]],[11,"checked_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",14,[[["self"],["self"]],["option"]]],[11,"checked_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",14,[[["self"],["self"]],["option"]]],[11,"checked_div","","Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`.",14,[[["self"],["self"]],["option"]]],[11,"checked_rem","","Checked integer remainder. Computes `self % rhs`, returning `None` if `rhs == 0`.",14,[[["self"],["self"]],["option"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",14,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",14,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",14,[[["self"]],["option"]]],[11,"saturating_add","","Saturating integer addition. Computes `self + rhs`, saturating at the numeric bounds instead of overflowing.",14,[[["self"],["self"]],["self"]]],[11,"saturating_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",14,[[["self"],["self"]],["self"]]],[11,"saturating_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",14,[[["self"],["self"]],["self"]]],[11,"overflowing_add","","Calculates `self + rhs`.",14,N],[11,"overflowing_sub","","Calculates `self - rhs`.",14,N],[11,"overflowing_mul","","Calculates the multiplication of `self` and `rhs`.",14,N],[11,"overflowing_div","","Calculates the divisor when `self` is divided by `rhs`.",14,N],[11,"overflowing_rem","","Calculates the remainder when `self` is divided by `rhs`.",14,N],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",14,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",14,N],[11,"overflowing_neg","","Negates `self` in an overflowing fashion.",14,N],[11,"random","","Create a random fixed uint with a input random core.",14,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",14,[[],["self"]]],[11,"clone","","",14,[[["self"]],["self"]]],[11,"default","","",14,[[],["self"]]],[11,"eq","","",14,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",14,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",14,[[["self"],["self"]],["ordering"]]],[11,"add","","",14,N],[11,"add_assign","","",14,[[["self"],["rhs"]]]],[11,"add","","",14,N],[11,"add_assign","","",14,[[["self"],["h384"]]]],[11,"sub","","",14,N],[11,"sub_assign","","",14,[[["self"],["rhs"]]]],[11,"sub","","",14,N],[11,"sub_assign","","",14,[[["self"],["h384"]]]],[11,"mul","","",14,N],[11,"mul_assign","","",14,[[["self"],["rhs"]]]],[11,"mul","","",14,N],[11,"mul_assign","","",14,[[["self"],["h384"]]]],[11,"div","","",14,N],[11,"div_assign","","",14,[[["self"],["rhs"]]]],[11,"div","","",14,N],[11,"div_assign","","",14,[[["self"],["h384"]]]],[11,"rem","","",14,N],[11,"rem_assign","","",14,[[["self"],["rhs"]]]],[11,"rem","","",14,N],[11,"rem_assign","","",14,[[["self"],["h384"]]]],[11,"bitand","","",14,N],[11,"bitand_assign","","",14,[[["self"],["rhs"]]]],[11,"bitand","","",14,N],[11,"bitand_assign","","",14,[[["self"],["h384"]]]],[11,"bitor","","",14,N],[11,"bitor_assign","","",14,[[["self"],["rhs"]]]],[11,"bitor","","",14,N],[11,"bitor_assign","","",14,[[["self"],["h384"]]]],[11,"bitxor","","",14,N],[11,"bitxor_assign","","",14,[[["self"],["rhs"]]]],[11,"bitxor","","",14,N],[11,"bitxor_assign","","",14,[[["self"],["h384"]]]],[11,"not","","",14,N],[11,"shl","","",14,N],[11,"shl","","",14,N],[11,"shl_assign","","",14,[[["self"],["u8"]]]],[11,"shl_assign","","",14,[[["self"],["u8"]]]],[11,"shl","","",14,N],[11,"shl","","",14,N],[11,"shl_assign","","",14,[[["self"],["u16"]]]],[11,"shl_assign","","",14,[[["self"],["u16"]]]],[11,"shl","","",14,N],[11,"shl","","",14,N],[11,"shl_assign","","",14,[[["self"],["u32"]]]],[11,"shl_assign","","",14,[[["self"],["u32"]]]],[11,"shl","","",14,N],[11,"shl","","",14,N],[11,"shl_assign","","",14,[[["self"],["u64"]]]],[11,"shl_assign","","",14,[[["self"],["u64"]]]],[11,"shl","","",14,N],[11,"shl","","",14,N],[11,"shl_assign","","",14,[[["self"],["u128"]]]],[11,"shl_assign","","",14,[[["self"],["u128"]]]],[11,"shl","","",14,N],[11,"shl","","",14,N],[11,"shl_assign","","",14,[[["self"],["usize"]]]],[11,"shl_assign","","",14,[[["self"],["usize"]]]],[11,"shl","","",14,N],[11,"shl","","",14,N],[11,"shl_assign","","",14,[[["self"],["i8"]]]],[11,"shl_assign","","",14,[[["self"],["i8"]]]],[11,"shl","","",14,N],[11,"shl","","",14,N],[11,"shl_assign","","",14,[[["self"],["i16"]]]],[11,"shl_assign","","",14,[[["self"],["i16"]]]],[11,"shl","","",14,N],[11,"shl","","",14,N],[11,"shl_assign","","",14,[[["self"],["i32"]]]],[11,"shl_assign","","",14,[[["self"],["i32"]]]],[11,"shl","","",14,N],[11,"shl","","",14,N],[11,"shl_assign","","",14,[[["self"],["i64"]]]],[11,"shl_assign","","",14,[[["self"],["i64"]]]],[11,"shl","","",14,N],[11,"shl","","",14,N],[11,"shl_assign","","",14,[[["self"],["i128"]]]],[11,"shl_assign","","",14,[[["self"],["i128"]]]],[11,"shl","","",14,N],[11,"shl","","",14,N],[11,"shl_assign","","",14,[[["self"],["isize"]]]],[11,"shl_assign","","",14,[[["self"],["isize"]]]],[11,"shr","","",14,N],[11,"shr","","",14,N],[11,"shr_assign","","",14,[[["self"],["u8"]]]],[11,"shr_assign","","",14,[[["self"],["u8"]]]],[11,"shr","","",14,N],[11,"shr","","",14,N],[11,"shr_assign","","",14,[[["self"],["u16"]]]],[11,"shr_assign","","",14,[[["self"],["u16"]]]],[11,"shr","","",14,N],[11,"shr","","",14,N],[11,"shr_assign","","",14,[[["self"],["u32"]]]],[11,"shr_assign","","",14,[[["self"],["u32"]]]],[11,"shr","","",14,N],[11,"shr","","",14,N],[11,"shr_assign","","",14,[[["self"],["u64"]]]],[11,"shr_assign","","",14,[[["self"],["u64"]]]],[11,"shr","","",14,N],[11,"shr","","",14,N],[11,"shr_assign","","",14,[[["self"],["u128"]]]],[11,"shr_assign","","",14,[[["self"],["u128"]]]],[11,"shr","","",14,N],[11,"shr","","",14,N],[11,"shr_assign","","",14,[[["self"],["usize"]]]],[11,"shr_assign","","",14,[[["self"],["usize"]]]],[11,"shr","","",14,N],[11,"shr","","",14,N],[11,"shr_assign","","",14,[[["self"],["i8"]]]],[11,"shr_assign","","",14,[[["self"],["i8"]]]],[11,"shr","","",14,N],[11,"shr","","",14,N],[11,"shr_assign","","",14,[[["self"],["i16"]]]],[11,"shr_assign","","",14,[[["self"],["i16"]]]],[11,"shr","","",14,N],[11,"shr","","",14,N],[11,"shr_assign","","",14,[[["self"],["i32"]]]],[11,"shr_assign","","",14,[[["self"],["i32"]]]],[11,"shr","","",14,N],[11,"shr","","",14,N],[11,"shr_assign","","",14,[[["self"],["i64"]]]],[11,"shr_assign","","",14,[[["self"],["i64"]]]],[11,"shr","","",14,N],[11,"shr","","",14,N],[11,"shr_assign","","",14,[[["self"],["i128"]]]],[11,"shr_assign","","",14,[[["self"],["i128"]]]],[11,"shr","","",14,N],[11,"shr","","",14,N],[11,"shr_assign","","",14,[[["self"],["isize"]]]],[11,"shr_assign","","",14,[[["self"],["isize"]]]],[11,"from","","",14,[[["bool"]],["self"]]],[11,"from","","",14,[[["u8"]],["self"]]],[11,"from","","",14,[[["u8"]],["self"]]],[11,"from","","",14,[[["u16"]],["self"]]],[11,"from","","",14,[[["u16"]],["self"]]],[11,"from","","",14,[[["u32"]],["self"]]],[11,"from","","",14,[[["u32"]],["self"]]],[11,"from","","",14,[[["u64"]],["self"]]],[11,"from","","",14,[[["u64"]],["self"]]],[11,"from","","",14,[[["u128"]],["self"]]],[11,"from","","",14,[[["u128"]],["self"]]],[11,"fmt","","",14,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",14,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",14,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",14,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",14,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",14,[[["self"],["formatter"]],["result"]]],[11,"hash","","",14,[[["self"],["h"]]]],[11,"sum","","",14,[[["i"]],["self"]]],[11,"sum","","",14,[[["i"]],["self"]]],[11,"product","","",14,[[["i"]],["self"]]],[11,"product","","",14,[[["i"]],["self"]]],[11,"as_byte_slice_mut","","",14,N],[11,"to_le","","",14,[[["self"]]]],[11,"convert_into","","",15,N],[11,"convert_into","","",0,N],[11,"convert_into","","",15,N],[11,"convert_into","","",1,N],[11,"convert_into","","",15,N],[11,"convert_into","","",2,N],[11,"convert_into","","",15,N],[11,"convert_into","","",3,N],[11,"convert_into","","",15,N],[11,"convert_into","","",4,N],[11,"convert_into","","",15,N],[11,"convert_into","","",5,N],[11,"convert_into","","",15,N],[11,"convert_into","","",6,N],[11,"convert_into","","",15,N],[11,"convert_into","","",7,N],[11,"convert_into","","",15,N],[11,"convert_into","","",8,N],[11,"convert_into","","",15,N],[11,"convert_into","","",9,N],[11,"convert_into","","",15,N],[11,"convert_into","","",10,N],[11,"convert_into","","",15,N],[11,"convert_into","","",11,N],[11,"convert_into","","",15,N],[11,"convert_into","","",12,N],[11,"convert_into","","",15,N],[11,"convert_into","","",13,N],[11,"convert_into","","",15,N],[11,"convert_into","","",14,N],[11,"zero","","Create a new fixed uint and value is zero.",15,[[],["self"]]],[11,"one","","Create a new fixed uint and value is zero.",15,[[],["self"]]],[11,"is_zero","","Test if a fixed uint is zero.",15,[[["self"]],["bool"]]],[11,"is_max","","Test if a fixed uint is the max value.",15,[[["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",15,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",15,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",15,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",15,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",15,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",15,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",15,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",15,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",15,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",15,[[["self"]],["option",["usize"]]]],[11,"complete_mul","","Calculates the multiplication of `self` and `other`.",15,N],[11,"complete_div","","Calculates both the quotient and the remainder when `self` is divided by `other`.",15,N],[11,"from_little_endian","","Convert from little-endian slice.",15,N],[11,"from_big_endian","","Convert from big-endian slice.",15,N],[11,"into_little_endian","","Convert into little-endian slice.",15,N],[11,"into_big_endian","","Convert into big-endian slice.",15,N],[11,"from_bin_str","","Convert from a binary string.",15,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_oct_str","","Convert from a octal string.",15,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_hex_str","","Convert from a hexadecimal string.",15,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_dec_str","","Convert from a decimal string.",15,[[["str"]],["result",["fixeduinterror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",15,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",15,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",15,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",15,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",15,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",15,[[["self"]],["u32"]]],[11,"checked_add","","Checked integer addition. Computes `self + rhs`, returning `None` if overflow occurred.",15,[[["self"],["self"]],["option"]]],[11,"checked_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",15,[[["self"],["self"]],["option"]]],[11,"checked_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",15,[[["self"],["self"]],["option"]]],[11,"checked_div","","Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`.",15,[[["self"],["self"]],["option"]]],[11,"checked_rem","","Checked integer remainder. Computes `self % rhs`, returning `None` if `rhs == 0`.",15,[[["self"],["self"]],["option"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",15,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",15,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",15,[[["self"]],["option"]]],[11,"saturating_add","","Saturating integer addition. Computes `self + rhs`, saturating at the numeric bounds instead of overflowing.",15,[[["self"],["self"]],["self"]]],[11,"saturating_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",15,[[["self"],["self"]],["self"]]],[11,"saturating_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",15,[[["self"],["self"]],["self"]]],[11,"overflowing_add","","Calculates `self + rhs`.",15,N],[11,"overflowing_sub","","Calculates `self - rhs`.",15,N],[11,"overflowing_mul","","Calculates the multiplication of `self` and `rhs`.",15,N],[11,"overflowing_div","","Calculates the divisor when `self` is divided by `rhs`.",15,N],[11,"overflowing_rem","","Calculates the remainder when `self` is divided by `rhs`.",15,N],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",15,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",15,N],[11,"overflowing_neg","","Negates `self` in an overflowing fashion.",15,N],[11,"random","","Create a random fixed uint with a input random core.",15,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",15,[[],["self"]]],[11,"clone","","",15,[[["self"]],["self"]]],[11,"default","","",15,[[],["self"]]],[11,"eq","","",15,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",15,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",15,[[["self"],["self"]],["ordering"]]],[11,"add","","",15,N],[11,"add_assign","","",15,[[["self"],["rhs"]]]],[11,"add","","",15,N],[11,"add_assign","","",15,[[["self"],["h512"]]]],[11,"sub","","",15,N],[11,"sub_assign","","",15,[[["self"],["rhs"]]]],[11,"sub","","",15,N],[11,"sub_assign","","",15,[[["self"],["h512"]]]],[11,"mul","","",15,N],[11,"mul_assign","","",15,[[["self"],["rhs"]]]],[11,"mul","","",15,N],[11,"mul_assign","","",15,[[["self"],["h512"]]]],[11,"div","","",15,N],[11,"div_assign","","",15,[[["self"],["rhs"]]]],[11,"div","","",15,N],[11,"div_assign","","",15,[[["self"],["h512"]]]],[11,"rem","","",15,N],[11,"rem_assign","","",15,[[["self"],["rhs"]]]],[11,"rem","","",15,N],[11,"rem_assign","","",15,[[["self"],["h512"]]]],[11,"bitand","","",15,N],[11,"bitand_assign","","",15,[[["self"],["rhs"]]]],[11,"bitand","","",15,N],[11,"bitand_assign","","",15,[[["self"],["h512"]]]],[11,"bitor","","",15,N],[11,"bitor_assign","","",15,[[["self"],["rhs"]]]],[11,"bitor","","",15,N],[11,"bitor_assign","","",15,[[["self"],["h512"]]]],[11,"bitxor","","",15,N],[11,"bitxor_assign","","",15,[[["self"],["rhs"]]]],[11,"bitxor","","",15,N],[11,"bitxor_assign","","",15,[[["self"],["h512"]]]],[11,"not","","",15,N],[11,"shl","","",15,N],[11,"shl","","",15,N],[11,"shl_assign","","",15,[[["self"],["u8"]]]],[11,"shl_assign","","",15,[[["self"],["u8"]]]],[11,"shl","","",15,N],[11,"shl","","",15,N],[11,"shl_assign","","",15,[[["self"],["u16"]]]],[11,"shl_assign","","",15,[[["self"],["u16"]]]],[11,"shl","","",15,N],[11,"shl","","",15,N],[11,"shl_assign","","",15,[[["self"],["u32"]]]],[11,"shl_assign","","",15,[[["self"],["u32"]]]],[11,"shl","","",15,N],[11,"shl","","",15,N],[11,"shl_assign","","",15,[[["self"],["u64"]]]],[11,"shl_assign","","",15,[[["self"],["u64"]]]],[11,"shl","","",15,N],[11,"shl","","",15,N],[11,"shl_assign","","",15,[[["self"],["u128"]]]],[11,"shl_assign","","",15,[[["self"],["u128"]]]],[11,"shl","","",15,N],[11,"shl","","",15,N],[11,"shl_assign","","",15,[[["self"],["usize"]]]],[11,"shl_assign","","",15,[[["self"],["usize"]]]],[11,"shl","","",15,N],[11,"shl","","",15,N],[11,"shl_assign","","",15,[[["self"],["i8"]]]],[11,"shl_assign","","",15,[[["self"],["i8"]]]],[11,"shl","","",15,N],[11,"shl","","",15,N],[11,"shl_assign","","",15,[[["self"],["i16"]]]],[11,"shl_assign","","",15,[[["self"],["i16"]]]],[11,"shl","","",15,N],[11,"shl","","",15,N],[11,"shl_assign","","",15,[[["self"],["i32"]]]],[11,"shl_assign","","",15,[[["self"],["i32"]]]],[11,"shl","","",15,N],[11,"shl","","",15,N],[11,"shl_assign","","",15,[[["self"],["i64"]]]],[11,"shl_assign","","",15,[[["self"],["i64"]]]],[11,"shl","","",15,N],[11,"shl","","",15,N],[11,"shl_assign","","",15,[[["self"],["i128"]]]],[11,"shl_assign","","",15,[[["self"],["i128"]]]],[11,"shl","","",15,N],[11,"shl","","",15,N],[11,"shl_assign","","",15,[[["self"],["isize"]]]],[11,"shl_assign","","",15,[[["self"],["isize"]]]],[11,"shr","","",15,N],[11,"shr","","",15,N],[11,"shr_assign","","",15,[[["self"],["u8"]]]],[11,"shr_assign","","",15,[[["self"],["u8"]]]],[11,"shr","","",15,N],[11,"shr","","",15,N],[11,"shr_assign","","",15,[[["self"],["u16"]]]],[11,"shr_assign","","",15,[[["self"],["u16"]]]],[11,"shr","","",15,N],[11,"shr","","",15,N],[11,"shr_assign","","",15,[[["self"],["u32"]]]],[11,"shr_assign","","",15,[[["self"],["u32"]]]],[11,"shr","","",15,N],[11,"shr","","",15,N],[11,"shr_assign","","",15,[[["self"],["u64"]]]],[11,"shr_assign","","",15,[[["self"],["u64"]]]],[11,"shr","","",15,N],[11,"shr","","",15,N],[11,"shr_assign","","",15,[[["self"],["u128"]]]],[11,"shr_assign","","",15,[[["self"],["u128"]]]],[11,"shr","","",15,N],[11,"shr","","",15,N],[11,"shr_assign","","",15,[[["self"],["usize"]]]],[11,"shr_assign","","",15,[[["self"],["usize"]]]],[11,"shr","","",15,N],[11,"shr","","",15,N],[11,"shr_assign","","",15,[[["self"],["i8"]]]],[11,"shr_assign","","",15,[[["self"],["i8"]]]],[11,"shr","","",15,N],[11,"shr","","",15,N],[11,"shr_assign","","",15,[[["self"],["i16"]]]],[11,"shr_assign","","",15,[[["self"],["i16"]]]],[11,"shr","","",15,N],[11,"shr","","",15,N],[11,"shr_assign","","",15,[[["self"],["i32"]]]],[11,"shr_assign","","",15,[[["self"],["i32"]]]],[11,"shr","","",15,N],[11,"shr","","",15,N],[11,"shr_assign","","",15,[[["self"],["i64"]]]],[11,"shr_assign","","",15,[[["self"],["i64"]]]],[11,"shr","","",15,N],[11,"shr","","",15,N],[11,"shr_assign","","",15,[[["self"],["i128"]]]],[11,"shr_assign","","",15,[[["self"],["i128"]]]],[11,"shr","","",15,N],[11,"shr","","",15,N],[11,"shr_assign","","",15,[[["self"],["isize"]]]],[11,"shr_assign","","",15,[[["self"],["isize"]]]],[11,"from","","",15,[[["bool"]],["self"]]],[11,"from","","",15,[[["u8"]],["self"]]],[11,"from","","",15,[[["u8"]],["self"]]],[11,"from","","",15,[[["u16"]],["self"]]],[11,"from","","",15,[[["u16"]],["self"]]],[11,"from","","",15,[[["u32"]],["self"]]],[11,"from","","",15,[[["u32"]],["self"]]],[11,"from","","",15,[[["u64"]],["self"]]],[11,"from","","",15,[[["u64"]],["self"]]],[11,"from","","",15,[[["u128"]],["self"]]],[11,"from","","",15,[[["u128"]],["self"]]],[11,"fmt","","",15,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",15,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",15,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",15,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",15,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",15,[[["self"],["formatter"]],["result"]]],[11,"hash","","",15,[[["self"],["h"]]]],[11,"sum","","",15,[[["i"]],["self"]]],[11,"sum","","",15,[[["i"]],["self"]]],[11,"product","","",15,[[["i"]],["self"]]],[11,"product","","",15,[[["i"]],["self"]]],[11,"as_byte_slice_mut","","",15,N],[11,"to_le","","",15,[[["self"]]]],[11,"convert_into","","",16,N],[11,"convert_into","","",0,N],[11,"convert_into","","",16,N],[11,"convert_into","","",1,N],[11,"convert_into","","",16,N],[11,"convert_into","","",2,N],[11,"convert_into","","",16,N],[11,"convert_into","","",3,N],[11,"convert_into","","",16,N],[11,"convert_into","","",4,N],[11,"convert_into","","",16,N],[11,"convert_into","","",5,N],[11,"convert_into","","",16,N],[11,"convert_into","","",6,N],[11,"convert_into","","",16,N],[11,"convert_into","","",7,N],[11,"convert_into","","",16,N],[11,"convert_into","","",8,N],[11,"convert_into","","",16,N],[11,"convert_into","","",9,N],[11,"convert_into","","",16,N],[11,"convert_into","","",10,N],[11,"convert_into","","",16,N],[11,"convert_into","","",11,N],[11,"convert_into","","",16,N],[11,"convert_into","","",12,N],[11,"convert_into","","",16,N],[11,"convert_into","","",13,N],[11,"convert_into","","",16,N],[11,"convert_into","","",14,N],[11,"convert_into","","",16,N],[11,"convert_into","","",15,N],[11,"zero","","Create a new fixed uint and value is zero.",16,[[],["self"]]],[11,"one","","Create a new fixed uint and value is zero.",16,[[],["self"]]],[11,"is_zero","","Test if a fixed uint is zero.",16,[[["self"]],["bool"]]],[11,"is_max","","Test if a fixed uint is the max value.",16,[[["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",16,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",16,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",16,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",16,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",16,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",16,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",16,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",16,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",16,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",16,[[["self"]],["option",["usize"]]]],[11,"complete_mul","","Calculates the multiplication of `self` and `other`.",16,N],[11,"complete_div","","Calculates both the quotient and the remainder when `self` is divided by `other`.",16,N],[11,"from_little_endian","","Convert from little-endian slice.",16,N],[11,"from_big_endian","","Convert from big-endian slice.",16,N],[11,"into_little_endian","","Convert into little-endian slice.",16,N],[11,"into_big_endian","","Convert into big-endian slice.",16,N],[11,"from_bin_str","","Convert from a binary string.",16,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_oct_str","","Convert from a octal string.",16,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_hex_str","","Convert from a hexadecimal string.",16,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_dec_str","","Convert from a decimal string.",16,[[["str"]],["result",["fixeduinterror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",16,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",16,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",16,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",16,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",16,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",16,[[["self"]],["u32"]]],[11,"checked_add","","Checked integer addition. Computes `self + rhs`, returning `None` if overflow occurred.",16,[[["self"],["self"]],["option"]]],[11,"checked_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",16,[[["self"],["self"]],["option"]]],[11,"checked_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",16,[[["self"],["self"]],["option"]]],[11,"checked_div","","Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`.",16,[[["self"],["self"]],["option"]]],[11,"checked_rem","","Checked integer remainder. Computes `self % rhs`, returning `None` if `rhs == 0`.",16,[[["self"],["self"]],["option"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",16,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",16,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",16,[[["self"]],["option"]]],[11,"saturating_add","","Saturating integer addition. Computes `self + rhs`, saturating at the numeric bounds instead of overflowing.",16,[[["self"],["self"]],["self"]]],[11,"saturating_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",16,[[["self"],["self"]],["self"]]],[11,"saturating_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",16,[[["self"],["self"]],["self"]]],[11,"overflowing_add","","Calculates `self + rhs`.",16,N],[11,"overflowing_sub","","Calculates `self - rhs`.",16,N],[11,"overflowing_mul","","Calculates the multiplication of `self` and `rhs`.",16,N],[11,"overflowing_div","","Calculates the divisor when `self` is divided by `rhs`.",16,N],[11,"overflowing_rem","","Calculates the remainder when `self` is divided by `rhs`.",16,N],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",16,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",16,N],[11,"overflowing_neg","","Negates `self` in an overflowing fashion.",16,N],[11,"random","","Create a random fixed uint with a input random core.",16,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",16,[[],["self"]]],[11,"clone","","",16,[[["self"]],["self"]]],[11,"default","","",16,[[],["self"]]],[11,"eq","","",16,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",16,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",16,[[["self"],["self"]],["ordering"]]],[11,"add","","",16,N],[11,"add_assign","","",16,[[["self"],["rhs"]]]],[11,"add","","",16,N],[11,"add_assign","","",16,[[["self"],["h520"]]]],[11,"sub","","",16,N],[11,"sub_assign","","",16,[[["self"],["rhs"]]]],[11,"sub","","",16,N],[11,"sub_assign","","",16,[[["self"],["h520"]]]],[11,"mul","","",16,N],[11,"mul_assign","","",16,[[["self"],["rhs"]]]],[11,"mul","","",16,N],[11,"mul_assign","","",16,[[["self"],["h520"]]]],[11,"div","","",16,N],[11,"div_assign","","",16,[[["self"],["rhs"]]]],[11,"div","","",16,N],[11,"div_assign","","",16,[[["self"],["h520"]]]],[11,"rem","","",16,N],[11,"rem_assign","","",16,[[["self"],["rhs"]]]],[11,"rem","","",16,N],[11,"rem_assign","","",16,[[["self"],["h520"]]]],[11,"bitand","","",16,N],[11,"bitand_assign","","",16,[[["self"],["rhs"]]]],[11,"bitand","","",16,N],[11,"bitand_assign","","",16,[[["self"],["h520"]]]],[11,"bitor","","",16,N],[11,"bitor_assign","","",16,[[["self"],["rhs"]]]],[11,"bitor","","",16,N],[11,"bitor_assign","","",16,[[["self"],["h520"]]]],[11,"bitxor","","",16,N],[11,"bitxor_assign","","",16,[[["self"],["rhs"]]]],[11,"bitxor","","",16,N],[11,"bitxor_assign","","",16,[[["self"],["h520"]]]],[11,"not","","",16,N],[11,"shl","","",16,N],[11,"shl","","",16,N],[11,"shl_assign","","",16,[[["self"],["u8"]]]],[11,"shl_assign","","",16,[[["self"],["u8"]]]],[11,"shl","","",16,N],[11,"shl","","",16,N],[11,"shl_assign","","",16,[[["self"],["u16"]]]],[11,"shl_assign","","",16,[[["self"],["u16"]]]],[11,"shl","","",16,N],[11,"shl","","",16,N],[11,"shl_assign","","",16,[[["self"],["u32"]]]],[11,"shl_assign","","",16,[[["self"],["u32"]]]],[11,"shl","","",16,N],[11,"shl","","",16,N],[11,"shl_assign","","",16,[[["self"],["u64"]]]],[11,"shl_assign","","",16,[[["self"],["u64"]]]],[11,"shl","","",16,N],[11,"shl","","",16,N],[11,"shl_assign","","",16,[[["self"],["u128"]]]],[11,"shl_assign","","",16,[[["self"],["u128"]]]],[11,"shl","","",16,N],[11,"shl","","",16,N],[11,"shl_assign","","",16,[[["self"],["usize"]]]],[11,"shl_assign","","",16,[[["self"],["usize"]]]],[11,"shl","","",16,N],[11,"shl","","",16,N],[11,"shl_assign","","",16,[[["self"],["i8"]]]],[11,"shl_assign","","",16,[[["self"],["i8"]]]],[11,"shl","","",16,N],[11,"shl","","",16,N],[11,"shl_assign","","",16,[[["self"],["i16"]]]],[11,"shl_assign","","",16,[[["self"],["i16"]]]],[11,"shl","","",16,N],[11,"shl","","",16,N],[11,"shl_assign","","",16,[[["self"],["i32"]]]],[11,"shl_assign","","",16,[[["self"],["i32"]]]],[11,"shl","","",16,N],[11,"shl","","",16,N],[11,"shl_assign","","",16,[[["self"],["i64"]]]],[11,"shl_assign","","",16,[[["self"],["i64"]]]],[11,"shl","","",16,N],[11,"shl","","",16,N],[11,"shl_assign","","",16,[[["self"],["i128"]]]],[11,"shl_assign","","",16,[[["self"],["i128"]]]],[11,"shl","","",16,N],[11,"shl","","",16,N],[11,"shl_assign","","",16,[[["self"],["isize"]]]],[11,"shl_assign","","",16,[[["self"],["isize"]]]],[11,"shr","","",16,N],[11,"shr","","",16,N],[11,"shr_assign","","",16,[[["self"],["u8"]]]],[11,"shr_assign","","",16,[[["self"],["u8"]]]],[11,"shr","","",16,N],[11,"shr","","",16,N],[11,"shr_assign","","",16,[[["self"],["u16"]]]],[11,"shr_assign","","",16,[[["self"],["u16"]]]],[11,"shr","","",16,N],[11,"shr","","",16,N],[11,"shr_assign","","",16,[[["self"],["u32"]]]],[11,"shr_assign","","",16,[[["self"],["u32"]]]],[11,"shr","","",16,N],[11,"shr","","",16,N],[11,"shr_assign","","",16,[[["self"],["u64"]]]],[11,"shr_assign","","",16,[[["self"],["u64"]]]],[11,"shr","","",16,N],[11,"shr","","",16,N],[11,"shr_assign","","",16,[[["self"],["u128"]]]],[11,"shr_assign","","",16,[[["self"],["u128"]]]],[11,"shr","","",16,N],[11,"shr","","",16,N],[11,"shr_assign","","",16,[[["self"],["usize"]]]],[11,"shr_assign","","",16,[[["self"],["usize"]]]],[11,"shr","","",16,N],[11,"shr","","",16,N],[11,"shr_assign","","",16,[[["self"],["i8"]]]],[11,"shr_assign","","",16,[[["self"],["i8"]]]],[11,"shr","","",16,N],[11,"shr","","",16,N],[11,"shr_assign","","",16,[[["self"],["i16"]]]],[11,"shr_assign","","",16,[[["self"],["i16"]]]],[11,"shr","","",16,N],[11,"shr","","",16,N],[11,"shr_assign","","",16,[[["self"],["i32"]]]],[11,"shr_assign","","",16,[[["self"],["i32"]]]],[11,"shr","","",16,N],[11,"shr","","",16,N],[11,"shr_assign","","",16,[[["self"],["i64"]]]],[11,"shr_assign","","",16,[[["self"],["i64"]]]],[11,"shr","","",16,N],[11,"shr","","",16,N],[11,"shr_assign","","",16,[[["self"],["i128"]]]],[11,"shr_assign","","",16,[[["self"],["i128"]]]],[11,"shr","","",16,N],[11,"shr","","",16,N],[11,"shr_assign","","",16,[[["self"],["isize"]]]],[11,"shr_assign","","",16,[[["self"],["isize"]]]],[11,"from","","",16,[[["bool"]],["self"]]],[11,"from","","",16,[[["u8"]],["self"]]],[11,"from","","",16,[[["u8"]],["self"]]],[11,"from","","",16,[[["u16"]],["self"]]],[11,"from","","",16,[[["u16"]],["self"]]],[11,"from","","",16,[[["u32"]],["self"]]],[11,"from","","",16,[[["u32"]],["self"]]],[11,"from","","",16,[[["u64"]],["self"]]],[11,"from","","",16,[[["u64"]],["self"]]],[11,"from","","",16,[[["u128"]],["self"]]],[11,"from","","",16,[[["u128"]],["self"]]],[11,"fmt","","",16,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",16,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",16,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",16,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",16,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",16,[[["self"],["formatter"]],["result"]]],[11,"hash","","",16,[[["self"],["h"]]]],[11,"sum","","",16,[[["i"]],["self"]]],[11,"sum","","",16,[[["i"]],["self"]]],[11,"product","","",16,[[["i"]],["self"]]],[11,"product","","",16,[[["i"]],["self"]]],[11,"as_byte_slice_mut","","",16,N],[11,"to_le","","",16,[[["self"]]]],[11,"convert_into","","",17,N],[11,"convert_into","","",0,N],[11,"convert_into","","",17,N],[11,"convert_into","","",1,N],[11,"convert_into","","",17,N],[11,"convert_into","","",2,N],[11,"convert_into","","",17,N],[11,"convert_into","","",3,N],[11,"convert_into","","",17,N],[11,"convert_into","","",4,N],[11,"convert_into","","",17,N],[11,"convert_into","","",5,N],[11,"convert_into","","",17,N],[11,"convert_into","","",6,N],[11,"convert_into","","",17,N],[11,"convert_into","","",7,N],[11,"convert_into","","",17,N],[11,"convert_into","","",8,N],[11,"convert_into","","",17,N],[11,"convert_into","","",9,N],[11,"convert_into","","",17,N],[11,"convert_into","","",10,N],[11,"convert_into","","",17,N],[11,"convert_into","","",11,N],[11,"convert_into","","",17,N],[11,"convert_into","","",12,N],[11,"convert_into","","",17,N],[11,"convert_into","","",13,N],[11,"convert_into","","",17,N],[11,"convert_into","","",14,N],[11,"convert_into","","",17,N],[11,"convert_into","","",15,N],[11,"convert_into","","",17,N],[11,"convert_into","","",16,N],[11,"zero","","Create a new fixed uint and value is zero.",17,[[],["self"]]],[11,"one","","Create a new fixed uint and value is zero.",17,[[],["self"]]],[11,"is_zero","","Test if a fixed uint is zero.",17,[[["self"]],["bool"]]],[11,"is_max","","Test if a fixed uint is the max value.",17,[[["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",17,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",17,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",17,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",17,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",17,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",17,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",17,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",17,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",17,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",17,[[["self"]],["option",["usize"]]]],[11,"complete_mul","","Calculates the multiplication of `self` and `other`.",17,N],[11,"complete_div","","Calculates both the quotient and the remainder when `self` is divided by `other`.",17,N],[11,"from_little_endian","","Convert from little-endian slice.",17,N],[11,"from_big_endian","","Convert from big-endian slice.",17,N],[11,"into_little_endian","","Convert into little-endian slice.",17,N],[11,"into_big_endian","","Convert into big-endian slice.",17,N],[11,"from_bin_str","","Convert from a binary string.",17,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_oct_str","","Convert from a octal string.",17,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_hex_str","","Convert from a hexadecimal string.",17,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_dec_str","","Convert from a decimal string.",17,[[["str"]],["result",["fixeduinterror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",17,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",17,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",17,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",17,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",17,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",17,[[["self"]],["u32"]]],[11,"checked_add","","Checked integer addition. Computes `self + rhs`, returning `None` if overflow occurred.",17,[[["self"],["self"]],["option"]]],[11,"checked_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",17,[[["self"],["self"]],["option"]]],[11,"checked_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",17,[[["self"],["self"]],["option"]]],[11,"checked_div","","Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`.",17,[[["self"],["self"]],["option"]]],[11,"checked_rem","","Checked integer remainder. Computes `self % rhs`, returning `None` if `rhs == 0`.",17,[[["self"],["self"]],["option"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",17,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",17,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",17,[[["self"]],["option"]]],[11,"saturating_add","","Saturating integer addition. Computes `self + rhs`, saturating at the numeric bounds instead of overflowing.",17,[[["self"],["self"]],["self"]]],[11,"saturating_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",17,[[["self"],["self"]],["self"]]],[11,"saturating_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",17,[[["self"],["self"]],["self"]]],[11,"overflowing_add","","Calculates `self + rhs`.",17,N],[11,"overflowing_sub","","Calculates `self - rhs`.",17,N],[11,"overflowing_mul","","Calculates the multiplication of `self` and `rhs`.",17,N],[11,"overflowing_div","","Calculates the divisor when `self` is divided by `rhs`.",17,N],[11,"overflowing_rem","","Calculates the remainder when `self` is divided by `rhs`.",17,N],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",17,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",17,N],[11,"overflowing_neg","","Negates `self` in an overflowing fashion.",17,N],[11,"random","","Create a random fixed uint with a input random core.",17,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",17,[[],["self"]]],[11,"clone","","",17,[[["self"]],["self"]]],[11,"default","","",17,[[],["self"]]],[11,"eq","","",17,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",17,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",17,[[["self"],["self"]],["ordering"]]],[11,"add","","",17,N],[11,"add_assign","","",17,[[["self"],["rhs"]]]],[11,"add","","",17,N],[11,"add_assign","","",17,[[["self"],["h1024"]]]],[11,"sub","","",17,N],[11,"sub_assign","","",17,[[["self"],["rhs"]]]],[11,"sub","","",17,N],[11,"sub_assign","","",17,[[["self"],["h1024"]]]],[11,"mul","","",17,N],[11,"mul_assign","","",17,[[["self"],["rhs"]]]],[11,"mul","","",17,N],[11,"mul_assign","","",17,[[["self"],["h1024"]]]],[11,"div","","",17,N],[11,"div_assign","","",17,[[["self"],["rhs"]]]],[11,"div","","",17,N],[11,"div_assign","","",17,[[["self"],["h1024"]]]],[11,"rem","","",17,N],[11,"rem_assign","","",17,[[["self"],["rhs"]]]],[11,"rem","","",17,N],[11,"rem_assign","","",17,[[["self"],["h1024"]]]],[11,"bitand","","",17,N],[11,"bitand_assign","","",17,[[["self"],["rhs"]]]],[11,"bitand","","",17,N],[11,"bitand_assign","","",17,[[["self"],["h1024"]]]],[11,"bitor","","",17,N],[11,"bitor_assign","","",17,[[["self"],["rhs"]]]],[11,"bitor","","",17,N],[11,"bitor_assign","","",17,[[["self"],["h1024"]]]],[11,"bitxor","","",17,N],[11,"bitxor_assign","","",17,[[["self"],["rhs"]]]],[11,"bitxor","","",17,N],[11,"bitxor_assign","","",17,[[["self"],["h1024"]]]],[11,"not","","",17,N],[11,"shl","","",17,N],[11,"shl","","",17,N],[11,"shl_assign","","",17,[[["self"],["u8"]]]],[11,"shl_assign","","",17,[[["self"],["u8"]]]],[11,"shl","","",17,N],[11,"shl","","",17,N],[11,"shl_assign","","",17,[[["self"],["u16"]]]],[11,"shl_assign","","",17,[[["self"],["u16"]]]],[11,"shl","","",17,N],[11,"shl","","",17,N],[11,"shl_assign","","",17,[[["self"],["u32"]]]],[11,"shl_assign","","",17,[[["self"],["u32"]]]],[11,"shl","","",17,N],[11,"shl","","",17,N],[11,"shl_assign","","",17,[[["self"],["u64"]]]],[11,"shl_assign","","",17,[[["self"],["u64"]]]],[11,"shl","","",17,N],[11,"shl","","",17,N],[11,"shl_assign","","",17,[[["self"],["u128"]]]],[11,"shl_assign","","",17,[[["self"],["u128"]]]],[11,"shl","","",17,N],[11,"shl","","",17,N],[11,"shl_assign","","",17,[[["self"],["usize"]]]],[11,"shl_assign","","",17,[[["self"],["usize"]]]],[11,"shl","","",17,N],[11,"shl","","",17,N],[11,"shl_assign","","",17,[[["self"],["i8"]]]],[11,"shl_assign","","",17,[[["self"],["i8"]]]],[11,"shl","","",17,N],[11,"shl","","",17,N],[11,"shl_assign","","",17,[[["self"],["i16"]]]],[11,"shl_assign","","",17,[[["self"],["i16"]]]],[11,"shl","","",17,N],[11,"shl","","",17,N],[11,"shl_assign","","",17,[[["self"],["i32"]]]],[11,"shl_assign","","",17,[[["self"],["i32"]]]],[11,"shl","","",17,N],[11,"shl","","",17,N],[11,"shl_assign","","",17,[[["self"],["i64"]]]],[11,"shl_assign","","",17,[[["self"],["i64"]]]],[11,"shl","","",17,N],[11,"shl","","",17,N],[11,"shl_assign","","",17,[[["self"],["i128"]]]],[11,"shl_assign","","",17,[[["self"],["i128"]]]],[11,"shl","","",17,N],[11,"shl","","",17,N],[11,"shl_assign","","",17,[[["self"],["isize"]]]],[11,"shl_assign","","",17,[[["self"],["isize"]]]],[11,"shr","","",17,N],[11,"shr","","",17,N],[11,"shr_assign","","",17,[[["self"],["u8"]]]],[11,"shr_assign","","",17,[[["self"],["u8"]]]],[11,"shr","","",17,N],[11,"shr","","",17,N],[11,"shr_assign","","",17,[[["self"],["u16"]]]],[11,"shr_assign","","",17,[[["self"],["u16"]]]],[11,"shr","","",17,N],[11,"shr","","",17,N],[11,"shr_assign","","",17,[[["self"],["u32"]]]],[11,"shr_assign","","",17,[[["self"],["u32"]]]],[11,"shr","","",17,N],[11,"shr","","",17,N],[11,"shr_assign","","",17,[[["self"],["u64"]]]],[11,"shr_assign","","",17,[[["self"],["u64"]]]],[11,"shr","","",17,N],[11,"shr","","",17,N],[11,"shr_assign","","",17,[[["self"],["u128"]]]],[11,"shr_assign","","",17,[[["self"],["u128"]]]],[11,"shr","","",17,N],[11,"shr","","",17,N],[11,"shr_assign","","",17,[[["self"],["usize"]]]],[11,"shr_assign","","",17,[[["self"],["usize"]]]],[11,"shr","","",17,N],[11,"shr","","",17,N],[11,"shr_assign","","",17,[[["self"],["i8"]]]],[11,"shr_assign","","",17,[[["self"],["i8"]]]],[11,"shr","","",17,N],[11,"shr","","",17,N],[11,"shr_assign","","",17,[[["self"],["i16"]]]],[11,"shr_assign","","",17,[[["self"],["i16"]]]],[11,"shr","","",17,N],[11,"shr","","",17,N],[11,"shr_assign","","",17,[[["self"],["i32"]]]],[11,"shr_assign","","",17,[[["self"],["i32"]]]],[11,"shr","","",17,N],[11,"shr","","",17,N],[11,"shr_assign","","",17,[[["self"],["i64"]]]],[11,"shr_assign","","",17,[[["self"],["i64"]]]],[11,"shr","","",17,N],[11,"shr","","",17,N],[11,"shr_assign","","",17,[[["self"],["i128"]]]],[11,"shr_assign","","",17,[[["self"],["i128"]]]],[11,"shr","","",17,N],[11,"shr","","",17,N],[11,"shr_assign","","",17,[[["self"],["isize"]]]],[11,"shr_assign","","",17,[[["self"],["isize"]]]],[11,"from","","",17,[[["bool"]],["self"]]],[11,"from","","",17,[[["u8"]],["self"]]],[11,"from","","",17,[[["u8"]],["self"]]],[11,"from","","",17,[[["u16"]],["self"]]],[11,"from","","",17,[[["u16"]],["self"]]],[11,"from","","",17,[[["u32"]],["self"]]],[11,"from","","",17,[[["u32"]],["self"]]],[11,"from","","",17,[[["u64"]],["self"]]],[11,"from","","",17,[[["u64"]],["self"]]],[11,"from","","",17,[[["u128"]],["self"]]],[11,"from","","",17,[[["u128"]],["self"]]],[11,"fmt","","",17,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",17,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",17,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",17,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",17,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",17,[[["self"],["formatter"]],["result"]]],[11,"hash","","",17,[[["self"],["h"]]]],[11,"sum","","",17,[[["i"]],["self"]]],[11,"sum","","",17,[[["i"]],["self"]]],[11,"product","","",17,[[["i"]],["self"]]],[11,"product","","",17,[[["i"]],["self"]]],[11,"as_byte_slice_mut","","",17,N],[11,"to_le","","",17,[[["self"]]]],[11,"convert_into","","",18,N],[11,"convert_into","","",0,N],[11,"convert_into","","",18,N],[11,"convert_into","","",1,N],[11,"convert_into","","",18,N],[11,"convert_into","","",2,N],[11,"convert_into","","",18,N],[11,"convert_into","","",3,N],[11,"convert_into","","",18,N],[11,"convert_into","","",4,N],[11,"convert_into","","",18,N],[11,"convert_into","","",5,N],[11,"convert_into","","",18,N],[11,"convert_into","","",6,N],[11,"convert_into","","",18,N],[11,"convert_into","","",7,N],[11,"convert_into","","",18,N],[11,"convert_into","","",8,N],[11,"convert_into","","",18,N],[11,"convert_into","","",9,N],[11,"convert_into","","",18,N],[11,"convert_into","","",10,N],[11,"convert_into","","",18,N],[11,"convert_into","","",11,N],[11,"convert_into","","",18,N],[11,"convert_into","","",12,N],[11,"convert_into","","",18,N],[11,"convert_into","","",13,N],[11,"convert_into","","",18,N],[11,"convert_into","","",14,N],[11,"convert_into","","",18,N],[11,"convert_into","","",15,N],[11,"convert_into","","",18,N],[11,"convert_into","","",16,N],[11,"convert_into","","",18,N],[11,"convert_into","","",17,N],[11,"zero","","Create a new fixed uint and value is zero.",18,[[],["self"]]],[11,"one","","Create a new fixed uint and value is zero.",18,[[],["self"]]],[11,"is_zero","","Test if a fixed uint is zero.",18,[[["self"]],["bool"]]],[11,"is_max","","Test if a fixed uint is the max value.",18,[[["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",18,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",18,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",18,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",18,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",18,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",18,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",18,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",18,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",18,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",18,[[["self"]],["option",["usize"]]]],[11,"complete_mul","","Calculates the multiplication of `self` and `other`.",18,N],[11,"complete_div","","Calculates both the quotient and the remainder when `self` is divided by `other`.",18,N],[11,"from_little_endian","","Convert from little-endian slice.",18,N],[11,"from_big_endian","","Convert from big-endian slice.",18,N],[11,"into_little_endian","","Convert into little-endian slice.",18,N],[11,"into_big_endian","","Convert into big-endian slice.",18,N],[11,"from_bin_str","","Convert from a binary string.",18,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_oct_str","","Convert from a octal string.",18,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_hex_str","","Convert from a hexadecimal string.",18,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_dec_str","","Convert from a decimal string.",18,[[["str"]],["result",["fixeduinterror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",18,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",18,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",18,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",18,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",18,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",18,[[["self"]],["u32"]]],[11,"checked_add","","Checked integer addition. Computes `self + rhs`, returning `None` if overflow occurred.",18,[[["self"],["self"]],["option"]]],[11,"checked_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",18,[[["self"],["self"]],["option"]]],[11,"checked_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",18,[[["self"],["self"]],["option"]]],[11,"checked_div","","Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`.",18,[[["self"],["self"]],["option"]]],[11,"checked_rem","","Checked integer remainder. Computes `self % rhs`, returning `None` if `rhs == 0`.",18,[[["self"],["self"]],["option"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",18,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",18,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",18,[[["self"]],["option"]]],[11,"saturating_add","","Saturating integer addition. Computes `self + rhs`, saturating at the numeric bounds instead of overflowing.",18,[[["self"],["self"]],["self"]]],[11,"saturating_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",18,[[["self"],["self"]],["self"]]],[11,"saturating_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",18,[[["self"],["self"]],["self"]]],[11,"overflowing_add","","Calculates `self + rhs`.",18,N],[11,"overflowing_sub","","Calculates `self - rhs`.",18,N],[11,"overflowing_mul","","Calculates the multiplication of `self` and `rhs`.",18,N],[11,"overflowing_div","","Calculates the divisor when `self` is divided by `rhs`.",18,N],[11,"overflowing_rem","","Calculates the remainder when `self` is divided by `rhs`.",18,N],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",18,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",18,N],[11,"overflowing_neg","","Negates `self` in an overflowing fashion.",18,N],[11,"random","","Create a random fixed uint with a input random core.",18,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",18,[[],["self"]]],[11,"clone","","",18,[[["self"]],["self"]]],[11,"default","","",18,[[],["self"]]],[11,"eq","","",18,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",18,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",18,[[["self"],["self"]],["ordering"]]],[11,"add","","",18,N],[11,"add_assign","","",18,[[["self"],["rhs"]]]],[11,"add","","",18,N],[11,"add_assign","","",18,[[["self"],["h2048"]]]],[11,"sub","","",18,N],[11,"sub_assign","","",18,[[["self"],["rhs"]]]],[11,"sub","","",18,N],[11,"sub_assign","","",18,[[["self"],["h2048"]]]],[11,"mul","","",18,N],[11,"mul_assign","","",18,[[["self"],["rhs"]]]],[11,"mul","","",18,N],[11,"mul_assign","","",18,[[["self"],["h2048"]]]],[11,"div","","",18,N],[11,"div_assign","","",18,[[["self"],["rhs"]]]],[11,"div","","",18,N],[11,"div_assign","","",18,[[["self"],["h2048"]]]],[11,"rem","","",18,N],[11,"rem_assign","","",18,[[["self"],["rhs"]]]],[11,"rem","","",18,N],[11,"rem_assign","","",18,[[["self"],["h2048"]]]],[11,"bitand","","",18,N],[11,"bitand_assign","","",18,[[["self"],["rhs"]]]],[11,"bitand","","",18,N],[11,"bitand_assign","","",18,[[["self"],["h2048"]]]],[11,"bitor","","",18,N],[11,"bitor_assign","","",18,[[["self"],["rhs"]]]],[11,"bitor","","",18,N],[11,"bitor_assign","","",18,[[["self"],["h2048"]]]],[11,"bitxor","","",18,N],[11,"bitxor_assign","","",18,[[["self"],["rhs"]]]],[11,"bitxor","","",18,N],[11,"bitxor_assign","","",18,[[["self"],["h2048"]]]],[11,"not","","",18,N],[11,"shl","","",18,N],[11,"shl","","",18,N],[11,"shl_assign","","",18,[[["self"],["u8"]]]],[11,"shl_assign","","",18,[[["self"],["u8"]]]],[11,"shl","","",18,N],[11,"shl","","",18,N],[11,"shl_assign","","",18,[[["self"],["u16"]]]],[11,"shl_assign","","",18,[[["self"],["u16"]]]],[11,"shl","","",18,N],[11,"shl","","",18,N],[11,"shl_assign","","",18,[[["self"],["u32"]]]],[11,"shl_assign","","",18,[[["self"],["u32"]]]],[11,"shl","","",18,N],[11,"shl","","",18,N],[11,"shl_assign","","",18,[[["self"],["u64"]]]],[11,"shl_assign","","",18,[[["self"],["u64"]]]],[11,"shl","","",18,N],[11,"shl","","",18,N],[11,"shl_assign","","",18,[[["self"],["u128"]]]],[11,"shl_assign","","",18,[[["self"],["u128"]]]],[11,"shl","","",18,N],[11,"shl","","",18,N],[11,"shl_assign","","",18,[[["self"],["usize"]]]],[11,"shl_assign","","",18,[[["self"],["usize"]]]],[11,"shl","","",18,N],[11,"shl","","",18,N],[11,"shl_assign","","",18,[[["self"],["i8"]]]],[11,"shl_assign","","",18,[[["self"],["i8"]]]],[11,"shl","","",18,N],[11,"shl","","",18,N],[11,"shl_assign","","",18,[[["self"],["i16"]]]],[11,"shl_assign","","",18,[[["self"],["i16"]]]],[11,"shl","","",18,N],[11,"shl","","",18,N],[11,"shl_assign","","",18,[[["self"],["i32"]]]],[11,"shl_assign","","",18,[[["self"],["i32"]]]],[11,"shl","","",18,N],[11,"shl","","",18,N],[11,"shl_assign","","",18,[[["self"],["i64"]]]],[11,"shl_assign","","",18,[[["self"],["i64"]]]],[11,"shl","","",18,N],[11,"shl","","",18,N],[11,"shl_assign","","",18,[[["self"],["i128"]]]],[11,"shl_assign","","",18,[[["self"],["i128"]]]],[11,"shl","","",18,N],[11,"shl","","",18,N],[11,"shl_assign","","",18,[[["self"],["isize"]]]],[11,"shl_assign","","",18,[[["self"],["isize"]]]],[11,"shr","","",18,N],[11,"shr","","",18,N],[11,"shr_assign","","",18,[[["self"],["u8"]]]],[11,"shr_assign","","",18,[[["self"],["u8"]]]],[11,"shr","","",18,N],[11,"shr","","",18,N],[11,"shr_assign","","",18,[[["self"],["u16"]]]],[11,"shr_assign","","",18,[[["self"],["u16"]]]],[11,"shr","","",18,N],[11,"shr","","",18,N],[11,"shr_assign","","",18,[[["self"],["u32"]]]],[11,"shr_assign","","",18,[[["self"],["u32"]]]],[11,"shr","","",18,N],[11,"shr","","",18,N],[11,"shr_assign","","",18,[[["self"],["u64"]]]],[11,"shr_assign","","",18,[[["self"],["u64"]]]],[11,"shr","","",18,N],[11,"shr","","",18,N],[11,"shr_assign","","",18,[[["self"],["u128"]]]],[11,"shr_assign","","",18,[[["self"],["u128"]]]],[11,"shr","","",18,N],[11,"shr","","",18,N],[11,"shr_assign","","",18,[[["self"],["usize"]]]],[11,"shr_assign","","",18,[[["self"],["usize"]]]],[11,"shr","","",18,N],[11,"shr","","",18,N],[11,"shr_assign","","",18,[[["self"],["i8"]]]],[11,"shr_assign","","",18,[[["self"],["i8"]]]],[11,"shr","","",18,N],[11,"shr","","",18,N],[11,"shr_assign","","",18,[[["self"],["i16"]]]],[11,"shr_assign","","",18,[[["self"],["i16"]]]],[11,"shr","","",18,N],[11,"shr","","",18,N],[11,"shr_assign","","",18,[[["self"],["i32"]]]],[11,"shr_assign","","",18,[[["self"],["i32"]]]],[11,"shr","","",18,N],[11,"shr","","",18,N],[11,"shr_assign","","",18,[[["self"],["i64"]]]],[11,"shr_assign","","",18,[[["self"],["i64"]]]],[11,"shr","","",18,N],[11,"shr","","",18,N],[11,"shr_assign","","",18,[[["self"],["i128"]]]],[11,"shr_assign","","",18,[[["self"],["i128"]]]],[11,"shr","","",18,N],[11,"shr","","",18,N],[11,"shr_assign","","",18,[[["self"],["isize"]]]],[11,"shr_assign","","",18,[[["self"],["isize"]]]],[11,"from","","",18,[[["bool"]],["self"]]],[11,"from","","",18,[[["u8"]],["self"]]],[11,"from","","",18,[[["u8"]],["self"]]],[11,"from","","",18,[[["u16"]],["self"]]],[11,"from","","",18,[[["u16"]],["self"]]],[11,"from","","",18,[[["u32"]],["self"]]],[11,"from","","",18,[[["u32"]],["self"]]],[11,"from","","",18,[[["u64"]],["self"]]],[11,"from","","",18,[[["u64"]],["self"]]],[11,"from","","",18,[[["u128"]],["self"]]],[11,"from","","",18,[[["u128"]],["self"]]],[11,"fmt","","",18,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",18,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",18,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",18,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",18,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",18,[[["self"],["formatter"]],["result"]]],[11,"hash","","",18,[[["self"],["h"]]]],[11,"sum","","",18,[[["i"]],["self"]]],[11,"sum","","",18,[[["i"]],["self"]]],[11,"product","","",18,[[["i"]],["self"]]],[11,"product","","",18,[[["i"]],["self"]]],[11,"as_byte_slice_mut","","",18,N],[11,"to_le","","",18,[[["self"]]]],[11,"convert_into","","",19,N],[11,"convert_into","","",0,N],[11,"convert_into","","",19,N],[11,"convert_into","","",1,N],[11,"convert_into","","",19,N],[11,"convert_into","","",2,N],[11,"convert_into","","",19,N],[11,"convert_into","","",3,N],[11,"convert_into","","",19,N],[11,"convert_into","","",4,N],[11,"convert_into","","",19,N],[11,"convert_into","","",5,N],[11,"convert_into","","",19,N],[11,"convert_into","","",6,N],[11,"convert_into","","",19,N],[11,"convert_into","","",7,N],[11,"convert_into","","",19,N],[11,"convert_into","","",8,N],[11,"convert_into","","",19,N],[11,"convert_into","","",9,N],[11,"convert_into","","",19,N],[11,"convert_into","","",10,N],[11,"convert_into","","",19,N],[11,"convert_into","","",11,N],[11,"convert_into","","",19,N],[11,"convert_into","","",12,N],[11,"convert_into","","",19,N],[11,"convert_into","","",13,N],[11,"convert_into","","",19,N],[11,"convert_into","","",14,N],[11,"convert_into","","",19,N],[11,"convert_into","","",15,N],[11,"convert_into","","",19,N],[11,"convert_into","","",16,N],[11,"convert_into","","",19,N],[11,"convert_into","","",17,N],[11,"convert_into","","",19,N],[11,"convert_into","","",18,N],[11,"zero","","Create a new fixed uint and value is zero.",19,[[],["self"]]],[11,"one","","Create a new fixed uint and value is zero.",19,[[],["self"]]],[11,"is_zero","","Test if a fixed uint is zero.",19,[[["self"]],["bool"]]],[11,"is_max","","Test if a fixed uint is the max value.",19,[[["self"]],["bool"]]],[11,"count_bits","","Return the count of bits.",19,[[],["u64"]]],[11,"bit","","Return a specific bit, or return None when overlows.",19,[[["self"],["usize"]],["option",["bool"]]]],[11,"set_bit","","Set a specific bit. Return false when overflows.",19,[[["self"],["usize"],["bool"]],["bool"]]],[11,"highest_one","","Return the highest bit which is one.",19,[[["self"]],["option",["usize"]]]],[11,"lowest_one","","Return the lowest bit which is one.",19,[[["self"]],["option",["usize"]]]],[11,"count_bytes","","Return the count of bytes.",19,[[],["u64"]]],[11,"byte","","Return a specific byte, or return None when overlows.",19,[[["self"],["usize"]],["option",["u8"]]]],[11,"set_byte","","Set a specific byte. Return false when overflows;",19,[[["self"],["usize"],["u8"]],["bool"]]],[11,"highest_nonzero_byte","","Return the highest byte which is nonzero.",19,[[["self"]],["option",["usize"]]]],[11,"lowest_nonzero_byte","","Return the lowest byte which is nonzero.",19,[[["self"]],["option",["usize"]]]],[11,"complete_mul","","Calculates the multiplication of `self` and `other`.",19,N],[11,"complete_div","","Calculates both the quotient and the remainder when `self` is divided by `other`.",19,N],[11,"from_little_endian","","Convert from little-endian slice.",19,N],[11,"from_big_endian","","Convert from big-endian slice.",19,N],[11,"into_little_endian","","Convert into little-endian slice.",19,N],[11,"into_big_endian","","Convert into big-endian slice.",19,N],[11,"from_bin_str","","Convert from a binary string.",19,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_oct_str","","Convert from a octal string.",19,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_hex_str","","Convert from a hexadecimal string.",19,[[["str"]],["result",["fixeduinterror"]]]],[11,"from_dec_str","","Convert from a decimal string.",19,[[["str"]],["result",["fixeduinterror"]]]],[11,"min_value","","Returns the smallest value that can be represented by this integer type.",19,[[],["self"]]],[11,"max_value","","Returns the largest value that can be represented by this integer type.",19,[[],["self"]]],[11,"count_ones","","Returns the number of ones in the binary representation of self.",19,[[["self"]],["u32"]]],[11,"count_zeros","","Returns the number of zeros in the binary representation of self.",19,[[["self"]],["u32"]]],[11,"leading_zeros","","Returns the number of leading zeros in the binary representation of self.",19,[[["self"]],["u32"]]],[11,"trailing_zeros","","Returns the number of trailing zeros in the binary representation of self.",19,[[["self"]],["u32"]]],[11,"checked_add","","Checked integer addition. Computes `self + rhs`, returning `None` if overflow occurred.",19,[[["self"],["self"]],["option"]]],[11,"checked_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",19,[[["self"],["self"]],["option"]]],[11,"checked_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",19,[[["self"],["self"]],["option"]]],[11,"checked_div","","Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`.",19,[[["self"],["self"]],["option"]]],[11,"checked_rem","","Checked integer remainder. Computes `self % rhs`, returning `None` if `rhs == 0`.",19,[[["self"],["self"]],["option"]]],[11,"checked_shl","","Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",19,[[["self"],["u128"]],["option"]]],[11,"checked_shr","","Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is larger than or equal to the number of bits in `self`.",19,[[["self"],["u128"]],["option"]]],[11,"checked_neg","","Checked negation. Computes `-self`, returning `None` unless `self == 0`. Note that negating any positive integer will overflow.",19,[[["self"]],["option"]]],[11,"saturating_add","","Saturating integer addition. Computes `self + rhs`, saturating at the numeric bounds instead of overflowing.",19,[[["self"],["self"]],["self"]]],[11,"saturating_sub","","Checked integer subtraction. Computes `self - rhs`, returning `None` if overflow occurred.",19,[[["self"],["self"]],["self"]]],[11,"saturating_mul","","Checked integer multiplication. Computes `self * rhs`, returning `None` if overflow occurred.",19,[[["self"],["self"]],["self"]]],[11,"overflowing_add","","Calculates `self + rhs`.",19,N],[11,"overflowing_sub","","Calculates `self - rhs`.",19,N],[11,"overflowing_mul","","Calculates the multiplication of `self` and `rhs`.",19,N],[11,"overflowing_div","","Calculates the divisor when `self` is divided by `rhs`.",19,N],[11,"overflowing_rem","","Calculates the remainder when `self` is divided by `rhs`.",19,N],[11,"overflowing_shl","","Shifts `self` left by `rhs` bits.",19,N],[11,"overflowing_shr","","Shifts `self` right by `rhs` bits.",19,N],[11,"overflowing_neg","","Negates `self` in an overflowing fashion.",19,N],[11,"random","","Create a random fixed uint with a input random core.",19,[[["r"]],["self"]]],[11,"thread_random","","Create a random fixed uint.",19,[[],["self"]]],[11,"clone","","",19,[[["self"]],["self"]]],[11,"default","","",19,[[],["self"]]],[11,"eq","","",19,[[["self"],["self"]],["bool"]]],[11,"partial_cmp","","",19,[[["self"],["self"]],["option",["ordering"]]]],[11,"cmp","","",19,[[["self"],["self"]],["ordering"]]],[11,"add","","",19,N],[11,"add_assign","","",19,[[["self"],["rhs"]]]],[11,"add","","",19,N],[11,"add_assign","","",19,[[["self"],["h4096"]]]],[11,"sub","","",19,N],[11,"sub_assign","","",19,[[["self"],["rhs"]]]],[11,"sub","","",19,N],[11,"sub_assign","","",19,[[["self"],["h4096"]]]],[11,"mul","","",19,N],[11,"mul_assign","","",19,[[["self"],["rhs"]]]],[11,"mul","","",19,N],[11,"mul_assign","","",19,[[["self"],["h4096"]]]],[11,"div","","",19,N],[11,"div_assign","","",19,[[["self"],["rhs"]]]],[11,"div","","",19,N],[11,"div_assign","","",19,[[["self"],["h4096"]]]],[11,"rem","","",19,N],[11,"rem_assign","","",19,[[["self"],["rhs"]]]],[11,"rem","","",19,N],[11,"rem_assign","","",19,[[["self"],["h4096"]]]],[11,"bitand","","",19,N],[11,"bitand_assign","","",19,[[["self"],["rhs"]]]],[11,"bitand","","",19,N],[11,"bitand_assign","","",19,[[["self"],["h4096"]]]],[11,"bitor","","",19,N],[11,"bitor_assign","","",19,[[["self"],["rhs"]]]],[11,"bitor","","",19,N],[11,"bitor_assign","","",19,[[["self"],["h4096"]]]],[11,"bitxor","","",19,N],[11,"bitxor_assign","","",19,[[["self"],["rhs"]]]],[11,"bitxor","","",19,N],[11,"bitxor_assign","","",19,[[["self"],["h4096"]]]],[11,"not","","",19,N],[11,"shl","","",19,N],[11,"shl","","",19,N],[11,"shl_assign","","",19,[[["self"],["u8"]]]],[11,"shl_assign","","",19,[[["self"],["u8"]]]],[11,"shl","","",19,N],[11,"shl","","",19,N],[11,"shl_assign","","",19,[[["self"],["u16"]]]],[11,"shl_assign","","",19,[[["self"],["u16"]]]],[11,"shl","","",19,N],[11,"shl","","",19,N],[11,"shl_assign","","",19,[[["self"],["u32"]]]],[11,"shl_assign","","",19,[[["self"],["u32"]]]],[11,"shl","","",19,N],[11,"shl","","",19,N],[11,"shl_assign","","",19,[[["self"],["u64"]]]],[11,"shl_assign","","",19,[[["self"],["u64"]]]],[11,"shl","","",19,N],[11,"shl","","",19,N],[11,"shl_assign","","",19,[[["self"],["u128"]]]],[11,"shl_assign","","",19,[[["self"],["u128"]]]],[11,"shl","","",19,N],[11,"shl","","",19,N],[11,"shl_assign","","",19,[[["self"],["usize"]]]],[11,"shl_assign","","",19,[[["self"],["usize"]]]],[11,"shl","","",19,N],[11,"shl","","",19,N],[11,"shl_assign","","",19,[[["self"],["i8"]]]],[11,"shl_assign","","",19,[[["self"],["i8"]]]],[11,"shl","","",19,N],[11,"shl","","",19,N],[11,"shl_assign","","",19,[[["self"],["i16"]]]],[11,"shl_assign","","",19,[[["self"],["i16"]]]],[11,"shl","","",19,N],[11,"shl","","",19,N],[11,"shl_assign","","",19,[[["self"],["i32"]]]],[11,"shl_assign","","",19,[[["self"],["i32"]]]],[11,"shl","","",19,N],[11,"shl","","",19,N],[11,"shl_assign","","",19,[[["self"],["i64"]]]],[11,"shl_assign","","",19,[[["self"],["i64"]]]],[11,"shl","","",19,N],[11,"shl","","",19,N],[11,"shl_assign","","",19,[[["self"],["i128"]]]],[11,"shl_assign","","",19,[[["self"],["i128"]]]],[11,"shl","","",19,N],[11,"shl","","",19,N],[11,"shl_assign","","",19,[[["self"],["isize"]]]],[11,"shl_assign","","",19,[[["self"],["isize"]]]],[11,"shr","","",19,N],[11,"shr","","",19,N],[11,"shr_assign","","",19,[[["self"],["u8"]]]],[11,"shr_assign","","",19,[[["self"],["u8"]]]],[11,"shr","","",19,N],[11,"shr","","",19,N],[11,"shr_assign","","",19,[[["self"],["u16"]]]],[11,"shr_assign","","",19,[[["self"],["u16"]]]],[11,"shr","","",19,N],[11,"shr","","",19,N],[11,"shr_assign","","",19,[[["self"],["u32"]]]],[11,"shr_assign","","",19,[[["self"],["u32"]]]],[11,"shr","","",19,N],[11,"shr","","",19,N],[11,"shr_assign","","",19,[[["self"],["u64"]]]],[11,"shr_assign","","",19,[[["self"],["u64"]]]],[11,"shr","","",19,N],[11,"shr","","",19,N],[11,"shr_assign","","",19,[[["self"],["u128"]]]],[11,"shr_assign","","",19,[[["self"],["u128"]]]],[11,"shr","","",19,N],[11,"shr","","",19,N],[11,"shr_assign","","",19,[[["self"],["usize"]]]],[11,"shr_assign","","",19,[[["self"],["usize"]]]],[11,"shr","","",19,N],[11,"shr","","",19,N],[11,"shr_assign","","",19,[[["self"],["i8"]]]],[11,"shr_assign","","",19,[[["self"],["i8"]]]],[11,"shr","","",19,N],[11,"shr","","",19,N],[11,"shr_assign","","",19,[[["self"],["i16"]]]],[11,"shr_assign","","",19,[[["self"],["i16"]]]],[11,"shr","","",19,N],[11,"shr","","",19,N],[11,"shr_assign","","",19,[[["self"],["i32"]]]],[11,"shr_assign","","",19,[[["self"],["i32"]]]],[11,"shr","","",19,N],[11,"shr","","",19,N],[11,"shr_assign","","",19,[[["self"],["i64"]]]],[11,"shr_assign","","",19,[[["self"],["i64"]]]],[11,"shr","","",19,N],[11,"shr","","",19,N],[11,"shr_assign","","",19,[[["self"],["i128"]]]],[11,"shr_assign","","",19,[[["self"],["i128"]]]],[11,"shr","","",19,N],[11,"shr","","",19,N],[11,"shr_assign","","",19,[[["self"],["isize"]]]],[11,"shr_assign","","",19,[[["self"],["isize"]]]],[11,"from","","",19,[[["bool"]],["self"]]],[11,"from","","",19,[[["u8"]],["self"]]],[11,"from","","",19,[[["u8"]],["self"]]],[11,"from","","",19,[[["u16"]],["self"]]],[11,"from","","",19,[[["u16"]],["self"]]],[11,"from","","",19,[[["u32"]],["self"]]],[11,"from","","",19,[[["u32"]],["self"]]],[11,"from","","",19,[[["u64"]],["self"]]],[11,"from","","",19,[[["u64"]],["self"]]],[11,"from","","",19,[[["u128"]],["self"]]],[11,"from","","",19,[[["u128"]],["self"]]],[11,"fmt","","",19,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",19,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",19,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",19,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",19,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",19,[[["self"],["formatter"]],["result"]]],[11,"hash","","",19,[[["self"],["h"]]]],[11,"sum","","",19,[[["i"]],["self"]]],[11,"sum","","",19,[[["i"]],["self"]]],[11,"product","","",19,[[["i"]],["self"]]],[11,"product","","",19,[[["i"]],["self"]]],[11,"as_byte_slice_mut","","",19,N],[11,"to_le","","",19,[[["self"]]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"from","","",0,[[["t"]],["t"]]],[11,"to_string","","",0,[[["self"]],["string"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,N],[11,"from","","",1,[[["t"]],["t"]]],[11,"to_string","","",1,[[["self"]],["string"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,N],[11,"from","","",2,[[["t"]],["t"]]],[11,"to_string","","",2,[[["self"]],["string"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"to_owned","","",3,[[["self"]],["t"]]],[11,"clone_into","","",3,N],[11,"from","","",3,[[["t"]],["t"]]],[11,"to_string","","",3,[[["self"]],["string"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"to_owned","","",4,[[["self"]],["t"]]],[11,"clone_into","","",4,N],[11,"from","","",4,[[["t"]],["t"]]],[11,"to_string","","",4,[[["self"]],["string"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"to_owned","","",5,[[["self"]],["t"]]],[11,"clone_into","","",5,N],[11,"from","","",5,[[["t"]],["t"]]],[11,"to_string","","",5,[[["self"]],["string"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"to_owned","","",6,[[["self"]],["t"]]],[11,"clone_into","","",6,N],[11,"from","","",6,[[["t"]],["t"]]],[11,"to_string","","",6,[[["self"]],["string"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"to_owned","","",7,[[["self"]],["t"]]],[11,"clone_into","","",7,N],[11,"from","","",7,[[["t"]],["t"]]],[11,"to_string","","",7,[[["self"]],["string"]]],[11,"into","","",7,[[["self"]],["u"]]],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"get_type_id","","",7,[[["self"]],["typeid"]]],[11,"to_owned","","",8,[[["self"]],["t"]]],[11,"clone_into","","",8,N],[11,"from","","",8,[[["t"]],["t"]]],[11,"to_string","","",8,[[["self"]],["string"]]],[11,"into","","",8,[[["self"]],["u"]]],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"try_into","","",8,[[["self"]],["result"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"get_type_id","","",8,[[["self"]],["typeid"]]],[11,"to_owned","","",9,[[["self"]],["t"]]],[11,"clone_into","","",9,N],[11,"from","","",9,[[["t"]],["t"]]],[11,"to_string","","",9,[[["self"]],["string"]]],[11,"into","","",9,[[["self"]],["u"]]],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"try_into","","",9,[[["self"]],["result"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"get_type_id","","",9,[[["self"]],["typeid"]]],[11,"to_owned","","",10,[[["self"]],["t"]]],[11,"clone_into","","",10,N],[11,"from","","",10,[[["t"]],["t"]]],[11,"to_string","","",10,[[["self"]],["string"]]],[11,"into","","",10,[[["self"]],["u"]]],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"try_into","","",10,[[["self"]],["result"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"get_type_id","","",10,[[["self"]],["typeid"]]],[11,"to_owned","","",11,[[["self"]],["t"]]],[11,"clone_into","","",11,N],[11,"from","","",11,[[["t"]],["t"]]],[11,"to_string","","",11,[[["self"]],["string"]]],[11,"into","","",11,[[["self"]],["u"]]],[11,"try_from","","",11,[[["u"]],["result"]]],[11,"borrow","","",11,[[["self"]],["t"]]],[11,"try_into","","",11,[[["self"]],["result"]]],[11,"borrow_mut","","",11,[[["self"]],["t"]]],[11,"get_type_id","","",11,[[["self"]],["typeid"]]],[11,"to_owned","","",12,[[["self"]],["t"]]],[11,"clone_into","","",12,N],[11,"from","","",12,[[["t"]],["t"]]],[11,"to_string","","",12,[[["self"]],["string"]]],[11,"into","","",12,[[["self"]],["u"]]],[11,"try_from","","",12,[[["u"]],["result"]]],[11,"borrow","","",12,[[["self"]],["t"]]],[11,"try_into","","",12,[[["self"]],["result"]]],[11,"borrow_mut","","",12,[[["self"]],["t"]]],[11,"get_type_id","","",12,[[["self"]],["typeid"]]],[11,"to_owned","","",13,[[["self"]],["t"]]],[11,"clone_into","","",13,N],[11,"from","","",13,[[["t"]],["t"]]],[11,"to_string","","",13,[[["self"]],["string"]]],[11,"into","","",13,[[["self"]],["u"]]],[11,"try_from","","",13,[[["u"]],["result"]]],[11,"borrow","","",13,[[["self"]],["t"]]],[11,"try_into","","",13,[[["self"]],["result"]]],[11,"borrow_mut","","",13,[[["self"]],["t"]]],[11,"get_type_id","","",13,[[["self"]],["typeid"]]],[11,"to_owned","","",14,[[["self"]],["t"]]],[11,"clone_into","","",14,N],[11,"from","","",14,[[["t"]],["t"]]],[11,"to_string","","",14,[[["self"]],["string"]]],[11,"into","","",14,[[["self"]],["u"]]],[11,"try_from","","",14,[[["u"]],["result"]]],[11,"borrow","","",14,[[["self"]],["t"]]],[11,"try_into","","",14,[[["self"]],["result"]]],[11,"borrow_mut","","",14,[[["self"]],["t"]]],[11,"get_type_id","","",14,[[["self"]],["typeid"]]],[11,"to_owned","","",15,[[["self"]],["t"]]],[11,"clone_into","","",15,N],[11,"from","","",15,[[["t"]],["t"]]],[11,"to_string","","",15,[[["self"]],["string"]]],[11,"into","","",15,[[["self"]],["u"]]],[11,"try_from","","",15,[[["u"]],["result"]]],[11,"borrow","","",15,[[["self"]],["t"]]],[11,"try_into","","",15,[[["self"]],["result"]]],[11,"borrow_mut","","",15,[[["self"]],["t"]]],[11,"get_type_id","","",15,[[["self"]],["typeid"]]],[11,"to_owned","","",16,[[["self"]],["t"]]],[11,"clone_into","","",16,N],[11,"from","","",16,[[["t"]],["t"]]],[11,"to_string","","",16,[[["self"]],["string"]]],[11,"into","","",16,[[["self"]],["u"]]],[11,"try_from","","",16,[[["u"]],["result"]]],[11,"borrow","","",16,[[["self"]],["t"]]],[11,"try_into","","",16,[[["self"]],["result"]]],[11,"borrow_mut","","",16,[[["self"]],["t"]]],[11,"get_type_id","","",16,[[["self"]],["typeid"]]],[11,"to_owned","","",17,[[["self"]],["t"]]],[11,"clone_into","","",17,N],[11,"from","","",17,[[["t"]],["t"]]],[11,"to_string","","",17,[[["self"]],["string"]]],[11,"into","","",17,[[["self"]],["u"]]],[11,"try_from","","",17,[[["u"]],["result"]]],[11,"borrow","","",17,[[["self"]],["t"]]],[11,"try_into","","",17,[[["self"]],["result"]]],[11,"borrow_mut","","",17,[[["self"]],["t"]]],[11,"get_type_id","","",17,[[["self"]],["typeid"]]],[11,"to_owned","","",18,[[["self"]],["t"]]],[11,"clone_into","","",18,N],[11,"from","","",18,[[["t"]],["t"]]],[11,"to_string","","",18,[[["self"]],["string"]]],[11,"into","","",18,[[["self"]],["u"]]],[11,"try_from","","",18,[[["u"]],["result"]]],[11,"borrow","","",18,[[["self"]],["t"]]],[11,"try_into","","",18,[[["self"]],["result"]]],[11,"borrow_mut","","",18,[[["self"]],["t"]]],[11,"get_type_id","","",18,[[["self"]],["typeid"]]],[11,"to_owned","","",19,[[["self"]],["t"]]],[11,"clone_into","","",19,N],[11,"from","","",19,[[["t"]],["t"]]],[11,"to_string","","",19,[[["self"]],["string"]]],[11,"into","","",19,[[["self"]],["u"]]],[11,"try_from","","",19,[[["u"]],["result"]]],[11,"borrow","","",19,[[["self"]],["t"]]],[11,"try_into","","",19,[[["self"]],["result"]]],[11,"borrow_mut","","",19,[[["self"]],["t"]]],[11,"get_type_id","","",19,[[["self"]],["typeid"]]],[11,"from","","",20,[[["t"]],["t"]]],[11,"to_string","","",20,[[["self"]],["string"]]],[11,"into","","",20,[[["self"]],["u"]]],[11,"try_from","","",20,[[["u"]],["result"]]],[11,"borrow","","",20,[[["self"]],["t"]]],[11,"try_into","","",20,[[["self"]],["result"]]],[11,"borrow_mut","","",20,[[["self"]],["t"]]],[11,"get_type_id","","",20,[[["self"]],["typeid"]]],[11,"as_fail","","",20,[[["self"]],["fail"]]],[11,"from","","",21,[[["t"]],["t"]]],[11,"to_string","","",21,[[["self"]],["string"]]],[11,"into","","",21,[[["self"]],["u"]]],[11,"try_from","","",21,[[["u"]],["result"]]],[11,"borrow","","",21,[[["self"]],["t"]]],[11,"try_into","","",21,[[["self"]],["result"]]],[11,"borrow_mut","","",21,[[["self"]],["t"]]],[11,"get_type_id","","",21,[[["self"]],["typeid"]]],[11,"as_fail","","",21,[[["self"]],["fail"]]],[11,"from","","",22,[[["t"]],["t"]]],[11,"to_string","","",22,[[["self"]],["string"]]],[11,"into","","",22,[[["self"]],["u"]]],[11,"try_from","","",22,[[["u"]],["result"]]],[11,"borrow","","",22,[[["self"]],["t"]]],[11,"try_into","","",22,[[["self"]],["result"]]],[11,"borrow_mut","","",22,[[["self"]],["t"]]],[11,"get_type_id","","",22,[[["self"]],["typeid"]]],[11,"as_fail","","",22,[[["self"]],["fail"]]],[11,"from","","",23,[[["t"]],["t"]]],[11,"to_string","","",23,[[["self"]],["string"]]],[11,"into","","",23,[[["self"]],["u"]]],[11,"try_from","","",23,[[["u"]],["result"]]],[11,"borrow","","",23,[[["self"]],["t"]]],[11,"try_into","","",23,[[["self"]],["result"]]],[11,"borrow_mut","","",23,[[["self"]],["t"]]],[11,"get_type_id","","",23,[[["self"]],["typeid"]]],[11,"as_fail","","",23,[[["self"]],["fail"]]]],"paths":[[3,"U128"],[3,"U160"],[3,"U224"],[3,"U256"],[3,"U384"],[3,"U512"],[3,"U520"],[3,"U1024"],[3,"U2048"],[3,"U4096"],[3,"H128"],[3,"H160"],[3,"H224"],[3,"H256"],[3,"H384"],[3,"H512"],[3,"H520"],[3,"H1024"],[3,"H2048"],[3,"H4096"],[4,"FromSliceError"],[4,"IntoSliceError"],[4,"FromStrError"],[4,"FixedUintError"],[8,"UintConvert"]]};
searchIndex["numext_fixed_uint_macros"]={"doc":"","items":[[5,"construct_fixed_uints","numext_fixed_uint_macros","",N,[[["tokenstream"]],["tokenstream"]]]],"paths":[]};
searchIndex["numext_fixed_uint_tests"]={"doc":"","items":[[0,"props","numext_fixed_uint_tests","Support proptest.",N,N],[3,"U256LeBytes","numext_fixed_uint_tests::props","",N,N],[12,"inner","","",0,N],[3,"U256LeBytesValueTree","","",N,N],[3,"U256LeBytesParameters","","",N,N],[3,"U256LeBytesStrategy","","",N,N],[3,"U256Pair","","",N,N],[12,"lhs","","",1,N],[12,"rhs","","",1,N],[12,"opr","","",1,N],[3,"U256PairValueTree","","",N,N],[3,"U256PairStrategy","","",N,N],[4,"U256PairParameters","","",N,N],[13,"Random","","",2,N],[13,"CanAdd","","",2,N],[13,"CanSub","","",2,N],[13,"CanMul","","",2,N],[13,"CanDiv","","",2,N],[13,"CanRem","","",2,N],[11,"clone","","",2,[[["self"]],["u256pairparameters"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"default","","",2,[[],["self"]]],[11,"clone","","",0,[[["self"]],["u256lebytes"]]],[11,"eq","","",0,[[["self"],["u256lebytes"]],["bool"]]],[11,"ne","","",0,[[["self"],["u256lebytes"]],["bool"]]],[11,"partial_cmp","","",0,[[["self"],["u256lebytes"]],["option",["ordering"]]]],[11,"lt","","",0,[[["self"],["u256lebytes"]],["bool"]]],[11,"le","","",0,[[["self"],["u256lebytes"]],["bool"]]],[11,"gt","","",0,[[["self"],["u256lebytes"]],["bool"]]],[11,"ge","","",0,[[["self"],["u256lebytes"]],["bool"]]],[11,"cmp","","",0,[[["self"],["u256lebytes"]],["ordering"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"from","","",0,[[["u256"]],["self"]]],[11,"from","","",0,[[["u256"]],["self"]]],[11,"from","","",0,[[["u256"]],["self"]]],[11,"from","","",0,[[["u256"]],["self"]]],[11,"any","","",0,[[["testrng"]],["self"]]],[11,"nonzero","","",0,[[["testrng"]],["self"]]],[11,"bigger","","",0,[[["self"],["testrng"]],["self"]]],[11,"nonzero_pair","","",0,N],[11,"nonzero_pair_asc","","",0,N],[11,"nonzero_pair_desc","","",0,N],[11,"can_add_without_overflow","","",0,N],[11,"can_mul_without_overflow","","",0,N],[11,"new","","",3,[[["testrunner"]],["self"]]],[11,"current","","",3,N],[11,"simplify","","",3,[[["self"]],["bool"]]],[11,"complicate","","",3,[[["self"]],["bool"]]],[11,"clone","","",4,[[["self"]],["u256lebytesparameters"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"default","","",4,[[],["u256lebytesparameters"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"new","","",5,[[["u256lebytesparameters"]],["self"]]],[11,"new_tree","","",5,[[["self"],["testrunner"]],["newtree"]]],[11,"arbitrary_with","","",0,N],[11,"clone","","",1,[[["self"]],["u256pair"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"new","","",1,[[["u256pairparameters"],["testrng"]],["self"]]],[11,"new","","",6,[[["u256pairparameters"],["testrunner"]],["self"]]],[11,"current","","",6,N],[11,"simplify","","",6,[[["self"]],["bool"]]],[11,"complicate","","",6,[[["self"]],["bool"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"new","","",7,[[["u256pairparameters"]],["self"]]],[11,"new_tree","","",7,[[["self"],["testrunner"]],["newtree"]]],[11,"arbitrary_with","","",1,N],[0,"tools","numext_fixed_uint_tests","Testing tools.",N,N],[5,"gen_nonzero","numext_fixed_uint_tests::tools","",N,[[],["t"]]],[5,"pair","","",N,[[["u256pairparameters"]],["u256pair"]]],[5,"lebytes","","",N,[[],["u256lebytes"]]],[11,"to_owned","numext_fixed_uint_tests::props","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"from","","",0,[[["t"]],["t"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"to_owned","","",4,[[["self"]],["t"]]],[11,"clone_into","","",4,N],[11,"from","","",4,[[["t"]],["t"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"from","","",5,[[["t"]],["t"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,N],[11,"from","","",1,[[["t"]],["t"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"from","","",6,[[["t"]],["t"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"from","","",7,[[["t"]],["t"]]],[11,"into","","",7,[[["self"]],["u"]]],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"get_type_id","","",7,[[["self"]],["typeid"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,N],[11,"from","","",2,[[["t"]],["t"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]]],"paths":[[3,"U256LeBytes"],[3,"U256Pair"],[4,"U256PairParameters"],[3,"U256LeBytesValueTree"],[3,"U256LeBytesParameters"],[3,"U256LeBytesStrategy"],[3,"U256PairValueTree"],[3,"U256PairStrategy"]]};
initSearch(searchIndex);
